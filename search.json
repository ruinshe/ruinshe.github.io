[{"title":"git push 前自动检查版本号","url":"/2019/12/22/auto-update-version-for-git/","content":"在做平时开发的时候，经常会遇到需要在 git push 的时候顺便更新版本号的情况，当版本号没有修改就 git push 的提醒用户修改，并 git amend 生效。一般这种情况会在版本号满足和 push 相关的时候发生，比如说版本号是 major.minor.patch-commit 的形式，这样的话，可以通过自定义的 push-hook 来实现功能。\n\n比如说在本地根目录下创建一个 hook 文件 hooks/pre-push。\n#! /bin/shset -o nounsetset -o errexit# The version file to be update.VERSION_FILE=package.json# The version pattern in the version file.VERSION_FILTER='\"version\": 'CODE_BASE=$(git rev-parse --show-toplevel)BRANCH=$(git branch | cut -d ' ' -f 2)BRANCH_TO_UPDATE_VERSION=master# If there is multiple remotes to be set in the repository, considering hard coded the next line to origin/master or similar.# Actually we need to filter the branch mapping by `git remote -v` if the branch is not mapped by name.REMOTE=$(git remote)/$BRANCHif [ \"$BRANCH\" = \"$BRANCH_TO_UPDATE_VERSION\" ]; then    CHANGES=$(git diff \"$BRANCH\"..\"$REMOTE\" | wc -l)    if [ \"$CHANGES\" -gt \"0\" ]; then        VERSION_CHANGED=$(git diff \"$BRANCH\"..\"$REMOTE\" \\                              -G ${VERSION_FILTER} -- ${CODE_BASE}/${VERSION_FILE} | wc -l)        if [ \"$VERSION_CHANGED\" -gt \"0\" ]; then            # In this case, the vesion was already updated.            exit 0        else            # if you wan to directly print error output, using this line.            printf \"\\033[0;31mERROR: the version in file ${VERSION_FILE} was not updated.\\033[0m\\n\"            exit 1        fi    fifi\n并将这个 hook 直接软链接到当前项目的 hooks 目录中\nln -fs $PWD/hooks/pre-push $PWD/.git/hooks/\n","categories":["development"],"tags":["git"]},{"title":"修复 WSL2 下 Git 仓库文件损坏的问题","url":"/2021/11/29/fix-git-corruption-on-wsl2/","content":"如果经常使用 WSL2 的时候不关闭虚拟机直接关机，会出现 Git 仓库文件损坏的情况，以下摘抄一个简单的解决方案：\n\n一般索引损坏的表现是发现有一些索引文件是空的，然后 Git 命令找不到相关的引用，比如说如下的情况：\n$ git statuserror: object file .git/objects/82/3ab829ac51fdba3d0b219fdc7370480f193cdc is emptyerror: object file .git/objects/82/3ab829ac51fdba3d0b219fdc7370480f193cdc is emptyfatal: loose object 823ab829ac51fdba3d0b219fdc7370480f193cdc (stored in .git/objects/82/3ab829ac51fdba3d0b219fdc7370480f193cdc) is corrupt\n如果说只是单纯的 Git 索引损坏，可以直接将这些文件删除，然后重新从云端拉取最新的索引：\n$ find .git/objects/ -type f -empty | xargs rm$ git fetch -p$ git fsck --full\n如果在接取索引的时候遇到类似如下的错误，可以手动删除对应的文件，然后重新运行 git fetch\nerror: refs/remotes/origin/HEAD: invalid sha1 pointer 0000000000000000000000000000000000000000error: refs/remotes/origin/master: invalid sha1 pointer 0000000000000000000000000000000000000000error: bad ref for .git/logs/refs/remotes/origin/HEADerror: bad ref for .git/logs/refs/remotes/origin/master\n","categories":["development"],"tags":["git"]},{"title":"Git - 删除无用的文件历史记录","url":"/2015/08/07/remove-unused-git-history/","content":"这几个晚上在倒腾 CDOJ 的 git repository，在家试着 git clone 了一把，第一感觉是\n坑爹啊，这是什么鬼，为什么会有100多MB的history。\n国内的情况你们懂的，花了 10 来分钟才把 repo 下下来，想了下原因，大致上是：昀大爷年轻的时候把 MathJax 和 Font 之类的前端 module 给 push 上去了，还不时地移了几次位置，更新了几次版本，就这样把几百 MB 的东西加到历史里去了。。。\n那么问题来了，怎么要才能把这些 “没有必要存在” 的文件从 git history 里面给干掉呢？这里推荐一个相对简单的办法（更简单的办法是用 bfg ，然而家里的网络直接装都装不上，我放弃了）。\n\n 想起来你要删的文件是什么\n在这里我们用 MathJax.zip 做例子。\n 用 git filter-branch 去看下有多少 commits 和你选择的文件相关。\n$ git log --stat | grep -B 10 -A 10 MathJax\\\\.zip\n在这里， grep 的 A 和 B 参数表示的是 after 和 before，这样可以大致上看到一个 commit 的 context。\n 把你所不关心的文件从历史记录中删掉\n$ git filter-branch --force --index-filter \\    'git rm --cache --ignore-unmatch MathJax.zip' \\    --prune-empty --tag-name-filter cat -- --all\n 清理下你的本地 git repo\n$ git for-each-ref --format='delete %(refname)' refs/original | git update-ref --stdin$ git reflog expire --expire=now --all$ git gc --prune=now --aggressive\n 强制刷新 remote repo 的内容\n$ git push origin --force --all$ git push origin --force --tags\n","categories":["development"],"tags":["git"]},{"title":"HDU1251 字典树","url":"/2010/11/06/obsidian/053c5f8e-ac8f-4f1c-b1fe-afc92402cf3a/","content":"这题还是一样的题型，插入和查询，这次查询 find 函数中要注意的就是如果遍历到一个结点之后对应的 next 指针为空，就返回 0。\n用 cnt 记录前缀出现次数，这时候就不用 danger 标记了。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;numeric&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;using namespace std;const int MAX = 1000000;struct Node {  int cnt;  Node* ne[26];} node[MAX], *root;int K;Node* New() {  Node* ret = &amp;node[K++];  ret-&gt;cnt = 0;  for (int i = 0; i &lt; 26; i++) {    ret-&gt;ne[i] = NULL;  }  return ret;}void init() {  K = 0;  root = New();}void insert(char* s) {  char* p = s;  Node* ptr = root;  int id;  while (*p) {    id = *(p++) - 'a';    ptr-&gt;cnt++;    if (ptr-&gt;ne[id] == NULL) {      ptr-&gt;ne[id] = New();    }    ptr = ptr-&gt;ne[id];  }  ptr-&gt;cnt++;}int find(char* s) {  char* p = s;  Node* ptr = root;  int id;  while (*p) {    id = *(p++) - 'a';    if (ptr-&gt;ne[id] == NULL) {      return 0;    }    ptr = ptr-&gt;ne[id];  }  return ptr-&gt;cnt;}int main() {  char s[120];  init();  while (gets(s), *s) {    insert(s);  }  while (gets(s)) {    printf(\"%d\\n\", find(s));  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"HNOI2004 宠物收养所  splay 入门","url":"/2010/10/21/obsidian/07d96af9-5ef7-4e24-b85c-5b58a46b2407/","content":"平衡二叉树的入门题，最近在研究 splay，就做了下，感觉题目不错，就写了。\n这题就是简单的元素插入删除操作，注意一下绝对值相同的时候取较小的即可，还有就是每次收养所里要么都是人，要么都是宠物。\n这里用到一个 typetypetype 变量记录树种元素是人还是宠物，如果是 -1 表示空\n这样每次取得一个数，如果和树种类型一致，就加入树种，否则就在树中寻找绝对值离它最近点一个即可。\n代码写的比较长，有些是这道题不需要的函数，主要是为了封装，全部写了出来，可以当模板用。只是多元素的处理没有弄好，如果有重复元素，rankrankrank 和 seleteseleteselete 函数以及结构体的封装就要换一下了。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int mod = 1000000;const int MAX = 150000;const int oo = 0x3f3f3f3f;typedef int keyType;struct Node {  keyType key;  int size;  Node* son[2];  Node* fa;} node[MAX], nil, *null;Node* root;int st[MAX], top, K;Node* New() {  if (top) {    return &amp;node[st[--top]];  } else {    return &amp;node[K++];  }}void Delete(Node* ptr) { st[top++] = ptr - node; }void update(Node* x) {  x-&gt;size = 1;  for (int i = 0; i &lt; 2; i++) {    if (x-&gt;son[i] != null) {      x-&gt;size += x-&gt;son[i]-&gt;size;    }  }}void rotate(Node* x, const int&amp; w) {  Node* y;  y = x-&gt;fa;  y-&gt;son[1 - w] = x-&gt;son[w];  if (x-&gt;son[w] != null) {    x-&gt;son[w]-&gt;fa = y;  }  x-&gt;fa = y-&gt;fa;  if (y-&gt;fa != null) {    if (y == y-&gt;fa-&gt;son[0]) {      y-&gt;fa-&gt;son[0] = x;    } else {      y-&gt;fa-&gt;son[1] = x;    }  }  x-&gt;son[w] = y;  y-&gt;fa = x;  update(y);  update(x);}void splay(Node* x, Node* y) {  while (x-&gt;fa != y) {    if (x-&gt;fa-&gt;fa == y) {      if (x == x-&gt;fa-&gt;son[0]) {        rotate(x, 1);      } else {        rotate(x, 0);      }    } else {      if (x-&gt;fa == x-&gt;fa-&gt;fa-&gt;son[0]) {        if (x == x-&gt;fa-&gt;son[0]) {          rotate(x-&gt;fa, 1);          rotate(x, 1);        } else {          rotate(x, 0);          rotate(x, 1);        }      } else {        if (x == x-&gt;fa-&gt;son[1]) {          rotate(x-&gt;fa, 0);          rotate(x, 0);        } else {          rotate(x, 1);          rotate(x, 0);        }      }    }  }  if (y == null) {    root = x;  }}void addNode(Node* x, Node* father, keyType val) {  x-&gt;key = val;  x-&gt;fa = father;  x-&gt;son[0] = x-&gt;son[1] = null;  x-&gt;size = 1;}void insert(keyType x) {  Node *y, *z;  if (root == null) {    y = New();    root = y;    addNode(y, null, x);    return;  }  y = root;  do {    y-&gt;size++;    if (x &lt; y-&gt;key) {      if (y-&gt;son[0] != null) {        y = y-&gt;son[0];      } else {        z = New();        addNode(z, y, x);        y-&gt;son[0] = z;        y = z;        break;      }    } else {      if (y-&gt;son[1] != null) {        y = y-&gt;son[1];      } else {        z = New();        addNode(z, y, x);        y-&gt;son[1] = z;        y = z;        break;      }    }  } while (true);  splay(y, null);}Node* find(keyType x) {  Node* y;  y = root;  do {    if (y-&gt;key == x) {      break;    }    if (x &lt; y-&gt;key) {      if (y-&gt;son[0] == null) {        break;      } else {        y = y-&gt;son[0];      }    } else {      if (y-&gt;son[1] == null) {        break;      } else {        y = y-&gt;son[1];      }    }  } while (true);  splay(y, null);  return y;}bool exist(keyType x) {  Node* y;  y = root;  while (y != null &amp;&amp; y-&gt;key != x) {    if (x &lt; y-&gt;key) {      y = y-&gt;son[0];    } else {      y = y-&gt;son[1];    }  }  if (y != null) splay(y, null);  return y != null;}void init() {  nil.size = 0;  null = &amp;nil;  K = 0;  top = 0;  root = null;}void Delete(keyType x) {  Node *y, *z;  y = find(x);  splay(y, null);  if (y-&gt;son[0] == null) {    if (y-&gt;son[1] == null) {      init();    } else {      root = y-&gt;son[1];      y-&gt;son[1]-&gt;fa = null;    }  } else {    z = y-&gt;son[0];    while (z-&gt;son[1] != null) z = z-&gt;son[1];    splay(z, y);    z-&gt;son[1] = y-&gt;son[1];    if (y-&gt;son[1] != null) {      y-&gt;son[1]-&gt;fa = z;    };    z-&gt;fa = null;    root = z;    update(z);  }}keyType selete(int x) {  Node* y;  y = root;  while (1) {    if (x &lt;= y-&gt;son[0]-&gt;size) {      y = y-&gt;son[0];    } else {      if (x == y-&gt;son[0]-&gt;size + 1) {        break;      } else {        x = x - y-&gt;son[0]-&gt;size - 1;        y = y-&gt;son[1];      }    }  }  splay(y, null);  return y-&gt;key;}void deleteNums(keyType x) {  Node* y;  if (root == null) {    return;  }  y = find(x);  splay(y, null);  y-&gt;son[1] = null;  if (y-&gt;key &gt;= x) {    if (y-&gt;son[0] == null) {      init();    } else {      root = y-&gt;son[0];      y-&gt;son[0]-&gt;fa = null;    }  }}int rank(keyType x) {  Node* y;  if (root == null) {    return 0;  }  y = find(x);  splay(y, null);  return y-&gt;son[0]-&gt;size + (int)(y-&gt;key &lt;= x);}keyType maxSmall(keyType x) {  Node* y;  if (root == null) {    return -oo;  }  y = find(x);  splay(y, null);  if (y-&gt;key &gt; x) {    y = y-&gt;son[0];    if (y == null) {      return -oo;    }    while (y-&gt;son[1] != null) {      y = y-&gt;son[1];    }  }  return y-&gt;key;}keyType minBig(keyType x) {  Node* y;  if (root == null) {    return oo;  }  y = find(x);  splay(y, null);  if (y-&gt;key &lt; x) {    y = y-&gt;son[1];    if (y == null) {      return oo;    }    while (y-&gt;son[0] != null) {      y = y-&gt;son[0];    }  }  return y-&gt;key;}int cnt, ret;void run(int x) {  int t1, t2;  t1 = minBig(x);  t2 = maxSmall(x);  if (t1 == oo) {    ret = (ret + abs(x - t2)) % mod;    Delete(t2);    cnt--;  } else if (t2 == -oo) {    ret = (ret + abs(x - t1)) % mod;    Delete(t1);    cnt--;  } else if (abs(x - t1) &lt; abs(x - t2)) {    ret = (ret + abs(x - t1)) % mod;    Delete(t1);    cnt--;  } else if (abs(x - t1) == abs(x - t2)) {    if (t1 &lt; t2) {      ret = (ret + abs(x - t1)) % mod;      Delete(t1);      cnt--;    } else {      ret = (ret + abs(x - t2)) % mod;      Delete(t2);      cnt--;    }  } else {    ret = (ret + abs(x - t2)) % mod;    Delete(t2);    cnt--;  }}int main() {  int n;  int x, op;  int type;  while (~scanf(\"%d\", &amp;n)) {    init();    type = -1;    cnt = 0;    ret = 0;    for (int i = 0; i &lt; n; i++) {      scanf(\"%d%d\", &amp;op, &amp;x);      if (type == -1 || type == op) {        type = op;        insert(x);        cnt++;      } else {        run(x);        if (!cnt) {          type = -1;        }      }    }    printf(\"%d\\n\", ret);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"POJ3253 哈弗曼树的优先队列解法","url":"/2010/08/29/obsidian/0bd821f9-1f56-4bc8-adaf-0be91835aa4e/","content":"直接构造优先队列，每次取出最小的两个数相加，直到队列中只有一个数为止，还是用 STL 过的题。\n注意 priority_queue 的用法，原型：\npriority_queue&lt;Type&gt; q;priority_queue&lt;Type, deque&lt;Type&gt;, Comp&gt; q;\n其中 Type 是类型，Comp 是比较结构体，比较函数是它的括号重载，比如对 int 型从小到大排序的 Comp 结构体如下：\nstruct Comp {  bool operator()(const LL&amp; a, const LL&amp; b) const { return a &gt; b; }};\n这题还要注意使用 long long，不然会越界导致 WA。\n\n我的代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;typedef long long LL;struct Comp {  bool operator()(const LL&amp; a, const LL&amp; b) const { return a &gt; b; }};priority_queue&lt;LL, deque&lt;LL&gt;, Comp&gt; q;void init() {  LL n, a;  while (!q.empty()) q.pop();  scanf(\"%lld\", &amp;n);  while (n--) {    scanf(\"%lld\", &amp;a);    q.push(a);  }}LL run() {  LL ret = 0;  LL a, b;  while (1) {    a = q.top();    q.pop();    if (q.empty()) break;    b = q.top();    q.pop();    a += b;    ret += a;    q.push(a);  }  return ret;}int main() {  init();  printf(\"%lld\\n\", run());  return 0;}\n总结：做题的时候要注意数字的范围，看清到底要用什么类型，是 int 还是 long long。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"Codeforces Beta Round #24 ABC","url":"/2010/07/29/obsidian/13cab6f9-c01d-494e-af29-e09704bf1efb/","content":"做过 TC 的比赛感觉上了相对来说，Code Forces 的比赛应该会简单一些，不过很可惜，那晚第三题并没有拍出来，可能是时间不够了，卡在第一题上太久，有点悲剧。。。。\n\n A.Rind Road\n这题之前把它看成了图论的题目，没有看清题意，导致到了比赛前半个钟头才写出来，其实很简单，题意大概是说，有 nnn 个城市和 nnn 条单行道，所有的城市通过单行道连接成了一个环，每个单行道都有一个权值 ccc，如果要将单行道改个方向，就要花费 ccc 的价钱，现在我们的任务就是花费最小的价钱把 nnn 条单行道方向变成同向。\n我的方法是将城市看成结点，单行道看成有向边，建立一个图，由于 n≤100n \\leq 100n≤100，可以利用邻接矩阵来存储，最后从任意一个点出发，正反地跑两次 DFS，如果遇到权值为负的边 (边的方向和遍历的方向相反)，则把费用加 c。最后输出两个费用的较小值。\n后来想了想，可以只跑一次 DFS，然后把权值总和减去第一次的值就是我们第二次 DFS 得到的值。\n我原版的代码。\n&nbsp;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int a[101][2], w1[101][2], total, total1, mark[105];void dfs(int u) {  int i;  mark[u] = 1;  for (i = 0; i &lt;= 1; i++)    if (!mark[a[u][i]]) {      if (w1[u][i] &lt; 0) total += (-w1[u][i]);      dfs(a[u][i]);    }}void dfs1(int u) {  int i;  mark[u] = 1;  for (i = 1; i &gt;= 0; i--)    if (!mark[a[u][i]]) {      if (w1[u][i] &lt; 0) total1 += (-w1[u][i]);      dfs1(a[u][i]);    }}int main() {  int n, i, x, y, w;  scanf(\"%d\", &amp;n);  for (i = 0; i &lt; n; i++) {    scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w);    if (!a[x][0]) {      a[x][0] = y;      w1[x][0] = w;    } else {      a[x][1] = y;      w1[x][1] = w;    }    if (!a[y][0]) {      a[y][0] = x;      w1[y][0] = -w;    } else {      a[y][1] = x;      w1[y][1] = -w;    }  }  total = 0;  dfs(1);  if (w1[1][1] &gt; 0) total += w1[1][1];  memset(mark, 0, sizeof(mark));  total1 = 0;  dfs1(1);  if (w1[1][0] &gt; 0) total1 += w1[1][0];  if (total1 &lt; total)    printf(\"%d\\n\", total1);  else    printf(\"%d\\n\", total);}\n B.F1 Champions\n这题是我过的最快的一题，简单的排序，手写比较函数就可以了，题目大意是说，F1 比赛的冠军判断标准有两种，第一种判断积分大小，当积分相等的时候判断获得第一名的次数，还相等的话，判断获得第二的次数，以此类推；第二种判断获得第一名的次数，相等，则判断积分大小，还相等的话和第一种一样，依次比较第二名、第三名。。。\n写两个函数比较，分别进行两次排序，输出第一名即可。\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;const int rate[] = {25, 18, 15, 12, 10, 8, 6, 4, 2, 1};struct Node {  string name;  int point;  int rank[51];  Node() {    name = \"\";    point = 0;    memset(rank, 0, sizeof(rank));  }} node[51];map&lt;string, int&gt; mp;bool comp1(const Node&amp; a, const Node&amp; b) {  if (a.point != b.point) return a.point &gt; b.point;  for (int i = 0; i &lt; 51; i++)    if (a.rank[i] != b.rank[i]) return a.rank[i] &gt; b.rank[i];  return a.name &lt; b.name;}bool comp2(const Node&amp; a, const Node&amp; b) {  if (a.rank[0] != b.rank[0])    return a.rank[0] &gt; b.rank[0];  else if (a.point != b.point)    return a.point &gt; b.point;  for (int i = 1; i &lt; 51; i++)    if (a.rank[i] != b.rank[i]) return a.rank[i] &gt; b.rank[i];  return a.name &lt; b.name;}int main() {  int t, n, cnt = 0, pos;  string name;  char str[100];  scanf(\"%d\", &amp;t);  while (t--) {    scanf(\"%d\", &amp;n);    for (int i = 0; i &lt; n; i++) {      scanf(\"%s\", str);      name = str;      if (mp[name] == 0) {        cnt++;        mp[name] = cnt;        node[cnt].name = name;      }      pos = mp[name];      node[pos].rank[i]++;      if (i &lt; 10) node[pos].point += rate[i];    }  }  sort(node + 1, node + cnt + 1, comp1);  printf(\"%s\\n\", node[1].name.c_str());  sort(node + 1, node + cnt + 1, comp2);  printf(\"%s\\n\", node[1].name.c_str());  return 0;}\n C.Sequence of Point\n这题比较简单，比赛的时候写完代码测试数据没过，也没时间去改，就放弃了，将题意理清之后的到一些公式：\n这样将全部式子加起来，就可以得到完整的公式，由于 AiA_iAi​ 有周期，我们可以将其取模 2n2n2n，然后进行计算，为了计算方便，我重载了运算符，封装了一个点的结构体，其实算是向量了。。。\n注意题目给的 jjj 奇数偶数的时候 M0M_0M0​ 前面的符号不同\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;struct Point {  int x;  int y;  Point(int x = 0, int y = 0) {    this-&gt;x = x;    this-&gt;y = y;  }  Point(const Point&amp; point) {    x = point.x;    y = point.y;  }  ~Point() {}  Point operator+(const Point&amp; p) { return Point(x + p.x, y + p.y); }  Point operator-(const Point&amp; p) { return Point(x - p.x, y - p.y); }  int operator*(const Point&amp; p) { return x * p.x + y * p.y; }  void Show() { printf(\"%d %d\\n\", x, y); }  void Set(const int&amp; x = 0, const int&amp; y = 0) {    this-&gt;x = x;    this-&gt;y = y;  }};Point m0, a[100100];int main() {  int n;  __int64 k;  int x, y;  Point ret(0, 0);  scanf(\"%d%I64d\", &amp;n, &amp;k);  scanf(\"%d%d\", &amp;x, &amp;y);  m0.Set(x, y);  for (int i = 0; i &lt; n; i++) {    scanf(\"%d%d\", &amp;x, &amp;y);    a[i].Set(x, y);  }  int len = k % (2 * n);  bool flag = true;  for (int i = 0; i &lt; len; i++) {    if (flag)      ret = ret + a[(k - i - 1) % n];    else      ret = ret - a[(k - i - 1) % n];    flag = !flag;  }  ret.x *= 2;  ret.y *= 2;  if (k % 2)    ret = ret - m0;  else    ret = ret + m0;  ret.Show();  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"Codeforces Beta Round #27 ABC 题","url":"/2010/09/11/obsidian/1865327f-a144-4d19-8c35-9023560283ce/","content":"因为今天要打区域赛的缘故，昨晚 CF 没有做，现在放出 ABC 的思路，后两题表示不怎么会，一题图论，一题数论，平时都是队友搞定的。。。\n\n A Next Test\n这题很简单，写的暴力点也无妨，n≤50n \\leq 50n≤50 的，开个 320032003200 大小的数组，然后记录 use[i]use[i]use[i] 表示 i 这个序号是否被用过，然后从头到尾循环一遍即可，时间复杂度是 O(n)O(n)O(n) 的。\n我的代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;bool use[3200] = {0};int main() {  int n, id;  scanf(\"%d\", &amp;n);  for (int i = 0; i &lt; n; i++) {    scanf(\"%d\", &amp;id);    use[id] = true;  }  for (int i = 1; i &lt; 3200; i++)    if (!use[i]) {      printf(\"%d\\n\", i);      break;    }  return 0;}\n B Tournament\n这题要求找到剩下的那场比赛的结果，这题可以转化一下模型，告诉你一个有向无环图，缺了一条边，并且要保证全部点连通 (弱连通)，可以先用一个数组标记有向边，nnn 很小，直接建个邻接矩阵，然后剩下两个没有连边的随便加一条，跑 bfs 看是否有回路，如果没有，那么说明这条边是正确的，否则就将这条边反向一下。最后输出这条边的两个端点就可以了。\n我的代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;bool mp[100][100] = {0};int n;bool bfs(int st) {  bool vis[100] = {0};  queue&lt;int&gt; q;  int now;  q.push(st);  while (!q.empty()) {    now = q.front();    q.pop();    for (int i = 1; i &lt;= n; i++) {      if (mp[now][i] &amp;&amp; !vis[i]) {        if (i == st) return false;        vis[i] = true;        q.push(i);      }    }  }  return true;}int main() {  int t;  int x, y;  scanf(\"%d\", &amp;n);  t = n * (n - 1) / 2 - 1;  for (int i = 0; i &lt; t; i++) {    scanf(\"%d%d\", &amp;x, &amp;y);    mp[x][y] = true;  }  for (int i = 1; i &lt;= n; i++) {    for (int j = i + 1; j &lt;= n; j++) {      if (mp[i][j] == false &amp;&amp; mp[j][i] == false) {        mp[i][j] = true;        if (!bfs(i)) {          printf(\"%d %d\\n\", j, i);        } else {          printf(\"%d %d\\n\", i, j);        }        return 0;      }    }  }  return 0;}\n C Unordered Subsequence\n这题直接模拟，如果原来的序列是有序的，那么就输出 000，否则答案一定是 333，剩下的三个数。可以取第一个，转折点，还有就是转折点之后的第一个点。\n之前要先把相等的数字去掉，然后找到第一个不同的数字当做第一个和第二个答案。\n时间复杂度是 O(n)O(n)O(n) 的。\n我的代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 100010;int main() {  bool up;  int n, st;  int a[MAX];  scanf(\"%d\", &amp;n);  for (int i = 0; i &lt; n; i++) {    scanf(\"%d\", &amp;a[i]);  }  st = 0;  while (st &lt; n - 1 &amp;&amp; a[st] == a[st + 1]) st++;  if (n - st &lt;= 2) {    puts(\"0\");    return 0;  }  if (a[st + 1] &gt; a[st])    up = true;  else    up = false;  if (up) {    for (int i = st + 2; i &lt; n; i++) {      if (a[i] &lt; a[i - 1]) {        puts(\"3\");        printf(\"%d %d %d\\n\", st + 1, i, i + 1);        return 0;      }    }    puts(\"0\");  } else {    for (int i = 2; i &lt; n; i++) {      if (a[i] &gt; a[i - 1]) {        puts(\"3\");        printf(\"%d %d %d\\n\", st + 1, i, i + 1);        return 0;      }    }    puts(\"0\");  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"Codeforces Beta Round #38 G Queue 动态树","url":"/2010/10/31/obsidian/1891d186-0cd4-4522-bcb6-7061e1d7ce82/","content":"本题算是比较难想的题目了，比赛的时候想成 Splay 果断悲剧，今晚才突然发现直接用可以合并的树就可以了。\n思路是维护一颗二叉树，每次来了一个元素，找到元素对应的位置，注意找到的位置是靠最右边的第一个比它大的元素的位置，如果此元素在 cic_ici​ 步内不能到达，就插入元素到右边第 cic_ici​ 个位置。\n动态树的 split 函数表示将树中的第 kkk 个和第 k−1k-1k−1 个元素分开，形成两棵树，这样我们将一个单独的结点分别与这两棵树合并，就可以得到新的序列。\n最后进行中序遍历得到最后的解，注意树的合并必须用随机算法，否则会使树退化。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 1000100;const int oo = 0x3f3f3f3f;struct Node {  int l, r;  int val, ma, size;  Node() {    l = r = 0;    val = ma = size = 0;  }} node[MAX];int find(int k, int val) {  if (k == 0) {    return 0;  }  if (val &lt;= node[node[k].r].ma) {    return node[node[k].l].size + 1 + find(node[k].r, val);  } else if (val &lt;= node[k].val) {    return node[node[k].l].size + 1;  } else {    return find(node[k].l, val);  }}void update(int k) {  node[k].size = node[node[k].l].size + node[node[k].r].size + 1;  node[k].ma = max(node[k].val, max(node[node[k].l].ma, node[node[k].r].ma));}void split(int k, int id, int&amp; l, int&amp; r) {  if (k == 0) {    l = r = 0;    return;  }  if (node[node[k].l].size &gt;= id) {    split(node[k].l, id, l, node[k].l);    r = k;  } else if (node[node[k].l].size + 1 &lt; id) {    split(node[k].r, id - node[node[k].l].size - 1, node[k].r, r);    l = k;  } else {    l = node[k].l;    r = k;    node[k].l = 0;  }  update(k);}int join(int x, int y) {  if (x == 0) {    return y;  } else if (y == 0) {    return x;  } else {    if (rand() % 1000 &lt; 500) {      node[x].r = join(node[x].r, y);      update(x);      return x;    } else {      node[y].l = join(x, node[y].l);      update(y);      return y;    }  }}bool done;void dfs(int k) {  if (node[k].l) {    dfs(node[k].l);  }  if (done) {    putchar(' ');  } else {    done = true;  }  printf(\"%d\", k);  if (node[k].r) {    dfs(node[k].r);  }}int main() {  int n, root = 0;  int id, x;  int l, r;  node[0].ma = node[0].val = -oo;  scanf(\"%d\", &amp;n);  for (int i = 1; i &lt;= n; i++) {    scanf(\"%d%d\", &amp;id, &amp;x);    x = max(i - x, find(root, id) + 1);    split(root, x, l, r);    node[i].val = id;    update(i);    l = join(l, i);    root = join(l, r);  }  done = false;  dfs(root);  puts(\"\");  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"Codeforces Beta Round #29 ACD 解题报告","url":"/2010/09/21/obsidian/1ae2c844-e271-4755-a644-af91f4edceee/","content":"好吧。。我的第二题现在还是挂着，算了，就把第二题无视掉吧，贴一下 ACD 的解题思路。\n\n A\n水题，不说太多，直接模拟就可以了，用 aaa 数组表示指定位置的 ddd，为了防止出现负数，把 xxx 都加了 200002000020000，读取了一个 xxx 和一个 ddd，判断 a[x+d]a[x+d]a[x+d] 是否是 −d-d−d 即可，如果是，就说明找到了一对。\n我的代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int step = 20000;int a[100000];int main() {  int n;  int x, d;  scanf(\"%d\", &amp;n);  while (n--) {    scanf(\"%d%d\", &amp;x, &amp;d);    x += step;    if (a[x + d] == -d) {      puts(\"YES\");      return 0;    } else      a[x] = d;  }  puts(\"NO\");  return 0;}\n C\n欧拉通路变形，因为要保证每个点都访问到一次，于是就找从奇度数结点出发进行 dfs，运用类似套圈法的方法来把结点加入路径中。\n还要注意因为范围很大，所以需要离散化，或者用 map 来存放结点信息。\n我的代码：\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;int n;map&lt;int, list&lt;int&gt; &gt; lst;  // 邻接表vector&lt;int&gt; ret;           // 最后结果map&lt;int, int&gt; d;           // 度数map&lt;int, bool&gt; use;        // 访问标记void dfs(int u) {  int v;  list&lt;int&gt;&amp; l = lst[u];  while (!l.empty()) {    v = *(l.begin());    l.pop_front();    if (!use[v]) dfs(v);  }  ret.push_back(u);}int main() {  int n, s;  int x, y;  scanf(\"%d\", &amp;n);  for (int i = 0; i &lt; n; i++) {    scanf(\"%d%d\", &amp;x, &amp;y);    lst[x].push_back(y);    lst[y].push_back(x);    d[x]++;    d[y]++;  }  // 找到度数是奇数的点作为起点  for (map&lt;int, int&gt;::iterator it = d.begin(); it != d.end(); it++) {    if ((it-&gt;second) % 2) {      s = it-&gt;first;      break;    }  }  dfs(s);  for (int i = 0; i &lt; n; i++) printf(\"%d \", ret[i]);  printf(\"%d\\n\", ret[n]);  return 0;}\n D\n经典 LCA 问题，为了得到有顺序的结点，我们求出相邻的结点的 LCA 即可，建议大家先看相关的资料再理解这个算法。\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 305;int lst[MAX][MAX];  // 邻接表int father[MAX];    // 父亲结点bool vis[MAX];      // 访问数组bool leaf[MAX];     // 是否是叶子int order[MAX];     // 叶子的顺序int lca[MAX];       // order[i]和order[i+1]的LCA// dfs判断叶子数量void dfs(int x) {  bool flag = false;  vis[x] = true;  for (int i = 1; i &lt;= lst[x][0]; i++) {    if (!vis[lst[x][i]]) {      flag = true;      father[lst[x][i]] = x;      dfs(lst[x][i]);    }  }  if (!flag) leaf[x] = true;}int st[MAX], cnt[MAX][MAX];int ret[600000];int main() {  int x, y, n;  int nleaf, temp, P, top;  scanf(\"%d\", &amp;n);  for (int i = 1; i &lt;= n; i++) lst[i][0] = 0;  for (int i = 1; i &lt; n; i++) {    scanf(\"%d%d\", &amp;x, &amp;y);    lst[x][0]++;    lst[x][lst[x][0]] = y;    lst[y][0]++;    lst[y][lst[y][0]] = x;  }  for (int i = 1; i &lt;= n; i++) {    vis[i] = false;    leaf[i] = false;  }  father[1] = -1;  dfs(1);  nleaf = 0;  for (int i = 1; i &lt;= n; i++)    if (leaf[i]) nleaf++;  for (int i = 1; i &lt;= nleaf; i++) scanf(\"%d\", &amp;order[i]);  for (int i = 1; i &lt; nleaf; i++) {    for (int j = 1; j &lt;= n; j++) vis[j] = false;    temp = order[i];  // 向上寻找祖先    while (temp != 1) {      vis[temp] = 1;      temp = father[temp];    }    temp = order[i + 1];    vis[1] = true;    while (temp != 1) {      if (vis[temp]) break;      temp = father[temp];    }    lca[i] = temp;  }  order[0] = 1;  lca[0] = 1;  lca[nleaf] = 1;  order[nleaf + 1] = 1;  for (int i = 1; i &lt;= n; i++)    for (int j = 1; j &lt;= n; j++) cnt[i][j] = 0;  P = 1;  ret[0] = 1;  for (int i = 1; i &lt;= nleaf; i++) {    temp = order[i];    top = 0;    while (temp != lca[i - 1]) {      st[top++] = temp;      cnt[temp][father[temp]]++;      cnt[father[temp]][temp]++;      if (cnt[father[temp]][temp] &gt; 2) {        puts(\"-1\");        return 0;      }      temp = father[temp];    }    for (int j = top - 1; j &gt;= 0; j--) ret[P++] = st[j];    temp = order[i];    top = 0;    while (temp != lca[i]) {      st[top++] = temp;      cnt[temp][father[temp]]++;      cnt[father[temp]][temp]++;      if (cnt[father[temp]][temp] &gt; 2) {        puts(\"-1\");        return 0;      }      temp = father[temp];    }    st[top] = lca[i];    for (int j = 1; j &lt;= top; j++) ret[P++] = st[j];  }  for (int i = 0; i &lt; P - 1; i++) printf(\"%d \", ret[i]);  printf(\"%d\\n\", ret[P - 1]);}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"HDU3220 逆向思维的 BFS","url":"/2010/08/15/obsidian/1da46b1f-7546-4a0a-ad44-3a44599a3d8b/","content":"这道题有两个重要的地方，一个是对题目的理解，合法的操作只有一种，那就是对相邻的两个状态不同的灯泡进行交换状态的操作，也就是说，相邻的灯泡如果都是亮着的或者暗着的，那么不能对这条边进行操作。\n第二点，那就是由于所有的状态的目标状态都是一样的，那么我们就可以从目标状态进行 BFS，计算出其他状态到目标状态要多少步，注意当 BFS 的步数大于 333 的时候，就不要将其子状态放入队列中，为了方便，之前将全部的状态的需要步数设置为 5，这样即使没有访问的状态，步数也是大于 333 的，这个算法的时间复杂度是 O(323)O(32^3)O(323)，完全可以接受，之后就是 O(1)O(1)O(1) 的查询。\n为了方便 BFS，优化空间，运用位压缩，将 161616 个灯泡的状态用一个 int 来存放，高位存放低编号的灯泡，装换的时候就用异或运算即可。\n数组 xxx 和 yyy 用来对应 323232 对相邻的灯泡\n\n我的代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int MAX = 1 &lt;&lt; 17;const int x[32] = {0,  1, 3, 11, 10, 8,  10, 2, 8,  9, 9,  0, 0, 1, 3,  11,                   10, 8, 9, 2,  12, 13, 13, 4, 14, 6, 12, 4, 5, 7, 15, 14};const int y[32] = {1,  3,  11, 10, 8,  0, 2,  3, 9, 1, 11, 2, 4, 5,  7,  15,                   14, 12, 13, 6,  13, 5, 15, 6, 6, 7, 4,  5, 7, 15, 14, 12};const int aim = ((1 &lt;&lt; 8) - 1);int dist[MAX];struct Node {  int st;  int depth;};int hash(const int&amp; st, const int&amp; op) {  return st ^ ((1 &lt;&lt; (15 - x[op])) | (1 &lt;&lt; (15 - y[op])));}void bfs() {  Node node, next;  queue&lt;Node&gt; q;  node.st = aim;  node.depth = 0;  dist[aim] = 0;  q.push(node);  while (!q.empty()) {    node = q.front();    q.pop();    if (node.depth &gt; 3) break;    next.depth = node.depth + 1;    for (int i = 0; i &lt; 32; i++) {      if ((node.st &amp; (1 &lt;&lt; (15 - x[i]))) != (node.st &amp; (1 &lt;&lt; (15 - y[i])))) {        next.st = hash(node.st, i);        if (dist[next.st] == 1000) {          dist[next.st] = next.depth;          q.push(next);        }      }    }  }}int main() {  int t, cnt = 0;  int a;  int st;  for (int i = 0; i &lt; MAX; i++) {    dist[i] = 1000;  }  bfs();  scanf(\"%d\", &amp;t);  while (t--) {    cnt++;    st = 0;    for (int i = 0; i &lt; 16; i++) {      scanf(\"%d\", &amp;a);      if (a == 1) st |= (1 &lt;&lt; (15 - i));    }    a = dist[st];    if (a &gt; 3) {      printf(\"Case #%d: more\\n\", cnt);    } else {      printf(\"Case #%d: %d\\n\", cnt, a);    }  }  return 0;}\n总结：在搜索的时候，我们经常要想到是否有可以优化的方法，位压缩是一个很好的节约空间的方式，另外，这题不可能对每个状态正向 BFS，那样在多 case 的情况下肯定是 TLE 的，另外就是要仔细看题，理解题目的意思，对题目的理解如果错误，将会导致思路的定式，觉得自己肯定是对的，这样，在比赛的时候就会心慌，严重影响比赛的状态。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"HDU1880 字符串 hash","url":"/2010/11/25/obsidian/26f49ed9-ca81-4a68-9c8c-9c146d7fcfab/","content":"无意中看到这题，就切了一下，感觉这题很适合刚刚接触散列表和字符串处理的朋友，直接对字符串 hash 就可以了，用 map 暴力不知道能不能过，没有尝试过。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 210000;const int mod = 100007;struct Node {  Node* ne;  char st[81];} hash[MAX], *h[mod], *cur;unsigned int BKDHash(char* s) {  unsigned int seed = 131;  unsigned int ret = 0;  while (*s) {    ret = ret * seed + *s++;  }  return (ret &amp; 0x7FFFFFFF) % mod;}int getId(char* s) {  int code = BKDHash(s);  Node* ptr = h[code];  while (ptr) {    if (strcmp(ptr-&gt;st, s) == 0) {      return ptr - hash;    } else {      ptr = ptr-&gt;ne;    }  }  strcpy(cur-&gt;st, s);  cur-&gt;ne = h[code];  h[code] = cur++;  return cur - hash - 1;}int find(char* s) {  int code = BKDHash(s);  Node* ptr = h[code];  while (ptr) {    if (strcmp(ptr-&gt;st, s) == 0) {      return ptr - hash;    } else {      ptr = ptr-&gt;ne;    }  }  return -1;}int main() {  char s[100], *p;  int id, n;  cur = hash;  memset(h, 0, sizeof(h));  while (scanf(\"%s\", s), s[0] != '@') {    getId(s);    getchar();    gets(s);    getId(s);  }  scanf(\"%d\", &amp;n);  gets(s);  while (n--) {    gets(s);    id = find(s);    if (id == -1) {      puts(\"what?\");    } else {      p = hash[id ^ 1].st;      if (p[0] != '[') {        puts(p);      } else {        p++;        while (*p != ']') {          putchar(*p++);        }        puts(\"\");      }    }  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"树形结构转线性结构的方法 (帖子汇总)","url":"/2011/08/31/obsidian/28d6a5b8-53dd-42a5-b7a2-31bfa5c90fc0/","content":"在图论中经常遇到一些很常见的问题，比如一个非常简单的例子，给你一棵树，每一个点都有一个权值，现在动态更新一个点的权值，叫你查询一个点对路径上所有点权的和，这种问题和图论的 Tree&nbsp;&nbsp;Problem 非常类似，我们可以利用树形结构转线性结构的方法来处理，我们考虑随便取一个点，比如说 111，作为根，这样我们就可以得到一个 DFS 序列，注意我们维护一个长度为 2×N2 \\times N2×N 的 DFS 序列，每次访问开始的时候，向序列中加入一个等于当前点权的元素，每次结束这个结点访问的时候，我们加入一个等于当前点权相反数的元素，举一个很简单的例子。\n我们考虑边的序列是这样31 21 3点权是5 7 10那么我们得到的序列有可能是5 7 -7 10 -10 -5\n注意一个非常好的性质，我们记录访问开始的时候加入的元素的下标，那么我们可以非常快的利用前缀和来计算出根到一个点的路径上点权和是多少，还是上面的例子，点权和的答案是\n2 : [5 7] -7 10 -10 -5 = 123 : [5 7 -7 10] -10 -5 = 15\n这样，我们可以维护一个线段树或者树状数组，对于更改点权的操作，假设我要把一个结点点权改成 v，我们在开始访问对应的下标处，把元素值改成 vvv，在其结束访问对应的下标处把元素改成 −v-v−v，这样还是保证了括号序列的匹配性。\n对于查询操作，假设我要求 uuu 和 vvv 路径上全部结点的权值之和，我们可以求出 uuu 和 vvv 的 LCA，我们记录为 ttt，那么我们可以求出根到 uuu、vvv 和 ttt 的权值之和，答案就是 ∑u+∑v−2×∑t+wt\\sum{u}+\\sum{v}-2 \\times \\sum{t}+w_t∑u+∑v−2×∑t+wt​，注意不要忘了加上那个 ttt 的权值。\n此外，Tree Problem 也是一个很经典的问题，对于 Tree Problem，我们可以只记录入点，不记录出点，但是要记录每一个点的管辖范围，注意一个点的子树在 DFS 序列中一定是连续的，那么我们就可以记录下这个点的管辖范围，然后利用树状数组维护这个序列，区间查询就可以了，至于需要查找大于其标号的点的个数， 做法大家应该是都知道了的，还不是很清楚的同学可以自己再想想。\n类似的问题有 POJ 的一题，叫做 Apple Tree，可以去做做。\n树形结构转线性结构在关于树的统计问题中还有非常多的运用，暑假的时候，大家如果有兴趣，可以去看看，做法很巧妙，代码量不大，是此类问题的共同性质。\n所谓的括号序列，就是将一个树形结构转化为线性结构，然后通过线性结构间接地对结点和路径的更新和查询操作。\n\n\n好，现在步入正题，首先我们考虑一个很经典的问题，HDU3966，也就是昨天 HIT 的 F 题的模型：\n大致题意\n给你一棵树，现在有两种操作，一个是修改 u 到 v 路径上点的权值 (全部增加一个值)，另外一个是查询一个点的点权。\n\n对于此类的问题，我们可以这么考虑，先将树形结构转化为线性结构，举下面的一个例子。\n我们可以通过 DFS 得到它的一个括号序列\n1 2 3 -3 -2 4 -4 5 -5 -1其中l[1] = 1 r[1] = 10l[2] = 2 r[2] = 5l[3] = 3 r[3] = 4l[4] = 6 r[4] = 7l[5] = 8 r[5] = 9\n我们现在要做的是更新区间查找点，利用树状数组维护括号序列的增量 (注意这里是增量，初始化全部为 000)，我们这么考虑，对于每一个更新操作，假设更新的是 uuu 到 vvv 路径上的点权全部加 www，那么对于 uuu，我们做的是将 111 到 lul_ulu​ 位置上的元素全部加 www，对于 vvv 我们做类似的处理。\n你会发现，更新 111 到 lul_ulu​ 上的元素值的时候，对于一个结点 xxx，如果 xxx 是 uuu 的祖先，那么 xxx 一定是左括号被增加了 www，如果 xxx 不是其祖先，比如说 uuu 为 444 的时候，333 不是 444 的祖先，那么 xxx 一定是左右括号都被增加了 www。通过这个例子，大家应该都知道怎么做了吧，对于每次更新，我们将 111 到 lul_ulu​ 以及 111 到 lvl_vlv​ 元素全部加 www，然后将 uuu 和 vvv 的 LCA 的左括号的位置找出来，假设为 lll，那么 111 到 l−1l-1l−1 的全部元素减去 2w2w2w，因为我们要更新的是路径上的值，这时候我们会发现 LCA 会被更新了两次，所以 LCA 对应的左括号位置元素减 www，这样我们就完成了一次更新操作。\n对于查询操作，看了上面一段话，应该会知道怎么做了，一个点的点权增加量就是等于其左括号的增加量减去右括号的增加量，这样我们就可以利用一个树状数组配合在线 LCA 在 O(Nlg⁡N)O(N \\lg N)O(NlgN) 的时间内得到所有的查询的答案。\n\n第二个例子是一个高级数据结构的题，不过是非常经典的一题了，题号是 HDU2475，题目抽象后的大意是这样的：\n大致题意\n给你 N 棵树，我们有两个操作，一个是将一棵树的根结点接到另外一棵树的某一个结点下面，另外一个操作是查询一个结点所在的树的根。\n\n对于这个问题，我们这么考虑，首先我们可以将全部的树逐个 DFS，这样对于每一棵树都可以得到一个括号序列，对于连结操作，我们将那个根所在的左右括号的一整段取出，连接到新的结点的左括号右边，这么做我们可以保证得到的一定也是一个括号序列。另外一个是查询操作，我们直接去找其结点所在的括号序列靠最左边的是谁就可以了。\n对于这个问题，我们用 splay 来维护这些括号序列，我们为每一个结点分配一个左括号和右括号的结点，然后做序列即可，注意查询的细节。\n利用 splay 来维护括号序列，对于一个 DFS 序列，我们入栈记录一次，出栈记录一次，我们用 x 表示 x 这个结点入栈的点，用 x+nx+nx+n 表示 xxx 出栈的点，那么对于这个问题可以轻松转化过来。\n\n对于 MOVE 操作，如果可以移动，我们进行 cut 操作和 add 操作。\n对于 cut 操作，我们将 xxx 和 x+nx+nx+n 分别旋根，这样我们可以得到一个 xxx 和 x+nx+nx+n，x+nx+nx+n 是根，xxx 是其左子树的某一个结点，这样 xxx 的左子树和 x+nx+nx+n 的右子树是无效的，我们剪掉它们，并且将 x+nx+nx+n 的右子树接到 x 的左子树最后，接着把 x+nx+nx+n 旋根，保证平衡性。\n对于 add 操作，我们将新的父亲结点旋到根，x+nx+nx+n 旋到根，然后进行连接，注意新的父亲结点的右子树，需要接到 x+nx+nx+n 的右子树上去。\n对于初始化，我们可以确定每一个结点的父亲结点，然后逐个进行 add 就是。\n\n最后的问题就是如何判断 yyy 是不是 xxx 的子树，这个的判断方法是先对 xxx 执行 cut 操作，注意这时候两个子树不要合并，然后再去查询 y 的根结点，如果 yyy 的根结点是 xxx，说明 yyy 是 xxx 的子树，最后记得复原。复原的时候要把 xxx 和 x+nx+nx+n 旋根，两个子树旋根，然后拼接。\n查询一个结点的根结点，其实就是 DFS 序列的起点，也就是所在树的最小元素，将 xxx 旋根，找左子树的最小值即可。\n注意这题不能用找祖先结点的方法来确定两个树的关系，因为有可能他们同是一颗树的两棵不同子树，这样找会有问题。\n\n最后一题可以算是第一题的变形吧，不过没发现哪个 OJ 有此类的题，具体题意如下：\n大致题意\n给你一棵树，每次可以对 uuu 到 vvv 路径上的全部点的点权加 www，可以查询 uuu 到 vvv 的点权之和。\n\n我们可以这么考虑，对于 A 题，我们记录的是每一个点的增量，这题我们还可以记录到一个位置前缀和的增量，从它到最后的后缀和的增量，这样查询 uuu 到 vvv 的权值之和，就是查询根到 uuu 的权值的增量加上根到 vvv 的权值的增量，减去根到 LCA 的增量，加上 LCA 的增量，注意后缀和用来计算右括号的增量，那么根到 uuu 的权值增量和就是 111 到 lul_ulu​ 的前缀增量和减去 rur_uru​ 到 2×N2 \\times N2×N 的后缀增量和，这样可以利用一个线段树来维护这三个值，在 O(Nlg⁡N)O(N \\lg N)O(NlgN) 的时间内得到解。\n其实这个系列还有很多相似的问题的，但是都可以转化为这个类型上去，所以就不在过多的举例了，在最后主要提一下关于边权的问题，其实边权可以把他们转化为点权来做，还是举几个例子。\n第一个例子很简单，给你一棵树，现在有两种操作，一种是一个边的权值加 vvv，另一个是查询两个点的距离，这个问题我们可以这么考虑，用点权代替边权，DFS 得到父亲结点和孩子结点的关系之后，我们用一个点的权值来代替连进这个点的边权的权值，这样就可以转化为括号序列的问题了。\n第二个例子，是给你一棵树，每次可以更新一个边的边权，保证边权是正的，求任意点到根的距离的最大值，我们可以这么考虑，直接利用第一个例子的结论，记录前缀和的最大值即可，然后我们就可以在 O(Nlg⁡N)O(N \\lg N)O(NlgN) 的时间内来维护这个性质。\n总之，边权的问题我们可以用点权来代替，如果遇到一些恶心的题目，既有边权又有点权的，我们可以考虑用多棵线段树或者树状数组来维护边权和点权，这样我们就可以在 O(Nlg⁡N)O(N \\lg N)O(NlgN) 的时间内完成相应的更新、查询操作。\n","categories":["杂谈","ICPC总结"],"tags":["CSDN","ICPC","杂谈"]},{"title":"POJ2001 字典树","url":"/2010/11/06/obsidian/28de87fc-e94f-41f1-a0cd-a0c622f83800/","content":"这题在 cnt 变量这里卡了好久，一直 WA 着，才发觉不对。、\n和常规的题思路一致，查询的时候找到第一个 cnt 为 1 的结点就是解，注意 insert 函数 cnt 的更新必须更新 next 指针，root 单独更新，如果要到此结点了更新 cnt，那么最后的一个结点要更新 cnt，如果不更新会发生错误。\n\n我的代码，加上了注释：\n#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;numeric&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;using namespace std;const int MAX = 1000000;struct Node {  Node* ne[26];  int cnt;} node[MAX], *root;int K;Node* New() {  Node* ret = &amp;node[K++];  ret-&gt;cnt = 0;  for (int i = 0; i &lt; 26; i++) {    ret-&gt;ne[i] = NULL;  }  return ret;}void init() {  K = 0;  root = New();}void insert(char* s) {  Node* ptr = root;  char* p = s;  int id;  ptr-&gt;cnt++;  // here we update the cnt at first when we reach it.  while (*p) {    id = *(p++) - 'a';    if (ptr-&gt;ne[id] == NULL) {      ptr-&gt;ne[id] = New();    }    ptr = ptr-&gt;ne[id];    ptr-&gt;cnt++;  }}char* find(char* s) {  char* p = s;  static char ret[30];  int top = 0;  Node* ptr = root;  int id;  while (*p) {    if (ptr-&gt;cnt == 1) {      ret[top] = 0;      return ret;    }    ret[top++] = *p;    id = *(p++) - 'a';    ptr = ptr-&gt;ne[id];  }  return s;}char s[1100][30];int main() {  int n = 0;  init();  while (gets(s[n])) {    insert(s[n++]);  }  for (int i = 0; i &lt; n; i++) {    printf(\"%s %s\\n\", s[i], find(s[i]));  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"HDU2896 AC 自动机多串匹配多串","url":"/2010/11/24/obsidian/2b54c209-3bf6-4976-b7a9-63cc9cd02b4d/","content":"这算是很经典的多模式串多原串的题目了，匹配的复杂度是 O(n)O(n)O(n) 的，这样，直接上自动机，注意判重另外开一个 vis 变量表示第 turn 趟是否访问过此结点即可。\n运用静态分配内存，跑了 156ms。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 101100;const int MAXK = 128;struct Node {  Node* ne[MAXK];  Node* fail;  int cnt, vis;} node[MAX], *root;Node* que[MAX];char s[11000];int K, ans[5], top;Node* New() {  Node* ret = &amp;node[K++];  ret-&gt;fail = NULL;  ret-&gt;cnt = 0;  ret-&gt;vis = 0;  for (int i = 0; i &lt; MAXK; i++) {    ret-&gt;ne[i] = NULL;  }  return ret;}void init() {  K = 0;  root = New();}void insert(char* s, int num) {  Node* ptr = root;  char* p = s;  int id;  while (*p) {    id = *(p++);    if (ptr-&gt;ne[id] == NULL) {      ptr-&gt;ne[id] = New();    }    ptr = ptr-&gt;ne[id];  }  ptr-&gt;cnt = num;}void bfs() {  int b = 0, f = 0;  Node* now;  Node* ptr;  que[b++] = root;  while (f != b) {    now = que[f++];    for (int i = 0; i &lt; MAXK; i++) {      if (now-&gt;ne[i] != NULL) {        if (now == root) {          now-&gt;ne[i]-&gt;fail = root;        } else {          ptr = now-&gt;fail;          while (ptr != NULL) {            if (ptr-&gt;ne[i] != NULL) {              now-&gt;ne[i]-&gt;fail = ptr-&gt;ne[i];              break;            } else {              ptr = ptr-&gt;fail;            }          }          if (ptr == NULL) {            now-&gt;ne[i]-&gt;fail = root;          }        }        que[b++] = now-&gt;ne[i];      }    }  }}void find(char* s, int turn) {  bool vis[520] = {0};  Node* ptr = root;  Node* next;  char* p = s;  int id;  vis[0] = true;  top = 0;  while (*p) {    id = *(p++);    while (ptr-&gt;ne[id] == NULL &amp;&amp; ptr != root) {      ptr = ptr-&gt;fail;    }    ptr = ptr-&gt;ne[id];    if (ptr == NULL) {      ptr = root;    }    next = ptr;    while (next != NULL &amp;&amp; next-&gt;vis != turn) {      if (!vis[next-&gt;cnt]) {        ans[top++] = next-&gt;cnt;        vis[next-&gt;cnt] = true;      }      next-&gt;vis = turn;      next = next-&gt;fail;    }  }}int main() {  int n, tol;  while (~scanf(\"%d\", &amp;n)) {    init();    gets(s);    for (int i = 1; i &lt;= n; i++) {      gets(s);      insert(s, i);    }    bfs();    scanf(\"%d\", &amp;n);    tol = 0;    gets(s);    for (int i = 1; i &lt;= n; i++) {      gets(s);      find(s, i);      if (top) {        printf(\"web %d:\", i);        sort(ans, ans + top);        for (int j = 0; j &lt; top; j++) {          printf(\" %d\", ans[j]);        }        puts(\"\");        tol++;      }    }    printf(\"total: %d\\n\", tol);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"ACM-ICPC 2015 regional Shanghai onsite 简单题解","url":"/2015/11/29/obsidian/2efe292f-0f33-4cfb-b2c5-d43612146a2a/","content":"本篇简单描述一下 2015 年上海 ACM/ICPC onsite 的题解（非官方）。\n\n An Easy Physics Problem\nTags: 几何\n简单几何，不过好多人说会挂精度是怎么回事。。（不管反正我只会嘴炮\n注意，两个点都在圆外，而且不在圆边上，这点非常重要！\n Binary Tree\nTags: 构造\n好吧。。这题本来想出成不给 KKK 的，但是考虑到缺中档偏简单的题而且不给 KKK 输出不好控制，就给了个这么奇怪的限制。。\n对于所有的奇数我们可以用 111 , 222 , 444 , ⋯\\cdots⋯ , 2K2^K2K 这条路径进行贪心构造。\n对于所有偶数的情况，由于我们已经构造出了所有的奇数，偶数就是奇数加 111 啦，所以我们可以从 111 走到 2K−12^{K-1}2K−1 然后走到 2K+12^K+12K+1 。\n时间复杂度 O(K)O(K)O(K) 。\n Colorful Tree\nTags: 数据结构\n先上一个可能会 TLE 的做法。。把整个树根据 DFS 序展开成线性的，然后我们可以把整个问题转化为，修改一个区间颜色，查询区间不颜色的数量。这里，如果修改的单点的话，就可以用类似 这个破题 的思路来写了。这样时间复杂度是 O(Nlg⁡2N)O(N\\lg^2N)O(Nlg2N) .\n对于把区间更新转化成单点更新，可以考虑，由于我们每次都是更新的一整个子树，那么对于修改操作，我可以把根结点的颜色更新成我们要的颜色，对于剩下的点，我们直接暴力把它们删掉。对于删颜色的操作，最多只会有 N+MN+MN+M 次。\n查询的时候，我们先看这个区间内的不同颜色数量，再考虑，如果根的颜色是空的话，我们要找到根真正的颜色，还要看这个颜色在不在区间内。不过这个好处理，直接维护一个线段树，表示每个点真正的颜色就可以了（对于更新一个子树的颜色，就等价于更新线段树里面一个区间的值）。\n最后，我们考虑怎么把时间复杂度再降一点（现场前者做法如果常数不大其实是可以过的）。对于相同颜色的结点，我们把他们按 DFS 序排好序，我们维护一个树，树上每个结点的值，表示以这个结点为根的答案，那么我们直接考虑不转线性地去维护这些答案。我们会发现，对于每个点，它的颜色只会影响到它到它祖先里面深度最大的同颜色点下面的结点的答案。但是有可能一个结点下面会有多个同颜色的点，怎么办？我们假设同颜色的 DFS 序是 aaa , bbb , ccc , ⋯\\cdots⋯ ，对于 aaa 我们只认为它影响到了 aaa 到 LCA(a,b)LCA(a, b)LCA(a,b) 路径上的答案，对于 bbb 来说，影响到的是 bbb 到 LCA(b,c)LCA(b, c)LCA(b,c) 上的答案。。。这样就可以把整个问题转化成了树上路径更新，单点查询的问题了。\n最后，总体复杂度是 O((N+M)lg⁡N)O((N + M) \\lg N)O((N+M)lgN) 。\n Discover Water Tank\nTags: 动态规划\n将整个 hhh 数组抽象成一棵笛卡尔树，对于每一个挡板，我们从它最高点向左右划横线，直到遇到比它高的挡板停止，然后我们会发现这个图被分成了很多个长方形，这些长方形就是树的每个结点（自己画图 QUQ）。然后我们就可以在这些结点上 DP 了。\n定义状态\ndp[u][s]dp[u][s]\ndp[u][s]\n表示考虑到结点 uuu ， sss 表示有水还是没水，值是最多不冲突的条件的数量。然后直接树形 DP 转移就可以了。\n这个树不一定要建出来，可以用并查集抽象化就可以（当然建树并不难写就是了）。\n对于每个结点，我们需要把在内部的条件预先排好序（内部有可能冲突），所以最后时间复杂度是 O(Mlg⁡M+N)O(M \\lg M + N)O(MlgM+N) 。\n Expection of String\nTags: 动态规划\n Solution I\n直接 DP 每两个位置的期望，定义状态\ndp[s][i][j][k]dp[s][i][j][k]\ndp[s][i][j][k]\n表示现在还有 kkk 次交换机会，两个数位置在 iii 和 jjj ，乘号在 kkk ，对最后答案的影响。转移可以通过求和来达到 O(1)O(1)O(1) 。\n时间复杂度是 O(N3⋅K)O(N^3 \\cdot K)O(N3⋅K) 。\n Solution II\n固定 CCC 我们用 DP 算 x×yx \\times yx×y 的期望\n定义状态\ndp[A][b][C][k]dp[A][b][C][k]\ndp[A][b][C][k]\n表示当前某三个位置 i&lt;j&lt;ki &lt; j &lt; ki&lt;j&lt;k 的值分别是 AAA BBB CCC ，还有 KKK 步要走时，\n这三个位置的 x×yx \\times yx×y 的期望，边界条件为\ndp[A][b][C][0] = \\begin{cases}A \\times C &amp; \\mbox{if }B = *\\\\0 &amp; \\mbox{if }B \\neq *\\end{cases}\n\n于是由于 AAA BBB CCC 分别只能是 0−90-90−9 以及 * 共 111111 种 然后转移的时候也只与这 111111 种的个数有关，因此可以做到 O(11)O(11)O(11) 的转移\n最后答案是\n∑i&lt;j&lt;k(dp[si][sj][sk][k]×C(i,j,k))\\sum_{i &lt; j &lt; k}(dp[s_i][s_j][s_k][k] \\times C(i, j, k))\ni&lt;j&lt;k∑​(dp[si​][sj​][sk​][k]×C(i,j,k))\n其中 C(i,j,k)=10(j−i−1)+(N−k−1)C(i, j, k) = 10 ^ {(j - i - 1) + (N - k - 1)}C(i,j,k)=10(j−i−1)+(N−k−1)\n总体复杂度 O(114⋅K+N3)O\\left(11^4 \\cdot K + N^3\\right)O(114⋅K+N3) .\n Friendship of Frog\nTags: 杂题\n怎么写都可以。。数据范围 N≤1000N \\leq 1000N≤1000 瞩目。\n时间复杂度强行 O(N2)O(N^2)O(N2) 。\n Game of Arrays\nTags: 博弈\n\n先计算出 A+B−CA+B-CA+B−C ，得到每一位需要操作的次数，若为正，即操作 AAA 或 BBB ，若为负，即操作 CCC 。\n如果初始状态等式成立，则先手赢。否则枚举先手第一步。\n对于每一位，判断初始时是否在等式永远不可能成立的状态，如果是，后手赢。\n否则判断其是否有一种方法（后手不断操作 AAA / BBB ，或者后手不断操作 CCC ），使其永远都不能成立。\n\n如果是，判断在这种情况下（后手不断操作 AAA / BBB ，或者后手不断操作 CCC ），先手能不能赢（即在这一位等式永远不成立之前，先手把其他位都操作成等式）\n如果先手不能赢，那么后手就执行这种方法（后手不断操作 AAA / BBB ，或者后手不断操作 CCC ），后手赢。\n如果对于每一位，后手都不能将其操作为永远不可能成立的状态，那么先手赢。\n\n\n\n Happiness of Frog\nTags: 动态规划\n不会。。。\n Infinity Point Sets\nTags: 几何 计数\n其实这题需要画图强行猜个结论（不\n最后满足条件的点集，只有一种，那就是一堆共线的点，加上两边最多各一个点（最多的意思是可以有一边没有点，或者两边都没有）。\n但是这样不好统计，怎么办？把这个结论划分成下面几类：\n\n小于等于 444 个点，或者大于等于 555 个点并且它们共线。\n大于等于 444 个点共线，加上其中一侧有一个点。\n大于等于 333 个点共线，加上两侧各有一个点。\n\n我们枚举一个点，把所有点极角排序，对于第 2 种情况可以直接算出来，对于第 3 种情况，我们假设这个枚举的点是四边形的中心，这样可以把四边形加上对角线交点这种会重复算的去掉。\n时间复杂度 O(N2lg⁡N)O(N^2 \\lg N)O(N2lgN) 。\n Journey of Taku\nTags: 图论 最短路\n首先如果 Taku 使用了第二种魔法，那么有 KKK 步的移动是可以确定的，于是我们记录每条边走完后，通过第一种魔法下一步是哪条边，这样可以倍增算出 K 步后在哪儿，于是可以直接建图，求最短路即可。\n重要的话一定要加粗说！答案会爆 int，另外题意有毒！\n时间复杂度 O(Mlg⁡K)O(M \\lg K)O(MlgK) 。\n Kingdom of Black and White\nTags: 杂题\n直接枚举修改哪个点，我们可以先算出原来的答案，然后修改一个点只会影响到相邻的两个连续段，直接算修改后对答案的影响就可以了。\n时间复杂度 O(N)O(N)O(N) 。\n LCM Walk\nTags: 数论（假）\n对于 (x,y)(x, y)(x,y) 走到 (x+z,y)(x + z, y)(x+z,y) 或者 (x,y+z)(x, y + z)(x,y+z) 。由于 z≥xz \\geq xz≥x 且 z≥yz \\geq yz≥y 。我们可以算出来 (ex,ey)(e_x, e_y)(ex​,ey​) 的前驱。实际上前驱是唯一确定的，所以直接模拟就可以。\n时间复杂度 O(lg⁡(max⁡(ex,ey)))O(\\lg\\left(\\max(e_x, e_y)\\right))O(lg(max(ex​,ey​))) 。\n","categories":["ICPC题解"],"tags":["ICPC题解"]},{"title":"Ubuntu 系统下用 Firefox 访问 12306","url":"/2015/12/27/obsidian/32365f1f-4934-4bdd-ab35-7f41e5bc5beb/","content":"之前在帮爹妈买火车票的时候，由于 12306 各种不稳定，买一次票还登出了 4、5 次，就特别狂躁。。。\n在 ubuntu 下每个浏览器支持的证书是分开的，和 windows 上貌似是有区别的，于是，打开 Firefox 选 Edit ，Preferences 下的 Advance Certificates 。打开 Certificate list，选择 Authorities （这里，不知道为毛某度上的帖子全部都是选的 Server，反正我导入 Server certificate 一点用都没有）。Import 进来下载的官网证书，刷新网站就可以了（这里也不需要重启浏览器之类，还是比较赞的）。\n1\n","categories":["贴士"],"tags":["互联网","Linux"]},{"title":"CCPC2016 Hangzhou solutions","url":"/2016/10/30/obsidian/3288e52f-1127-4dea-ac5f-77375964cdd8/","content":"本篇简单描述一下 CCPC 2016 杭州赛区的题解（非官方）。\n\n ArcSoft’s Office Rearrangement\nTags: 数学\n我们令每一块的长度是 yyy ，则有\ny=∑i=1naiKy = \\frac{\\sum_{i = 1}^{n} a_i}{K}\ny=K∑i=1n​ai​​\n假设我们有 ∑a\\sum a∑a 个人站成一排，那么他们一定是在 pmod  y=0p \\mod y = 0pmody=0 的位置 ppp 上被分开，而对于 pmod  y≠0p \\mod y \\neq 0pmody=0 的位置，一定是合并的。对于每一个块 jjj ，我们算出前缀和\ns=∑i=1jaimod  ys = \\sum_{i=1}^{j} a_i \\mod y\ns=i=1∑j​ai​mody\n然后呢，对于这一块前面的不被整除的部分要合并到前面一块去，中间完整整除的一些块就分成，剩下的最后多余出来的和后面合并就可以了。\n总体复杂度： O(n)O(n)O(n)\n Bomb\nTags: 图论 , 几何\n建一个有向图，如果 d(u,v)≤rud(u, v) \\leq r_ud(u,v)≤ru​ 的话，就从 uuu 向 vvv 连条边。连完全部的边之后求出图的所有强连通分量，如果一个连通分量是有入边的，那么就说明这个分量中的所有点都是不需要点燃的（可以由入边的分量中任意一个爆炸来点燃它们），所以最后的答案就是对于每个入度为 000 的分量中的最小代价点求和。\n总体复杂度： O(n2)O(n^2)O(n2)\n Car\nTags: 贪心\n由于速度是不断变大的，所以最后一段的时间为 111 的时候是最优的，对于相邻的两段，我们有\nvi≤vi+1v_i \\leq v_{i + 1}\nvi​≤vi+1​\n稍稍做个转化，则变成了\nliti≤li+1ti+1\\frac{l_i}{t_i} \\leq \\frac{l_{i + 1}}{t_{i + 1}}\nti​li​​≤ti+1​li+1​​\n然后做计算就可以了。\n复杂度： O(n)O(n)O(n)\n Difference\nTags: meet in middle\n首先，我们有 11×99&lt;101011 \\times 9^9 &lt; 10^{10}11×99&lt;1010 ，我们可以得到 yyy 的范围是 y&lt;1010y &lt; 10^{10}y&lt;1010 。我们假设 y=a×105+by = a \\times 10^5 + by=a×105+b ，我们有\nf(y,K)=f(a,K)+f(b,K)]f(y, K) = f(a, K) + f(b, K)]\nf(y,K)=f(a,K)+f(b,K)]\n做个简单的转化\nf(y,K)−y=f(a,K)−105×a+f(b,K)−bf(y, K) - y = f(a, K) - 10^5 \\times a + f(b, K) - b\nf(y,K)−y=f(a,K)−105×a+f(b,K)−b\n我们在 a∈[0,105)a \\in [0, 10^5)a∈[0,105) 范围内枚举 f(a,K)−105×af(a, K) - 10^5 \\times af(a,K)−105×a 的值，然后把它们扔进一个 hash 表里去，然后枚举 b∈[0,105)b \\in [0, 10^5)b∈[0,105) 计算 x−(f(b,K)−b)x - (f(b, K) - b)x−(f(b,K)−b) 的值，然后去 hash 表里查下看看它们在不在就可以了。\n总体复杂度： O(5×105)O(5 \\times 10^5)O(5×105)\n Equation\nTags: 分类讨论 , 搜索\n把这些等式分成三个大类\n\n形如 1+x=x+11 + x = x + 11+x=x+1 , 这里 x≥1x \\geq 1x≥1 ， x≤8x \\leq 8x≤8 , 总共有 888 种不同的等式\n形如 x+x=2⋅xx + x = 2 \\cdot xx+x=2⋅x , 这里 x≥2x \\geq 2x≥2 ， x≤4x \\leq 4x≤4 , 总共有 333 种不同的等式\n形如 x+y=zx + y = zx+y=z , 这里 x≠1x \\neq 1x=1 ， x&lt;yx &lt; yx&lt;y , 总共有 999 种不同的等式\n\n对于第二类的每一种等式，我们有两种选择方法，不选这个等式，或者选了这个等式。而对于第三类的每一种等式，我们有三种选择，要么都不选，要么选了其中一种，要么两种都选了。对于第一类，我们可以暴力贪心计算出在选了第二类和第三类之后还可以最多构成多少种第一类的等式。\n对于实现，可以搜索第二类和第三类，贪心第一类，或者状压之类的？\n总体复杂度： O(39×23×9)O(3^9 \\times 2^3 \\times 9)O(39×23×9)\n Four Operations\nTags: 暴力 , 表达式求值\n假设这个式子可以写成\ny=a+b−c×d&nbsp;/&nbsp;ey = a + b - c \\times d\\ /\\ e\ny=a+b−c×d&nbsp;/&nbsp;e\n对于式子中的后半部分 c×d&nbsp;/&nbsp;ec \\times d\\ /\\ ec×d&nbsp;/&nbsp;e , ccc 和 ddd 应该只保留一位，让最后的答案最小。而对于 eee ，它最多只会有两位，这是因为 c×d&lt;100c \\times d &lt; 100c×d&lt;100 并且，如果你用了三位让后半部分从一个一位数变成了 000 ，还不如省下那一位让前半部分尽量大。\n对于前半部分， aaa 和 bbb 一定是一个一位数加一个多位数。所以我们只要枚举加号和除号的位置就可以定下来最后式子长什么样了。\n总体复杂度： O(2×2×n)O(2 \\times 2 \\times n)O(2×2×n)\n Game of Eliminate\nTags: 动态规划\n我们设 aia_iai​ 为第 iii 列的最高的 * 的高度，注意这里我们从底下开始， 111 开始标高度。定义状态\ndp[i][j]dp[i][j]\ndp[i][j]\n表示我们已经把第 i−1i - 1i−1 列和它之前的全部 * 部分消完，而第 iii 列的没有消去的高度还有 jjj 的状态的最小开销，那么有状态转移方程\ndp[i+1][max⁡(0,ai−k)]=min⁡(dp[i][j]+j+k3)dp[i + 1][\\max(0, a_i - k)] = \\min(dp[i][j] + \\frac{j + k}{3})\ndp[i+1][max(0,ai​−k)]=min(dp[i][j]+3j+k​)\n这里 2×u+v=j2 \\times u + v = j2×u+v=j 且 2×v+u=k2 \\times v + u = k2×v+u=k\n转化一下\ndp[i+1][ai−k]=min⁡(dp[i][j]+(j+k)&nbsp;/&nbsp;3)dp[i + 1][a_i - k] = \\min(dp[i][j] + (j + k)\\ /\\ 3)\ndp[i+1][ai​−k]=min(dp[i][j]+(j+k)&nbsp;/&nbsp;3)\n3×dp[i+1][ai−k]+(ai−k)=3×dp[i][j]+j+ai3 \\times dp[i + 1][a_i - k] + (a_i - k) = 3 \\times dp[i][j] + j + a_i\n3×dp[i+1][ai​−k]+(ai​−k)=3×dp[i][j]+j+ai​\n边界限制： (j+k)mod  3=0(j + k) \\mod 3 = 0(j+k)mod3=0 且 j2≤k≤2×j\\frac{j}{2} \\leq k \\leq 2 \\times j2j​≤k≤2×j\n用单调队列大概可以优化一波。\n总体复杂度： O(n×m)O(n \\times m)O(n×m)\n Hazy String\nTags: 动态规划 , 矩阵\n由于字符串不能包含超过 111 长度的回文串，那么对于所有长度为 222 和 333 的子串，它们一定不是回文，而且这是个充要条件。那么对于一个位置 ppp 的字符，它的选择只和 p+k,−2≤k≤2p + k, -2 \\leq k \\leq 2p+k,−2≤k≤2 位置上的字符有关。\n定义 mmm 是出现过的字符的数量，将它们标号为 000 到 m−1m - 1m−1 。定义状态\ndp[i][j]dp[i][j]\ndp[i][j]\n表示我们现在在考虑位置 pip_ipi​ 并且 pi−1p_i - 1pi​−1 上的字符是 jjj ，这里 j∈[0,m]j \\in [0, m]j∈[0,m] ， mmm 表示那些没出现过的字符，可以统一考虑。\n对于两个位置之间的部分，假设我们在考虑一个子串\nj,&nbsp;vi,&nbsp;⋯ ,&nbsp;x,&nbsp;yj,\\ v_i,\\ \\cdots,\\ x,\\ y\nj,&nbsp;vi​,&nbsp;⋯,&nbsp;x,&nbsp;y\n由于每一个位置上的字符只和它的前两位有关系，我们定义一个状态\nw(a,b)w(a, b)\nw(a,b)\n表示 j,&nbsp;vij,\\ v_ij,&nbsp;vi​ 和 x,&nbsp;yx,\\ yx,&nbsp;y 的关系，其中 a,&nbsp;b∈[0,2]a,\\ b \\in [0, 2]a,&nbsp;b∈[0,2] ， aaa 表示 jjj 和 xxx 的关系， bbb 表示 viv_ivi​ 和 yyy 的关系。 a=0a=0a=0 表示 x=jx=jx=j ， a=1a=1a=1 表示 x=vix=v_ix=vi​ ，而 a=2a=2a=2 表示 xxx 和前面两个都不一样， bbb 也是对应的表示状态。\n我们可以构建出一个矩阵来做 p⋅ip \\cdot ip⋅i 到 p⋅i+1p\\cdot i + 1p⋅i+1 之间的转移，而 dp[i+1][k]dp[i+1][k]dp[i+1][k] 的值等价于 x=kx=kx=k 且 y=vi+1y = v_{i+1}y=vi+1​ 的时候的值。\n总体复杂度： O(n×m+73×nlg⁡L)O(n \\times m + 7^3 \\times n \\lg L)O(n×m+73×nlgL)\n Inequality\nTags: 数学\n我们定义函数 b(i)=min⁡∑k=1ixkb(i) = \\min \\sum_{k=1}^{i} x_kb(i)=min∑k=1i​xk​ ，通过观察可以发现，它是一个关于 xix_ixi​ 值的分段函数，而且每一段的值可以写成如下形式\nu×x+vx+wu \\times x + \\frac{v}{x} + w\nu×x+xv​+w\n函数 b(i)b(i)b(i) 只有一个全局极小值，可以递推出 b(i)b(i)b(i) 关于 xix_ixi​ 的每一段分段函数长什么样子，然后算出全局的极小值。\n总体复杂度： O(n2)O(n^2)O(n2)\n Just a Math Problem\nTags: 数论\n定义 m=p1r1×p2r2×⋯×pkrkm = p_1^{r_1} \\times p_2^{r_2} \\times \\cdots \\times p_k^{r_k}m=p1r1​​×p2r2​​×⋯×pkrk​​ 且 f(m)=kf(m) = kf(m)=k\ng(m)g(m)g(m) 可以成满足 (x,y)=1(x, y) = 1(x,y)=1 和 x×y=mx \\times y = mx×y=m 的数对 xxx , yyy 的数量。那么 ∑ing(i)\\sum_{i}^{n} g(i)∑in​g(i) 就是满足 (x,y)=1(x, y) = 1(x,y)=1 且 x×y≤nx \\times y \\leq nx×y≤n 的数对的数量。\n我们假设 x&lt;yx&lt;yx&lt;y ，我们可以枚举 xxx ，容斥出 yyy 的数量（假设是 YYY ）， yyy 满足条件 (x,y)=1(x, y) = 1(x,y)=1 且 1≤y≤n1 \\leq y \\leq n1≤y≤n 。对于枚举的 xxx ，答案是 Y−ϕ(x)Y - \\phi(x)Y−ϕ(x) 。\n总体复杂度： O(nlg⁡n)O(\\sqrt{n} \\lg n)O(n​lgn)\n Kingdom of Obsession\nTags: 匹配 , 数论\n我们定义 bi=s+ib_i = s + ibi​=s+i ，如果 bi≤nb_i \\leq nbi​≤n ，那么最优的做法一定是把它放在原来自己的位置上，这里可以反证一下，如果 bib_ibi​ 放在了 ppp 上，而且 p&lt;bip &lt; b_ip&lt;bi​ ，我们一定可以把 bib_ibi​ 和放在 ppp 上的另外一个比 bib_ibi​ 大的数交换。\n对于 bi&gt;nb_i &gt; nbi​&gt;n 的情况，如果这样的 bib_ibi​ 中素数超过了 111 个，那么一定是无解的，因为素数只能放在自己的位置或者 111 上，而对于不超过一个素数的情况，这样的 bib_ibi​ 的数量会非常少（姑且认为是 100100100 个最多了？），对于这些数，假设有 mmm 个的话，我们就让它们和 111 到 mmm 这些位置做匹配就可以了。\n另外，给个贪心的反例： n=5,s=11n = 5, s = 11n=5,s=11 。\n总体复杂度： O(m3)O(m^3)O(m3)\n","categories":["ICPC题解"],"tags":["ICPC题解"]},{"title":"SRM482 DIV2 AB 两题解题报告","url":"/2010/09/16/obsidian/3b04b129-33f7-4a65-85b3-03f4b1ab41c9/","content":"今晚最后一题冲动了，没看范围就模拟，为某孩子送去了 50 分。。。\n好吧，我在这里说说前两题。。。\n\n 275 求平均数\n这题对我这个数学不怎么样的人来说，第一反应就搜索了，反正 n≤8n \\leq 8n≤8 嘛，O(28)O(2^8)O(28) 暴过。。\n我的代码：\nint a[10];int n, cnt;long long sum;void dfs(int k, int num, int cur) {  if (k == n) {    if (num == 0) return;    sum += cur;    cnt += num;    return;  }  dfs(k + 1, num, cur);  dfs(k + 1, num + 1, cur + a[k]);}double average(vector&lt;int&gt; numList) {  sum = 0;  cnt = 0;  n = numList.size();  for (int i = 0; i &lt; n; i++) a[i] = numList[i];  dfs(0, 0, 0);  return (double)sum / cnt;}\n队友的解法，直接求 nnn 个数的平均数即可。。。\n 500 约瑟夫问题\nnnn 比较小，直接模拟，我用的是 list。\n我的代码：\nint lastOpened(int N) {  list&lt;int&gt; lst;  list&lt;int&gt;::iterator it;  int ret = 1;  for (int i = 1; i &lt;= N; i++) lst.push_back(i);  int cnt = 0;  for (int i = 2; cnt &lt; N; i++) {    it = lst.begin();    while (1) {      ret = *it;      lst.erase(it++);      cnt++;      for (int j = 1; j &lt; i; j++) {        it++;        if (it == lst.end()) it++;        if (it == lst.begin()) break;      }      if (it == lst.begin()) break;    }  }  return ret;}\n总结：还是看题！！！看题很重要。。。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"ZOJ3533-Gao the String I","url":"/2011/09/19/obsidian/3becf816-eae7-454f-8323-09501d12cc09/","content":"好吧，这场比赛被完虐，3+3 来的太不容易了，这题在之前见过类似的问题，不过那题至今没过，还是处于 TLE 的状态 - -\n题号是 UVA11996，感兴趣的孩子可以去写写\n这题的主要思路是利用 splay 维护序列，对于 reverse 和 modify 操作都可以直接利用 splay 来维护，主要的问题是 lcp 的求法，lcp 比较直接的做法是二分长度，然后利用 splay 维护 hash 值。利用数据结构来维护 hash 值，这个在多校里面见过好多次了，最近的一场是 FZU 的 B 题？维护的是前缀 hash 值，和后缀 hash 值 (为了翻转操作)，判断区间的 hash 值是否相同即可，保险一点可以用双 hash。\nManacher 对于最长回文的求法，可以使用 O(N)O(N)O(N) 的 Manacher 算法 [1]。\n相对于那些大代码量的题，这题算是较短代码了，主要处理好 splay 的部分，对于求回文，直接把 splay 进行 dfs 下放，然后得到字符串，然后执行 O(N)O(N)O(N) 的回文即可。\n这题需要注意的地方如下：\ndfs 的时候要下放，否则会有问题\nlll 和 rrr 需要交换，如果 l&gt;rl&gt;rl&gt;r 的话\n代码量在 280 左右，splay 的标准线\n\n\n\nhttp://zhuhongcheng.wordpress.com/2009/08/02/a-simple-linear-time-algorithm-for-finding-longest-palindrome-sub-string/ ↩︎\n\n\n\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"分享一下我的 RSS 方案","url":"/2024/03/16/obsidian/40417926-96cd-46b2-a00c-ef7ff7437417/","content":"\n最近把之前 Feedly 上的订阅源薅了下来，自己搭了个 RSS 服务器，在自己的主力机（Arch Linux）、笔记本（Windows 11），以及手机（iPhone）上实现了多端同步还有查看，故在此做一个简单的记录。\n\n\n 背景\nRSS 作为我日常生活比较稳定的信息来源，我之前一直是在使用 Feedly 的，但是因为需要打开浏览器，现在也不像在老东家的时候那样，常年开着浏览器窗口了，所以我就想着，折腾一个可以多端同步的解决方案。\n我最终选择的方案如下图所示：\n\n在上图中，电脑和手机通过 Fresh RSS 提供的 API（Fever 或者原生的 Greader），进行数据同步，由于是自己在用，数据传输方面就自己弄个 SSL 证书即可，不需要使用商业的 HTTPS 证书，挂载出来的卷可以进行定期备份，如果有必要（比如说源非常重要，或者说想加固自己的数据），可以考虑使用第三方的 RDS 服务。\n 搭建 Fresh RSS 服务\n首先，在自己的服务器上简单创建一个 compose.yaml 文件，用于存储相关的服务清单：\nservices:  freshrss:    image: freshrss/freshrss:latest    hostname: freshrss    restart: always    logging:      options:        max-size: 10m    volumes:      - ./data:/var/www/FreshRSS/data      - ./extensions:/var/www/FreshRSS/extensions    ports:      - 12382:80    environment:      TZ: Asia/Shanghai      CRON_MIN: \"2,32\" # &lt;1&gt; cron      FRESHRSS_ENV: development      LISTEN: 0.0.0.0:80      TRUSTED_PROXY: 172.16.0.1/12 192.168.0.1/16      OIDC_ENABLED: 0      # &lt;2&gt; freshrss-install      FRESHRSS_INSTALL: |-        --api_enabled        --base_url 192.168.1.123        --db-base freshrss        --db-host db        --db-password dbpassword        --db-type pgsql        --db-user freshrss        --default_user freshrss        --language en      # &lt;3&gt; freshrss-user      FRESHRSS_USER: |-        --api_password apipassword        --email username@gmail.com        --language en        --password password        --user freshrss    healthcheck:      test: timeout 10s bash -c ':&gt; /dev/tcp/127.0.0.1/80'  || exit 1      interval: 30s      timeout: 5s      retries: 3    depends_on:      db:        condition: service_healthy        restart: false  db:    image: postgres:16    hostname: db    restart: always    logging:      options:        max-size: 10m    volumes:      - ./db:/var/lib/postgresql/data    environment:      POSTGRES_DB: freshrss      POSTGRES_USER: freshrss      POSTGRES_PASSWORD: dbpassword    expose:      - 5432    healthcheck:      test: pg_isready -U postgres -d \"dbname=$$POSTGRESQL_DB\" -h 127.0.0.1 -p 5432      interval: 30s      timeout: 5s      retries: 3\n在上述清单中，有如下的内容需要注意：\n\nCRON_MIN 环境变量指 RSS 源拉取的时间，这里 2,32 表示在每个小时的第二分钟和第 32 分钟进行拉取。\nFRESHRSS_INSTALL 中定义了安装相关的参数，要注意的是数据库的密码需要和下面数据库服务保持一致。\nFRESHRSS_USER 中定义了用户的信息，主要是 用户名密码，以及 API 密码。\n\n使用 docker compose up -d 运行，通过映射出来的端口号来访问服务。\n 使用自己的 SSL 证书\n 签发自己的 SSL 证书\n关于签发证书，为了方便，我直接使用 mkcert [1] 来生成证书，并备份收藏好它生成出来的 rootCA 证书，分发到各个客户端中，这样就可以在不同的电脑和手机上用 HTTPS 来访问自己的网站了。\n注意\n非常不推荐用 HTTP 的形式进行网站的访问，如果是自己使用而没有商业用途或者多人使用的情况，完全可以自己签发证书。另外，如果是小批量多人使用的情况，也不推荐把 CA 证书开放下载的时候提供，会有更大的安全隐患。\n\n可以使用如下命令生成自己想要的证书，另外如果你没有绑定域名，直接不用带域名参数即可：\nmkcert -cert-file cert.pem -key-file cert.key domain.example.com 192.168.1.123\n小贴士\n可以定义 CAROOT 环境变量，用于方便查找自己的 CA 证书，如果没有定义，默认 CA 证书的位置可以通过 mkcert -CAROOT 查看。\n\n 配置服务使用 SSL 证书\n对我们的 compose.yaml 进行修改，添加一个 Nginx 服务进行 HTTPS 流量转发：\nservices:  endpoint:    image: nginx:alpine    hostname: endpoint    restart: always    logging:      options:        max-size: 10    ports:      - 12382:443    volumes:      - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro      - ./cert.pem:/etc/nginx/ssl/cert.pem:ro      - ./cert.key:/etc/nginx/ssl/cert.key:ro    depends_on:      freshrss:        condition: service_healthy        restart: false\n注意，你需要关闭 Fresh RSS 服务的端口映射，方便端口释放，然后上述的证书文件是上个章节生成的，而 nginx.conf 文件，只是做了简单的流量转发：\nupstream freshrss {  server freshrss:80;  keepalive 64;}server {  listen 80;  location / {    return 301 https://$host$request_uri;  }}server {  server_name 47.122.61.12;  listen 443 ssl http2;  ssl_certificate ssl/cert.pem;  ssl_certificate_key ssl/cert.key;  location / {    proxy_pass http://freshrss/;    add_header X-Frame-Options SAMEORIGIN;    add_header X-XSS-Protection \"1; mode=block\";    proxy_redirect off;    proxy_buffering off;    proxy_set_header Host $host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_set_header X-Forwarded-Proto $scheme;    proxy_set_header X-Forwarded-Port $server_port;    proxy_read_timeout 90;    proxy_set_header Authorization $http_authorization;    proxy_pass_header Authorization;  }}\n上述的配置直接使用就可以，有两个要点需要说明：\n\n在 proxy_pass 中，最后的斜杠 / 是必需的。\n最后的 Authorization 请求头主要是用于 Google Reader API 的兼容。\n\n配置完毕之后，可以直接 docker compose up -d 开启服务。\n 安装自己的 CA 证书\nWindows 11Arch LinuxiPhone下载自己的证书，重命名为 crt 格式，打开它之后进行安装，安装的时候选择 “将所有的证书都放入下列存储”，并选择 “受信任的根证书颁发机构”，就可以安装并信任自己的 CA 证书了。直接使用 trust [1] 命令安装就可以：\nsudo trust anchor --store&nbsp;rootCA.crt\n\n\n\nhttps://wiki.archlinux.org/title/User:Grawity/Adding_a_trusted_CA_certificate ↩︎\n\n\n首先先把自己的证书发送给自己的手机，可以使用邮件（需要用系统邮箱软件打开），或者直接用 python -m http.server 启动一个临时的 Web 服务器，然后用系统自带的 Safari 打开，安装证书，并在通用 -&gt; 关于本机 -&gt; 证书信任设置中，信任自己的 CA 证书。\n 客户端对接\n桌面端iPhone在 Windows 11 和 Arch Linux 中，我选择使用 Fluent Reader[1] 作为我的阅读器，可以做简单的过滤，而且颜值还行。\n安装完 Fluent Reader 之后，直接在设置中选择服务，添加 Fever API 服务，端点是自己的服务器地址，加上 /api/fever.php 后缀，比如说 https://192.168.1.123:12382/api/fever.php，用户名密码是自己之前配置的用户名，以及 API 密码（注意不是登录密码）。\n\n\n\nhttps://github.com/yang991178/fluent-reader/ ↩︎\n\n\n在 iPhone 上，我暂时使用的是 NetNewsWire 和 Fluent Reader Lite[1] ，后面可能会考虑其它家的代替品。NetNewsWire 可以在软件中可以直接添加一个 Fresh RSS 账号，使用 /api/greader.php 作为后缀，并且还是用上述的用户名以及 API 密码访问，而 Fluent Reader Lite 的配置和桌面端一致。\n\n\n\nhttps://github.com/yang991178/fluent-reader-lite ↩︎\n\n\n\n\n\n\nhttps://github.com/FiloSottile/mkcert ↩︎\n\n\n\n","tags":["development","rss"]},{"title":"HDU1247 字典树","url":"/2010/11/06/obsidian/42ea8791-3396-4a07-a722-2e68c70dad1e/","content":"本题思路和一般字典树有所不同，将全部的字符串读入离线处理，insert 操作和大部分字典树一致，接下来就是一个 dfs 函数，枚举全部字符串是否是符合条件的，dfs 的 tim 参数表示了这个是第几次查询，如果遇到 danger 标记，就可以有两种路径，继续本次查询和进入下一个查询，这样讲每一个字符串都判断完毕即可。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;numeric&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;using namespace std;const int MAX = 1000000;struct Node {  Node* ne[26];  bool danger;} node[MAX], *root;char in[50010][50];int K;Node* New() {  Node* ret = &amp;node[K++];  for (int i = 0; i &lt; 26; i++) {    ret-&gt;ne[i] = NULL;  }  ret-&gt;danger = false;  return ret;}void init() {  K = 0;  root = New();}void insert(char* s) {  char* p = s;  Node* ptr = root;  int id;  while (*p) {    id = *(p++) - 'a';    if (ptr-&gt;ne[id] == NULL) {      ptr-&gt;ne[id] = New();    }    ptr = ptr-&gt;ne[id];  }  ptr-&gt;danger = true;}bool dfs(char* s, int tim) {  // tim=0 means that it is the first time search,  // otherwise it is the second time.  char* p = s;  Node* ptr = root;  int id;  while (*p) {    id = *(p++) - 'a';    if (ptr-&gt;ne[id] == NULL) {      return false;      // if the next pointer is null, return false.    }    ptr = ptr-&gt;ne[id];    // important.    // if this node is a danger case, we search a second time.    if (ptr-&gt;danger) {      if (tim == 0 &amp;&amp; *p &amp;&amp; dfs(p, 1)) {        return true;      }    }  }  // if the node is dangerous and the string has been completely search  // return true.  if (tim == 1 &amp;&amp; ptr-&gt;danger) {    return true;  } else {    return false;  }}int main() {  int n = 0;  init();  while (gets(in[n])) {    insert(in[n]);    n++;  }  for (int i = 0; i &lt; n; i++) {    if (dfs(in[i], 0)) {      puts(in[i]);    }  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"POJ2336 Ferry Loading II 动态规划","url":"/2010/10/10/obsidian/451351d0-54c8-40b6-9555-ed935753257b/","content":"好吧，今天开始正式学 DP，随便点了一个简单题，练了下手。。。\n这道题转移方程不难，O(n2)O(n^2)O(n2) 的复杂度，可以 AC。\ndp[i][j]dp[i][j]dp[i][j] 表示考虑跑了 iii 趟前 jjj 个车走完花的时间\n先进行对时间排序 (不知道为什么，第一次交没排序也 AC 了。。。。难道是原来就是有序的？)\ni≤ni \\leq ni≤n 时：dp[1][i]=a[i]+tdp[1][i] = a[i]+tdp[1][i]=a[i]+t\ni&gt;ni&gt;ni&gt;n 时：dp[1][i]=∞dp[1][i] = \\inftydp[1][i]=∞\n至于趟数大于 111 的，有如下转移方程：\ndp[k][i]=min⁡{max⁡(dp[i−1][j][j−1]+t,a[i])+t}dp[k][i] = \\min\\{\\max(dp[i-1][j][j-1]+t, a[i])+t\\}\ndp[k][i]=min{max(dp[i−1][j][j−1]+t,a[i])+t}\n其中\nmax⁡(i−n+1,1)≤j&lt;i\\max(i-n+1,1) \\leq j&lt;i\nmax(i−n+1,1)≤j&lt;i\n然后找 dp[i][m]dp[i][m]dp[i][m] 中最小的就可以了\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 1500;const int oo = 0x3f3f3f3f;int dp[MAX][MAX];int n, m, t;int a[MAX];void Dp() {  for (int i = 0; i &lt;= m; i++)    for (int j = 0; j &lt;= m; j++) {      dp[i][j] = oo;    }  for (int i = 1; i &lt;= n &amp;&amp; i &lt;= m; i++) {    dp[1][i] = a[i] + t;  }  for (int k = 2; k &lt;= m; k++) {    for (int i = 1; i &lt;= m; i++) {      for (int j = max(i - n + 1, 1); j &lt; i; j++) {        dp[k][i] = min(dp[k][i], max(dp[k - 1][j - 1] + t, a[i]) + t);      }    }  }}void Ans() {  int ret = oo, cot;  for (int i = 1; i &lt;= m; i++) {    if (dp[i][m] &lt; ret) {      ret = dp[i][m];      cot = i;    }  }  printf(\"%d %d\\n\", ret, cot);}int main() {  int T;  scanf(\"%d\", &amp;T);  while (T--) {    scanf(\"%d%d%d\", &amp;n, &amp;t, &amp;m);    for (int i = 1; i &lt;= m; i++) {      scanf(\"%d\", &amp;a[i]);    }    sort(a + 1, a + m);    Dp();    Ans();  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"HDU3080","url":"/2010/07/30/obsidian/497f5d7c-ad6f-4e87-b5e0-c201dcdc576b/","content":"下午看到了这题，第一反应就是 MST，既然是 MST，可以用 Kruskal 快速地解决问题，记住在输入所有边之后，删除村庄时把边删除，我的方法是开一个数组 extextext，ext[i]ext[i]ext[i] 表示 iii 是否存在，在对边结构体排序的时候，把不存在的边通通放到后面去，这样，当 Kruskal 过程中，找到一个不存在的边时，就退出，这样会节省比较多的时间。\n\n并查集初始化的时候要全部初始化，以防出现不用的情况。\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int MAX = 210;int n, cnt, ret;int p[MAX], rank[MAX];bool ext[MAX];struct Edge {  int from;  int to;  int weight;  bool operator&lt;(const Edge&amp; edge) const {    if (ext[from] == false || ext[to] == false) return false;    if (ext[edge.from] == false || ext[edge.to] == false) return true;    return weight &lt; edge.weight;  }} edge[MAX * MAX];void Init() {  for (int i = 0; i &lt; 210; i++) {    p[i] = i;    rank[i] = 0;  }}void Link(int x, int y) {  if (rank[x] &lt; rank[y])    p[x] = y;  else {    p[y] = x;    if (rank[x] == rank[y]) rank[x]++;  }}int Find(int x) {  if (p[x] != x) p[x] = Find(p[x]);  return p[x];}void Union(int x, int y) { Link(Find(x), Find(y)); }bool Kruskal() {  sort(edge, edge + cnt);  int done = 0;  Init();  for (int i = 0; i &lt; cnt &amp;&amp; done &lt; n - 1; i++) {    if (ext[edge[i].from] == false || ext[edge[i].to] == false) break;    if (Find(edge[i].from) != Find(edge[i].to)) {      done++;      ret += edge[i].weight;      Union(edge[i].from, edge[i].to);    }  }  if (done == n - 1)    return true;  else    return false;}int main() {  int t;  int x, y, w;  int nn, ee, m;  scanf(\"%d\", &amp;t);  while (t--) {    cnt = 0;    ret = 0;    memset(ext, 0, sizeof(ext));    scanf(\"%d%d\", &amp;nn, &amp;ee);    n = nn;    for (int i = 0; i &lt; nn; i++) ext[i] = true;    for (int i = 0; i &lt; ee; i++) {      scanf(\"%d%d%D\", &amp;x, &amp;y, &amp;w);      edge[cnt].from = x;      edge[cnt].to = y;      edge[cnt].weight = w;      cnt++;    }    scanf(\"%d%d\", &amp;nn, &amp;ee);    for (int i = n; i &lt; n + nn; i++) ext[i] = true;    n += nn;    for (int i = 0; i &lt; ee; i++) {      scanf(\"%d%d%D\", &amp;x, &amp;y, &amp;w);      edge[cnt].from = x;      edge[cnt].to = y;      edge[cnt].weight = w;      cnt++;    }    scanf(\"%d\", &amp;m);    n -= m;    for (int i = 0; i &lt; m; i++) {      scanf(\"%d\", &amp;x);      ext[x] = false;    }    if (Kruskal())      printf(\"%d\\n\", ret);    else      printf(\"what a pity!\\n\");  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"HDU3549 最大流入门","url":"/2010/11/25/obsidian/527fceb2-0cb9-4a53-963e-3838ea91a741/","content":"第一次写 EK，写了一个晚上没有什么大的进展，仔仔细细研究了一下论文，自己想了 BFS 找增广路的过程，写了一个邻接矩阵版的 EK 交上去，居然只跑了 30 多毫秒，不知道什么情况。。。。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int oo = 0x3f3f3f3f;int get() {  char ch;  int flag = 0, tmp = 0;  for (ch = getchar(); ch &lt; 48 || ch &gt; 57; ch = getchar())    if (ch == int('-')) break;  if (ch == int('-'))    flag = 1;  else    tmp = int(ch) - 48;  for (ch = getchar(); 48 &lt;= ch &amp;&amp; ch &lt;= 57; ch = getchar())    tmp = tmp * 10 + int(ch) - 48;  return (flag) ? -tmp : tmp;}int c[20][20], pre[20], low[20];int st, ed, n;int bfs() {  bool vis[20] = {0};  memset(low, 0, sizeof(low));  queue&lt;int&gt; q;  low[st] = oo;  q.push(st);  vis[st] = true;  while (!q.empty()) {    int u = q.front();    q.pop();    for (int v = 1; v &lt;= n; v++) {      if (!vis[v] &amp;&amp; c[u][v]) {        vis[v] = true;        pre[v] = u;        q.push(v);        low[v] = min(c[u][v], low[u]);      }    }  }  if (low[st]) {    int u = ed;    do {      c[pre[u]][u] -= low[ed];      c[u][pre[u]] += low[ed];      u = pre[u];    } while (u != st);  }  return low[ed];}int maxflow() {  int ret = 0;  do {    ret += bfs();  } while (low[ed]);  return ret;}int main() {  int t, m;  int cnt = 0;  t = get();  while (t--) {    cnt++;    n = get();    m = get();    memset(c, 0, sizeof(c));    for (int i = 0; i &lt; m; i++) {      int u = get();      int v = get();      int w = get();      c[u][v] += w;    }    st = 1;    ed = n;    printf(\"Case %d: %d\\n\", cnt, maxflow());  }  return 0;}\n注意 BFS 过程，low 作为全局变量。。。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"ZOJ2676 动态规划优化","url":"/2010/10/21/obsidian/57c761de-e19d-4830-81fb-9ff686325e1d/","content":"这道题裸的 dp 方程应该可以写的出来，我记录的状态如下：\ndp[i][j]dp[i][j]dp[i][j] 表示以 aia_iai​ 为第一个元素，aja_jaj​ 为第二个元素的斐波那契序列的最大长度，这样 i≤ji \\leq ji≤j 转移方程：\ndp[i][j]=dp[j][k]+1dp[i][j]=dp[j][k]+1\ndp[i][j]=dp[j][k]+1\n其中 ak=ai+aja_k=a_i+a_jak​=ai​+aj​\n从后向前扫描，每次更新 dpdpdp 值后更新最大长度以及第一第二项，最后的答案直接根据第一第二项迭代即可\n现在遇到的最大问题就是转移，裸的转移是 O(n)O(n)O(n) 的，直接从前向后扫一遍，找到第一个符合条件的 k，这样总的复杂度是枚举加上扫描，是 O(n3)O(n^3)O(n3) 的，明显对 nnn 为 300030003000 的数据来说太大了，不可取。\n后来想到了二叉树，嗯，就是 map，在树中维护值为 x 的最前位置，这样直接通过在树中找 ai+aja_i+a_jai​+aj​ 的最前位置即可，后来想想也不对，复杂度是 O(n2×logn)O(n^2 \\times logn)O(n2×logn) 的，对于 STL 的大常数不放心，算了一下 30002×lg30003000^2 \\times lg{3000}30002×lg3000 差不多 10810^8108 数量级，会 TLE。又开始想转移能不能压缩。\n最后想到 hash 的办法，因为转移无非就是在一个序列中找一个 xxx 对应的最前位置，直接将 xxx 进行 hash，对应的 hash 值的位置存放我们要的 xxx 对应的最前位置即可。\nhash 函数乱写的 - -\n发现其实数据重复的概率不大，没有优化，直接用了。。。\n这样可以在近似 O(1)O(1)O(1) 的时间内找到我们要的值，转移加上枚举就是 O(n2)O(n^2)O(n2) 的了\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 100000;const int mod = 100007;struct hbox {  int st;  hbox* s;} hash[MAX], *h[mod], *cur;int cnt[mod], pos;unsigned int BKDHash(int s) {  unsigned int r = abs(s);  return (r * r &amp; 0x7FFFFFFF) % mod;}bool has(int s, int&amp; pos) {  int d = BKDHash(s);  hbox* p = h[d];  while (p) {    if (s == p-&gt;st) {      pos = p - hash;      return true;    }    p = p-&gt;s;  }  return false;}void insert(int s, int v) {  int d = BKDHash(s);  hbox* p = h[d];  while (p) {    if (s == p-&gt;st) {      cnt[p - hash] = v;      return;    }    p = p-&gt;s;  }  cur-&gt;st = s;  cur-&gt;s = h[d];  h[d] = cur++;  cnt[cur - hash - 1] = v;}void init() {  memset(h, 0, sizeof(h));  cur = hash;}int a[3100];short dp[3100][3100];int main() {  int n;  int x, y, pos;  bool blocks = false;  int ret;  while (~scanf(\"%d\", &amp;n)) {    if (blocks) {      puts(\"\");    } else {      blocks = true;    }    init();    for (int i = 0; i &lt; n; i++) {      scanf(\"%d\", &amp;a[i]);    }    for (int i = 0; i &lt; n; i++) {      for (int j = i + 1; j &lt; n; j++) {        dp[i][j] = 1;      }    }    x = a[0];    ret = 0;    for (int j = n - 1; j &gt;= 0; j--) {      for (int i = j - 1; i &gt;= 0; i--) {        if (has(a[i] + a[j], pos)) {          dp[i][j] = dp[j][cnt[pos]] + 1;        }        if (dp[i][j] &gt; ret) {          x = a[i];          y = a[j];          ret = dp[i][j];        }      }      insert(a[j], j);    }    printf(\"%d\\n\", ret + 1);    printf(\"%d\", x);    for (int i = 0; i &lt; ret; i++) {      printf(\" %d\", y);      swap(x, y);      y += x;    }    puts(\"\");  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"Bochs 的实时时钟","url":"/2023/11/20/obsidian/591491c7-7f7f-445f-94d5-5f47a4de8aa2/","content":"摘抄自 ByteKits 上的文章 [1]，目前已不可用，做个备份（方便大家查阅）。\nclock 定义了 Bochs 内的时钟。\nsync 定义了如何将 Bochs 内部时间与实时同步的方法。值为’none’时，Bochs 时间依赖于 IPS 值，并且不使用主机时间同步。“减速” 方法牺牲性能以保持再现性，同时允许主机时间相关性。“实时” 方法牺牲了再现性，以保持性能和主机时间相关性。可以同时启用这两种同步方法。\nrtc_sync 选项与实时同步一起启用，RTC 将以实时速度运行。默认情况下，此功能处于禁用状态。\ntime0 指定虚拟机的开始（引导）时间。使用 time(2) 系统调用返回的时间值或 ctime(3) 系统调用返回的字符串。如果没有设置 time0 值，或者 time0 等于 1（特殊情况），或者 time0 等于 “local”，则模拟将在当前本地主机时间开始。如果 time0 等于 2（特殊情况）或 time0 等于’utc’，模拟将在当前 utc 时间开始。\n以下是一个例子：\nSyntax:  clock: sync=[none|slowdown|realtime|both], time0=[timeValue|local|utc]Examples:  clock: sync=none,     time0=local       # Now (localtime)  clock: sync=slowdown, time0=315529200   # Tue Jan  1 00:00:00 1980  clock: sync=none,     time0=\"Mon Jan  1 00:00:00 1990\" # 631148400  clock: sync=realtime, time0=938581955   # Wed Sep 29 07:12:35 1999  clock: sync=realtime, time0=\"Sat Jan  1 00:00:00 2000\" # 946681200  clock: sync=none,     time0=1           # Now (localtime)  clock: sync=none,     time0=utc         # Now (utc/gmt)Default value are sync=none, rtc_sync=0, time0=local\n\n\n\nhttp://www.bytekits.com/bochs/bochs-clock.html ↩︎\n\n\n\n","categories":["development"]},{"title":"天津大学 2010 年区域赛 1007 Giant For","url":"/2010/09/13/obsidian/5b4a90ef-f480-469c-9201-8d6a9ed093bb/","content":"这题典型的线段树加离散化，比赛的时候没有思路，中午突然想到了怎么实现。\n这题主要的思路是将全部的数据读取进来然后离线处理，离散化的时候把不同的点按照先 xxx 后 yyy 的方式离散化，也就是说只要两个点不是同一个点，那么他们的离散化后的 hash 值就不一样，将离散化后的值放到 lst 数组中去。\n在线段树中维护第 iii 个 lstlstlst 元素是否存在，如果存在，那么线段树中的第 iii 个元素值就是 lst[i]lst[i]lst[i] 对应的 yyy 值，否则就为 −1-1−1，segsegseg 的值记录 [l,r][l,r][l,r] 区间的最大值。每次 find 的时候，读取的如果是 x,yx, yx,y，那么去找 [x+1,M][x+1,M][x+1,M] 区间，优先找左边的区间，如果左边区间的最大值比 yyy 来的大，那么解一定在左边区间，如果左边区间的最大值小于或等于 yyy，那么用同样的方法找右区间，如果依然没有比 yyy 大的，那么返回 −1-1−1，否则返回第一个比 yyy 大的区间在 lstlstlst 数组中对应的脚标。\n主要是离散化的方式有点特别，先按 xyxyxy 排序，记录 lstlstlst 数组，然后按 ididid 排序，返回原来输入的顺序，这样保证了读取的顺序和输入顺序一致。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int MAX = 200100;struct Lst {  int x, y;} lst[MAX];struct Node {  int op;  int x, y;  int id;  int val;  int nxt;} node[MAX];int n, M;int seg[4 * MAX];bool comp1(const Node&amp; a, const Node&amp; b) {  if (a.x != b.x)    return a.x &lt; b.x;  else    return a.y &lt; b.y;}bool comp2(const Node&amp; a, const Node&amp; b) { return a.id &lt; b.id; }void hash() {  for (int i = 0; i &lt; n; i++) node[i].id = i;  sort(node, node + n, comp1);  M = 1;  node[0].val = M;  lst[M].x = node[0].x;  lst[M].y = node[0].y;  for (int i = 1; i &lt; n; i++) {    if (node[i].x == node[i - 1].x &amp;&amp; node[i].y == node[i - 1].y)      node[i].val = M;    else {      node[i].val = ++M;      lst[M].x = node[i].x;      lst[M].y = node[i].y;    }  }  node[n - 1].nxt = -1;  for (int i = n - 2; i &gt;= 0; i--) {    if (node[i].x != node[i + 1].x)      node[i].nxt = node[i + 1].val;    else      node[i].nxt = node[i + 1].nxt;  }  sort(node, node + n, comp2);}void init(int k, int l, int r) {  if (l == r) {    seg[k] = 0;    return;  }  int mid = (l + r) / 2;  init(2 * k, l, mid);  init(2 * k + 1, mid + 1, r);  seg[k] = 0;}void update(int k, int l, int r, int idx, int v) {  if (l == r) {    seg[k] = v;    return;  }  int mid = (l + r) / 2;  if (idx &lt;= mid)    update(2 * k, l, mid, idx, v);  else    update(2 * k + 1, mid + 1, r, idx, v);  seg[k] = max(seg[2 * k], seg[2 * k + 1]);}int read(int k, int l, int r, int a, int b, int v) {  int tmp;  int mid = (l + r) / 2;  if (l &gt; b || r &lt; a) return -1;  if (seg[k] &lt;= v) return -1;  if (l == r) return l;  if (l &gt;= a &amp;&amp; r &lt;= b) {    if (seg[2 * k] &gt; v)      return read(2 * k, l, mid, a, b, v);    else      return read(2 * k + 1, mid + 1, r, a, b, v);  }  tmp = read(2 * k, l, mid, a, b, v);  if (tmp &gt;= 0) return tmp;  tmp = read(2 * k + 1, mid + 1, r, a, b, v);  if (tmp &gt;= 0) return tmp;  return -1;}int main() {  char op[100];  int id;  int cnt = 1;  while (scanf(\"%d\", &amp;n), n) {    if (cnt != 1) printf(\"\\n\");    for (int i = 0; i &lt; n; i++) {      scanf(\"%s%d%d\", op, &amp;node[i].x, &amp;node[i].y);      if (op[0] == 'a')        node[i].op = 1;      else if (op[0] == 'r')        node[i].op = 2;      else        node[i].op = 3;    }    hash();    init(1, 1, M);    printf(\"Case %d:\\n\", cnt++);    for (int i = 0; i &lt; n; i++) {      switch (node[i].op) {        case 1:          update(1, 1, M, node[i].val, node[i].y);          break;        case 2:          update(1, 1, M, node[i].val, -1);          break;        case 3:          if (node[i].nxt &lt; 0) {            printf(\"-1\\n\");            break;          }          id = read(1, 1, M, node[i].nxt, M, node[i].y);          if (id &lt; 0)            printf(\"-1\\n\");          else            printf(\"%d %d\\n\", lst[id].x, lst[id].y);          break;      }    }  }  return 0;}\n看来还是见世面见的太少了，很多算法没有思路。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"SRM477 DIV2 1000","url":"/2023/11/02/obsidian/65db2f7a-6679-4d90-b904-10991cd0d16b/","content":"这题还是看了官方的解题报告才明白怎么做的，动态规划加记忆化搜索。\ndp[n][k]dp[n][k]dp[n][k] 代表 nnn 个人中有 kkk 个人都拿错信件的状态数目，\n\n当 n=k=0n=k=0n=k=0 时：dp[n][k]=1dp[n][k]=1dp[n][k]=1\nn=0n=0n=0 时：dp[n][k]=0dp[n][k]=0dp[n][k]=0\nk=0k=0k=0 时：dp[n][k]=n×dp[n−1][k]dp[n][k]=n \\times dp[n-1][k]dp[n][k]=n×dp[n−1][k]\n 否则：dp[n][k]=(n−k)×(dp[n−2][k−1]+dp[n−1][k])+(k−1)×(dp[n−2][k−2]+dp[n−1][k−1])dp[n][k]=(n-k) \\times (dp[n-2][k-1]+dp[n-1][k])+(k-1) \\times (dp[n-2][k-2]+dp[n-1][k-1])dp[n][k]=(n−k)×(dp[n−2][k−1]+dp[n−1][k])+(k−1)×(dp[n−2][k−2]+dp[n−1][k−1])\n\n注意：当 k=1k=1k=1 时，没有后半部分\n\nconst int MAX = 1100;const LL mod = 1000000007;LL dp[MAX][MAX];LL dfs(int n, int k) {  if (dp[n][k] != -1) return dp[n][k];  if (n == 0 &amp;&amp; k == 0)    dp[n][k] = 1;  else if (n == 0)    dp[n][k] = 0;  else if (k == 0)    dp[n][k] = (n * dfs(n - 1, k)) % mod;  else if (k == 1) {    if (n &gt; 1)      dp[n][k] = ((n - k) * (dfs(n - 2, k - 1) + dfs(n - 1, k))) % mod;    else      dp[n][k] = 0;  } else    dp[n][k] = ((n - k) * (dfs(n - 2, k - 1) + dfs(n - 1, k)) +                (k - 1) * (dfs(n - 2, k - 2) + dfs(n - 1, k - 1))) %               mod;  return (int)dp[n][k];}class CarelessSecretary { public:  int howMany(int N, int K) {    for (int i = 0; i &lt;= N; i++)      for (int j = 0; j &lt;= K; j++) dp[i][j] = -1;    return (int)dfs(N, K);  }};\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"2011-07-31 阶段性总结","url":"/2011/07/31/obsidian/67894163-d723-418a-98fc-5c5f51f57e05/","content":"这个 blog 好久没有上来看了，看到原来写的一些文章，发现现在的代码风格完全变了个样儿，大半年没有写博文了，主要还是比较忙的原因，现在发现对于一些题目的理解，不能只局限于对某一题的做法的理解，要把相似问题转化为模型，这样我们才能在比赛中获得比较好的成绩。\n这半年可以说自己的代码风格完全变了，我觉得代码要有可读性，不然的会查起来会很痛苦，和队友磨合了一两个月了，渐渐找到了那种感觉，就是这段时间的状态和队友比起来差了许多，一个主代码的居然沦落到天天比赛打酱油的地步，这是很囧的一件事儿。\n这段时间要好好地调整状态了，队友八月初去北京参加百度之星的比赛，那一周队内的主要代码还是要由我来负责了，但愿这几天可以把状态找到吧，不然多校联合会打的很挫很挫。\n先把数据结构和计算几何放放，把基础的东西的代码写稳了，虽然自己偏后期， 但是前期一定属于我的，这样我们队的代码基本上要由我来负责，只有我多负责一些代码的实现，两个思维型的队友才能完全发挥出他们特长。\n后面有空还是会写一些总结的，不过现在没有贴代码的习惯了，多写写思路和扩展吧。\n","categories":["杂谈"],"tags":["CSDN","杂谈"]},{"title":"China Final 2016 C 题瞎扯淡","url":"/2016/12/14/obsidian/6a8f1383-644e-4e9e-99f6-ba2a1a3ee573/","content":"周末去上海大学的 ACM/ICPC China Final，新的一赛季也结束了，出了个 “Mr. Panda and Strips” 直接身败名裂（一个奇怪的梗：我怀疑出 C 这个题的人啊，他不会做题啊？（x\n大概不会补其它题的题解了暂时（看情况吧。。。\n\n这破题出的刚想出 idea 的时候一群人讨论了下，finalize 了一个 O(N2lg⁡N)O(N^2 \\lg N)O(N2lgN) 的做法，大致的思路是枚举第一个区间的左右边界 LLL 和 RRR，然后去维护第二个区间，对于第二个区间，我们维护一个区间的集合 SSS，我们把区间内的元素表示成三元组 (l,r,m)(l, r, m)(l,r,m)，表示如果第二段区间的起点 L′L'L′ 是处于 [l,r][l, r][l,r] 这个区间内的话，它可以向右延伸的右边界就是 mmm，也就是说，对于确定了 RRR 的情况下，最后的答案应该是\n(R−L+1)+max⁡k∈S(mk−lk+1)(R - L + 1) + \\max_{k \\in S} \\left(m_k - l_k + 1\\right)\n(R−L+1)+k∈Smax​(mk​−lk​+1)\n我们考虑增加 RRR （双指针），当 RRR 增加 111 的时候，你会发现，有一些区间包含了数字 aRa_RaR​，那么我们要考虑把这些区间拆成多个区间，对于一个区间 (l,r,m)(l, r, m)(l,r,m)，如果存在 k∈[l,m]k \\in [l, m]k∈[l,m] 使得 ak=aRa_k = a_Rak​=aR​ 的话，我们就把它拆掉。我们令 ap=aRa_p = a_Rap​=aR​，对于小于 ppp 的来说，我们可以拆成一个区间 (l,p−1,p)(l, p - 1, p)(l,p−1,p)，对于大于 ppp 的来说，我们可以拆成区间 (p+1,r,m)(p + 1, r, m)(p+1,r,m)。那么，当我们 RRR 增加的时候，我们逐个地去看所有满足条件的 ppp，维护一个 ordered set 去查找包含 ppp 的区间，对于每个 ppp，有且只有一个对应的需要拆分的区间（注意一点就是集合 SSS 中的区间，lll, rrr 和 mmm 都是严格递增的，而且没有 [l,r][l, r][l,r] 交集）。\n这样搞一搞就 O(N2lg⁡N)O(N^2 \\lg N)O(N2lgN) 了？啊，什么？你觉得这样不优美，那么这里不优美的地方在哪啊！还不是要用 ordered set 去找要拆的区间么！那我反过来做 （RRR 从大到小枚举）是不是就变成了区间合并问题了？那么区间合并问题是不是就是并查集合并省下一个 lg⁡N\\lg NlgN 了？\n那么，我们就把 RRR 从大到小枚举吧。。。首先我们先来算两个数组的值\n\n一个是 bbb, bib_ibi​ 表示大于 iii 并且 ap=aia_p = a_iap​=ai​ 的最小的位置 ppp。\n另外一个是 ccc, cic_ici​ 表示对于 i≤k≤pi \\leq k \\leq pi≤k≤p 条件下 min⁡bk≤p\\min{b_k} \\leq pminbk​≤p 的最大的位置 ppp。\n\n当我们 RRR 变小的时候，就会有两个（只会有两个）区间发生了合并，大概上就是区间 (l,p−1,p)(l, p - 1, p)(l,p−1,p) 和 (p+1,r,m)(p + 1, r, m)(p+1,r,m) 被修改成了区间 (l,p−1,m1)(l, p - 1, m_1)(l,p−1,m1​) 和区间 (p,r,m2)(p, r, m_2)(p,r,m2​)。如果我们枚举 ppp 的时候是从大到小的话，这里 m2m_2m2​ 应该就等于 mmm 了，对于 m1m_1m1​ 来说，我们考虑先预处理出 [l,p−1][l, p - 1][l,p−1] 里面可以向右扩展的最大距离（这里其实就是 bkb_kbk​ 的最小值），那么 m1m_1m1​ 就可以通过 bbb 数组和现在有大于 ppp 的最小的不能选位置 qqq （在第一段中出现过），还有数组 ccc，来更新答案。\nm1=min⁡(min⁡l≤k≤p−1(bk),q,cp+1)m_1 = \\min(\\min_{l \\leq k \\leq p - 1}(b_k), q, c_{p + 1})\nm1​=min(l≤k≤p−1min​(bk​),q,cp+1​)\n对于这个合并的做法，我们可以直接利用并查集维护 [l,r][l, r][l,r] 这个集合，然后并查集的值存 mmm 就可以表示区间 (l,r,m)(l, r, m)(l,r,m) 了。总体复杂度 O(N2⋅α(n))O(N^2 \\cdot \\alpha(n))O(N2⋅α(n))。\n","categories":["ICPC题解"],"tags":["ICPC题解","杂谈"]},{"title":"POJ1804 逆序对","url":"/2010/08/29/obsidian/6c81bc58-f390-4c93-9678-f5d243d4f13e/","content":"求逆序对的题目，可以用暴力、树状数组来实现。\n\n 暴力法\nO(n2)O(n^2)O(n2) 对于 100010001000 的规模完全可以做，直接找第 iii 个元素之后有多少个比其小的元素即可。\n代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;int main() {  int t, n, cnt = 0;  int a[1005];  int ret;  scanf(\"%d\", &amp;t);  while (t--) {    cnt++;    scanf(\"%d\", &amp;n);    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;a[i]);    ret = 0;    for (int i = 0; i &lt; n; i++)      for (int j = i + 1; j &lt; n; j++)        if (a[i] &gt; a[j]) ret++;    printf(\"Scenario #%d:\\n\", cnt);    printf(\"%d\\n\", ret);    if (t) printf(\"\\n\");  }  return 0;}\n 运用树状数组\n每次维护小于 KKK 的数的个数，从后往前求和，时间复杂度是 O(nlgn)O(nlgn)O(nlgn) 的，注意数的范围很大，是 200000020000002000000，这样用这种方法反而不快。\n代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int MAX = 2000100;int seg[MAX], a[1100];void add(int k) {  while (k &lt; MAX) {    seg[k]++;    k += k &amp; -k;  }}int sum(int k) {  int ret = 0;  while (k) {    ret += seg[k];    k -= k &amp; -k;  }  return ret;}int main() {  int t, n, cnt = 0;  int ret;  scanf(\"%d\", &amp;t);  while (t--) {    cnt++;    scanf(\"%d\", &amp;n);    for (int i = 0; i &lt; n; i++) {      scanf(\"%d\", &amp;a[i]);      a[i] += 1000001;    }    ret = 0;    memset(seg, 0, sizeof(seg));    for (int i = n - 1; i &gt;= 0; i--) {      ret += sum(a[i] - 1);      add(a[i]);    }    printf(\"Scenario #%d:\\n\", cnt);    printf(\"%d\\n\", ret);    if (t) printf(\"\\n\");  }  return 0;}\n 运用线段树\n我也尝试写了一下，但是超时了，由于数的范围大，而线段树的初始化时间效率低，线段树的初始化时间是 O(nlgn)O(nlgn)O(nlgn) 而树状数组的初始化时间是 O(n)O(n)O(n) 的，这里差距很大。\n总结：能用树状数组代替线段树的，尽量代替，不仅代码量小，而且效率高。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"ZOJ2011-Dynamic Rankings 树套树？","url":"/2011/09/30/obsidian/7469f967-9d4b-46ca-8a80-ed9a1b23f1a2/","content":"好久没有写博文了，这题是刚才被 lrj 的题虐了之后写的，这题的题意是告诉你 NNN 个数的序列，每次修改一个位置的值，动态查询区间第 kkk 个元素\n做法是维护一个线段树，这样我们就可以得到区间的信息，但是这时候我们并不能维护区间有序的序列，所以我们要二分答案，查询 lll 到 rrr 区间内比这个数小的有多少，和 kkk 做比较，然后最后得到答案，写起来就是一个线段树和一个平衡树，对于平时写数据结构写多的来说代码量一般，我的代码一向都很长，写了 200 行左右。\n\n#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;typedef long long ll;const int MAX = 50005;const int oo = 0x3f3f3f3f;struct Node {  int key, size;  Node* c[2];} memo[MAX * 20], *cur, *nil;int a[MAX], n, q;struct Seg {  int l, r;  Node* root;} seg[MAX &lt;&lt; 2];inline Node* New(int v) {  cur-&gt;key = v;  cur-&gt;size = 1;  cur-&gt;c[0] = cur-&gt;c[1] = nil;  return cur++;}inline void rotate(Node*&amp; t, int f) {  Node* k = t-&gt;c[f ^ 1];  t-&gt;c[f ^ 1] = k-&gt;c[f];  k-&gt;c[f] = t;  k-&gt;size = t-&gt;size;  t-&gt;size = t-&gt;c[0]-&gt;size + t-&gt;c[1]-&gt;size + 1;  t = k;}inline void keep(Node*&amp; t, int f) {  if (t == nil)    return;  else if (t-&gt;c[f]-&gt;c[f]-&gt;size &gt; t-&gt;c[f ^ 1]-&gt;size)    rotate(t, f ^ 1);  else if (t-&gt;c[f]-&gt;c[f ^ 1]-&gt;size &gt; t-&gt;c[f ^ 1]-&gt;size)    rotate(t-&gt;c[f], f), rotate(t, f ^ 1);  else    return;  for (int i = 0; i &lt; 2; i++) keep(t-&gt;c[i], i);  for (int i = 0; i &lt; 2; i++) keep(t, i);}inline void insert(Node*&amp; t, int v) {  if (t == nil) {    t = New(v);  } else {    t-&gt;size++;    insert(t-&gt;c[v &gt;= t-&gt;key], v);    keep(t, v &gt;= t-&gt;key);  }}inline Node* del(Node*&amp; t, int v) {  Node* p;  if (t == nil) return nil;  t-&gt;size--;  if (v == t-&gt;key || t-&gt;c[v &gt; t-&gt;key] == nil) {    if (t-&gt;c[0] != nil &amp;&amp; t-&gt;c[1] != nil)      p = del(t-&gt;c[0], v + 1), t-&gt;key = p-&gt;key;    else      p = t, t = t-&gt;c[t-&gt;c[0] == nil];    return p;  } else    return del(t-&gt;c[v &gt; t-&gt;key], v);}inline int getRank(Node* t, int v) {  int ret = 0;  while (t != nil)    if (t-&gt;key &lt; v)      ret += t-&gt;c[0]-&gt;size + 1, t = t-&gt;c[1];    else      t = t-&gt;c[0];  return ret;}inline void init() {  nil = cur = memo;  nil = New(0);  nil-&gt;size = 0;}inline void init(int k, int l, int r) {  seg[k].l = l;  seg[k].r = r;  seg[k].root = nil;  for (int i = l; i &lt;= r; i++) {    insert(seg[k].root, a[i]);  }  if (l == r) return;  int mid = l + r &gt;&gt; 1;  init(k &lt;&lt; 1, l, mid);  init(k &lt;&lt; 1 | 1, mid + 1, r);}inline void set(int k, int idx, int v) {  del(seg[k].root, a[idx]);  insert(seg[k].root, v);  if (seg[k].l == seg[k].r) return;  int mid = seg[k].l + seg[k].r &gt;&gt; 1;  if (idx &lt;= mid)    set(k &lt;&lt; 1, idx, v);  else    set(k &lt;&lt; 1 | 1, idx, v);}inline int read(int k, int l, int r, int v) {  if (l &gt; r || seg[k].l &gt; r || seg[k].r &lt; l) return 0;  if (seg[k].l &gt;= l &amp;&amp; seg[k].r &lt;= r) {    return getRank(seg[k].root, v);  }  return read(k &lt;&lt; 1, l, r, v) + read(k &lt;&lt; 1 | 1, l, r, v);}inline int doit(int lb, int rb, int k) {  int l = -1000000005, r = 1000000005, mid;  int ret;  while (l &lt; r) {    mid = l + r + 1 &gt;&gt; 1;    ret = read(1, lb, rb, mid);    if (ret &lt; k)      l = mid;    else      r = mid - 1;  }  return l;}inline void doit() {  char op[5];  int l, r, k;  init();  init(1, 1, n);  while (q--) {    scanf(\"%s\", op);    if (op[0] == 'Q') {      scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;k);      printf(\"%d\\n\", doit(l, r, k));    } else {      scanf(\"%d%d\", &amp;l, &amp;r);      set(1, l, r);      a[l] = r;    }  }}int main() {  int T;  scanf(\"%d\", &amp;T);  while (T--) {    scanf(\"%d%d\", &amp;n, &amp;q);    for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]);    doit();  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"HDU3415 单调队列","url":"/2010/12/06/obsidian/74798e15-d69f-4796-a7b8-e12ff42f9e83/","content":"这题是单调队列的典型运用。\n至于单调队列，就是一个双端队列，在队首 (fff) 出队，在队尾 (bbb) 出队入队，我们要维护整个队列的元素是单调的，比如，我们要动态查询从左向右的区间的最小值，那么我们就要在队列中维护一个单调递增的序列，从左向右枚举，队列的元素还有一个 ididid 值，代表这个元素在原序列中的位置，然后左边的元素如果不在范围内了，就判断队首的元素 ididid 是否是这个左边的 id，是的话就出队，否则就不管。关于元素入队，首先判断入队的元素是否大于队尾的元素 (保证队列单调递增)，如果不大于，那么弹出队尾元素，直到队尾元素小于入队元素或者队列为空。\n枚举 sum[i]sum[i]sum[i] 表示前 iii 个元素的和，注意这里为了实现循环的序列要将 nnn 扩展到 2n2n2n。\n然后枚举每一个 sum[i]sum[i]sum[i]，找到 iii 之前 kkk 个元素 [i−k,j][i-k, j][i−k,j] 区间内的 sumsumsum 最小值 sum[k]sum[k]sum[k]，sum[i]−sum[k]sum[i] - sum[k]sum[i]−sum[k] 就是最优解，然后取全局最优解即可。\n注意一点在队列中在处理队列之前就要先将 i−k−1i - k - 1i−k−1 号元素删除，我们要在队列维护最多 k+1k + 1k+1 个元素，然后去最值，最后才将 sum[i]sum[i]sum[i] 入队。\n复杂度 O(n)O(n)O(n)。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 200010;const int oo = 0x3f3f3f3f;int q[MAX], val[MAX], id[MAX], f, b;int main() {  int t, n, k;  freopen(\"in.txt\", \"r\", stdin);  scanf(\"%d\", &amp;t);  while (t--) {    scanf(\"%d%d\", &amp;n, &amp;k);    for (int i = 0; i &lt; n; i++) {      scanf(\"%d\", &amp;val[i]);      val[i + n] = val[i];    }    n *= 2;    for (int i = 1; i &lt; n; i++) {      val[i] += val[i - 1];    }    f = b = 0;    int ret = -oo, st, ed;    for (int i = 0; i &lt; n; i++) {      if (f != b &amp;&amp; id[f] == i - k - 1) f++;      if (i &lt; k &amp;&amp; ret &lt; val[i]) {        ret = val[i];        st = 1;        ed = i % (n / 2) + 1;      }      if (f == b) {        if (i &amp;&amp; ret &lt; val[i] - val[i - 1]) {          ret = val[i] - val[i - 1];          st = i % (n / 2) + 1;          ed = i % (n / 2) + 1;        } else if (ret &lt; val[i]) {          ret = val[i];          st = ed = i % (n / 2) + 1;        }      } else {        if (ret &lt; val[i] - val[id[f]]) {          ret = val[i] - val[id[f]];          st = (id[f] + 1) % n + 1;          ed = i % (n / 2) + 1;        }      }      while (f != b &amp;&amp; q[b - 1] &gt; val[i]) b--;      id[b] = i;      q[b++] = val[i];    }    printf(\"%d %d %d\\n\", ret, st, ed);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"一类区间动态规划的优化 - Key Words","url":"/2016/04/07/obsidian/77353ef3-4165-402c-9337-38a0166915a5/","content":"上周末 UESTC 校赛初赛，由于养老群里奇怪的爷爷一上来就开写这题还说挺好玩的，就看了下。\n这是一个看上去是字符串的字符串题（雾\n\n大致背景\n给你一个长度为 200200200 的回文串  SSS ，一开始给你一个空串 TTT ，你可以选择 TTT 的一个位置，加一个特定的串 SSS 进去。比如说 SSS 是 aba，那么做了两次操作之后， TTT 就可能是 aababa。\n\n现在给你串 TTT ，要你输出所有可能的 SSS 。\n第一反应，枚举子串，用区间 DP 判断是否可行。首先 SSS 满足\n\n长度能被 TTT 的长度整除\n是一个回文\n是 TTT 的一个子串\n\n根据这三点，可以得到一个结论，不同的 SSS 的个数最多只有 LLL 个，这里 LLL 是 TTT 的长度。\n然后嘛，当时第一反应 DP 状态是这个样子的\ndp[l][r]dp[l][r]\ndp[l][r]\n表示区间 lll 到 rrr 是否可行。\n这样的状态，转移应该是\ndp[l][r]=⋁l′≤lr′≥rdp[l′][r′]dp[l][r] = \\bigvee_{\\substack{l' \\leq l\\\\r' \\geq r}}dp[l'][r']\ndp[l][r]=l′≤lr′≥r​⋁​dp[l′][r′]\n这里 l′l'l′ 到 lll 还有 rrr 到 r′r'r′ 这一段可以构成 SSS 。\n对于转移，如果是暴力的话，DP 的复杂度是 O(N4)O(N^4)O(N4) 的，总体复杂度是 O(N5)O(N^5)O(N5) ，内存的复杂是 O(N2)O(N^2)O(N2) 。\n考虑到时间复杂度有点高（嗯，只是一点啦），考虑把把 SSS 的信息带到状态中去，我们定义状态\ndp[l][r][i]dp[l][r][i]\ndp[l][r][i]\n表示考虑到区间 (l,r)(l, r)(l,r) ，我们最左边已经匹配完了 SSS 的前 iii 个字符的方法是否可行。那么转移就是\ndp[l][r][i]=dp[l+1][r][i+1]∨⋁r′≥r(dp[l][r′][0]∧dp[r′+k][r][0])dp[l][r][i] = dp[l + 1][r][i + 1] \\lor \\bigvee_{r' \\geq r}\\left(dp[l][r'][0] \\land dp[r' + k][r][0]\\right)\ndp[l][r][i]=dp[l+1][r][i+1]∨r′≥r⋁​(dp[l][r′][0]∧dp[r′+k][r][0])\n其中，要么匹配 SSS 的当前位，要么把 SSS 剩下的用右边匹配掉，这里 kkk 是 SSS 剩下的长度，这样转移复杂度是 O(N)O(N)O(N) 的，总体复杂度是 O(N3)O(N^3)O(N3) 。\n这样总体复杂还算可以了（不过会 T 的吧大概，我猜的（。\n回忆下 LCIS 的 DP，其实我们可以不需要枚举右边那段的位置，而让 DP 回来之后继续做 (r′,r′+k)(r', r' + k)(r′,r′+k) 区间的匹配。定义状态\ndp[i][j][k]dp[i][j][k]\ndp[i][j][k]\n表示我们还要匹配 iii 个 SSS 串，现在在 TTT 的第 jjj 位，在 SSS 的第 kkk 位，这个状态是否可行。注意我们有一个很强的条件，就是第一维和第三维的大小之积正好是 NNN 。也就是说，这个状态是 O(N2)O(N^2)O(N2) 的。\n这样，对于转移我们可以在 O(1)O(1)O(1) 时间内处理\ndp[i][j][k]=dp[i][j−1][k−1]∨⋁p(dp[k][j][0]∧dp[i][j+p×l][k])dp[i][j][k] = dp[i][j - 1][k - 1] \\lor \\bigvee_{p}\\left({dp[k][j][0] \\land dp[i][j + p \\times l][k]}\\right)\ndp[i][j][k]=dp[i][j−1][k−1]∨p⋁​(dp[k][j][0]∧dp[i][j+p×l][k])\n其中 lll 是 SSS 的长度， ppp 是枚举的中间自匹配了多少个 SSS ，总体的转移是 O(Ll)O(\\frac{L}{l})O(lL​) 的。\n这样的话，整个 DP 的复杂度是 O(N2×Ll)O(N^2 \\times \\frac{L}{l})O(N2×lL​) 的，总体复杂度会小于 O(N4)O(N^4)O(N4) ？（根本不想分析复杂度。。。\n","categories":["ICPC题解"],"tags":["ICPC题解"]},{"title":"从多校联合 NUDT 第二题 Cube 想到的关于树状数组的结论","url":"/2010/09/01/obsidian/78161c65-7f4b-4b99-903c-401c80255d6f/","content":"这题一眼看去就是更新区间查找点，典型的树状数组解法，但是如果用三维树状数组的话，会遇到一个难题，那就是怎么分割？\n我们看简单的问题开始，对于一维的情况，将区间 (a,b)(a,b)(a,b) 进行更新，那么就在 aaa 处加 vvv，b+1b+1b+1 处减 vvv 即可。\n对于二维的情况，那就麻烦一点，将区域 (x1,y1)(x_1, y_1)(x1​,y1​) 到 (x2,y2)(x_2, y_2)(x2​,y2​) 进行更新，那么就在 (x1,y1)(x_1, y_1)(x1​,y1​) 处加 vvv，在 (x2+1,y1)(x_2+1,y_1)(x2​+1,y1​) 和 (x1,y2+1)(x_1,y_2+1)(x1​,y2​+1) 处减 v，在 (x2+1,y2+1)(x_2+1, y_2+1)(x2​+1,y2​+1) 处加 v 即可。\n那么三维的呢？经过画图，我得到了结论，那就是 (x1,y1,z1)(x_1, y_1, z_1)(x1​,y1​,z1​) 加 v，和 (x1,y1,z1)(x_1, y_1, z_1)(x1​,y1​,z1​) 相邻奇数长度的点减 vvv，这些点有 (x2+1,y1,z1)(x_2+1, y_1, z_1)(x2​+1,y1​,z1​)、(x1,y2+1,z1)(x_1, y_2+1, z_1)(x1​,y2​+1,z1​)、(x1,y1,z2+1)(x_1, y_1, z_2+1)(x1​,y1​,z2​+1) 还有 (x2+1,y2+1,z2+1)(x_2+1, y_2+1, z_2+1)(x2​+1,y2​+1,z2​+1)，剩下的就是加 vvv 了。\n把三个维度不同的树状数组的情况和在一起，源点 PPP 加 vvv 和 PPP 相邻奇数位置的减 vvv，偶数位置的加 vvv，这样就可以快速地记下来全部的切割情况了。\n\n我的代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int MAX = 110;int n;int tree[MAX][MAX][MAX];void add(int x, int y, int z, int v) {  int tmp1 = y;  int tmp2 = z;  while (x &lt;= n) {    y = tmp1;    while (y &lt;= n) {      z = tmp2;      while (z &lt;= n) {        tree[x][y][z] += v;        z += z &amp; -z;      }      y += y &amp; -y;    }    x += x &amp; -x;  }}int read(int x, int y, int z) {  int tmp1 = y;  int tmp2 = z;  int sum = 0;  while (x) {    y = tmp1;    while (y) {      z = tmp2;      while (z) {        sum += tree[x][y][z];        z -= z &amp; -z;      }      y -= y &amp; -y;    }    x -= x &amp; -x;  }  return sum;}int main() {  int m;  int x1, x2, y1, y2, z1, z2, op;  while (scanf(\"%d%d\", &amp;n, &amp;m) != EOF) {    for (int i = 1; i &lt;= n; i++)      for (int j = 1; j &lt;= n; j++)        for (int k = 1; k &lt;= n; k++) tree[i][j][k] = 0;    for (int i = 0; i &lt; m; i++) {      scanf(\"%d\", &amp;op);      if (op) {        scanf(\"%d%d%d\", &amp;x1, &amp;y1, &amp;z1);        scanf(\"%d%d%d\", &amp;x2, &amp;y2, &amp;z2);        add(x1, y1, z1, 1);        add(x2 + 1, y1, z1, -1);        add(x1, y2 + 1, z1, -1);        add(x1, y1, z2 + 1, -1);        add(x2 + 1, y2 + 1, z1, 1);        add(x2 + 1, y1, z2 + 1, 1);        add(x1, y2 + 1, z2 + 1, 1);        add(x2 + 1, y2 + 1, z2 + 1, -1);      } else {        scanf(\"%d%d%d\", &amp;x1, &amp;y1, &amp;z1);        printf(\"%d\\n\", read(x1, y1, z1) % 2);      }    }  }  return 0;}\n总结：每次做题后要反思，不能做一题过一题，宁可花时间想怎么优化代码，毕竟这个对自己好处更大。做题不贵多，而贵精。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"POJ1002 的懒人做法","url":"/2010/07/31/obsidian/78d244d9-72cb-400d-b9d2-50260457d6a2/","content":"这道题的题意就是如果遇到相同的号码就输出，这样用 STL 中的 map 加上 string 可以写的很简单，但是结果就不是很好了。\n\n好囧的时间，2000ms 的题 1954ms 卡过，在代码中的 map 可以用离散化 hash 代替，可以大大地优化代码。\n我的代码思路就是读取字符串，hash，然后对应的映射加 1，最后统计大于等于 2 的全部输出即可，cnt 计数器，当 cnt 等于 0 的时候输出 No duplicates。之前漏了这个，WA 了两次。。。\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;using namespace std;const char hash[100] = \"22233344455566677778889999\";int main() {  int n, cnt, len;  string ret;  char str[100];  map&lt;string, int&gt; mp;  scanf(\"%d\", &amp;n);  while (n--) {    scanf(\"%s\", str);    cnt = 0;    ret = \"\";    len = strlen(str);    for (int i = 0; i &lt; len; i++) {      if (str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') {        ret += str[i];        cnt++;        if (cnt == 3) ret += '-';      } else if (str[i] &gt;= 'A' &amp;&amp; str[i] &lt; 'Z' &amp;&amp; str[i] != 'Q') {        ret += hash[str[i] - 'A'];        cnt++;        if (cnt == 3) ret += '-';      }      if (cnt == 7) break;    }    mp[ret]++;  }  cnt = 0;  map&lt;string, int&gt;::iterator it;  for (it = mp.begin(); it != mp.end(); it++) {    if ((*it).second &gt; 1) {      printf(\"%s %d\\n\", (*it).first.c_str(), (*it).second);      cnt++;    }  }  if (cnt == 0) printf(\"No duplicates.\\n\");  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"压缩 WSL2 的虚拟磁盘","url":"/2023/06/07/obsidian/7b7e8787-da60-4964-bb92-5d924176696a/","content":"在使用 WSL2 的时候，我们有的时候会因为不断增减文件，导致对应的虚拟磁盘的文件大小远超过预期，并且需要进行清理，我们可以通过 diskpart 打开虚拟磁盘管理工具，然后通过如下命令进行操作 [1]：\nselect vdisk file=\"D:\\Arch\\ext4.vhdx\"compact vdisk\n关于文件路径\ndiskpart 工具选择磁盘的时候，需要绝对路径。\n\n\n\n\nhttps://stephenreescarter.net/how-to-shrink-a-wsl2-virtual-disk/ ↩︎\n\n\n\n","categories":["development"],"tags":["操作系统/Windows","软件开发/命令行工具"]},{"title":"POJ1753 优化代码","url":"/2010/07/31/obsidian/7e4077ef-9ab6-4dd1-9f26-9a379afc4256/","content":"经过去除 code 变量加上手写队列，把代码的时间优化了不少，但是看了一下 status，感觉压力很大，一帮的 0ms。。。。\n\ncode 是没用的记录，可以删除，成型代码如下：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int MAX = 500000;struct Node {  int table;  int depth;  int last;} start, queue[MAX];int hash(int table, int op) {  int st;  st = (1 &lt;&lt; op);  if (op % 4 &gt; 0) st |= (1 &lt;&lt; (op - 1));  if (op % 4 &lt; 3) st |= (1 &lt;&lt; (op + 1));  if (op / 4 &gt; 0) st |= (1 &lt;&lt; (op - 4));  if (op / 4 &lt; 3) st |= (1 &lt;&lt; (op + 4));  return (table ^ st);}int bfs() {  Node node, next;  int tail = 0, head = 0;  node.table = start.table;  node.depth = 0;  node.last = -1;  if (node.table == 0 || node.table == ((1 &lt;&lt; 16) - 1)) return 0;  queue[head++] = node;  while (head != tail) {    node = queue[tail];    tail = (tail + 1) % MAX;    for (int i = node.last + 1; i &lt; 16; i++) {      next.table = hash(node.table, i);      next.depth = node.depth + 1;      next.last = i;      if (next.table == 0 || next.table == ((1 &lt;&lt; 16) - 1)) return next.depth;      queue[head] = next;      head = (head + 1) % MAX;    }  }  return -1;}int main() {  char str[10];  start.table = 0;  for (int i = 0; i &lt; 4; i++) {    gets(str);    for (int j = 0; j &lt; 4; j++) {      if (str[j] == 'b') {        start.table |= (1 &lt;&lt; (i * 4 + j));      }    }  }  int ret = bfs();  if (ret == -1)    printf(\"Impossible\\n\");  else    printf(\"%d\\n\", ret);  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"使用 Obsidian 管理我的博客","url":"/2023/11/05/obsidian/7b89a1b1-b4f6-442a-8002-32e046f525e0/","content":"我大概在今年年初的时候，把所有以前分散在各个平台上的文章、知识库个人帖子，以及老的通过 Emacs Org Mode 管理的内容，全部迁移到了 Obsidian 下，一直有在想，有没有比较好的办法把博客上的文章也放到一起做汇总，这样也有写新文章的动力。后来经过了一段时间的尝试，算是做了一个最简单的无附件（图片之类的）的文章的管理方案，目前这个博客上的所有文章都是从我的 Obsidian 库中直接提取出来发布的。本文章抛砖引玉，介绍一个使用 Obsidian 进行博文编写、管理的解决方案。\n额外说明\n目前没有实现图片、附件的解析、拆解和同步功能，但是理论上这块的内容是可以通过 tokenizer 来实现的，可以在后面考虑进来，这个文章只是做了抛砖引玉，倒是可以提一提解决方案，但是不会考虑说明具体的实现。\n\n\n 主要流程\n目前我的文章是存放在一个 Obsidian 库中，我们这里假设它是 obsidian-vault 目录，我们需要编写一个程序（或者脚本），遍历所有库中的文章，根据 Markdown 的元数据来过滤出需要发布的文章，然后收集到 Hexo 的仓库中，这里我们认为收集到的目的地是 hexo-blog/source/_posts/obsidian。\n元数据的定义如下：\nid: 7b89a1b1-b4f6-442a-8002-32e046f525e0date: 2023-11-05 13:56categories: development\n这里各个字段的含义如下：\n\n\n\n键值\n类型\n含义\n\n\n\n\nid\n字符串\n文章的 ID\n\n\ndate\n日期\n文章创建的时间，在博客中只会显示它的日期\n\n\ncategories\n类别\n文章的类别\n\n\n\n而在 Obsidian 中，我们可能有自己额外的元数据，并且有发布的标记，我们需要对这些元数据进行过滤、映射，来满足我们发布的要求。为了方便处理，我在 Obsidian 的文件头，添加了一个叫 published 的选项，当它是 true 的时候，它将被脚本处理，过滤完发布到对应的仓库中。\n总结一下，整个流水线的流程是：通过 Obsidian 编写文章，打上 published 标记，然后通过脚本进行处理，映射、过滤以及清洗元数据，并处理文章的标签，最后把处理好的文件存放在 hexo-blog 对应的目标文件夹中。\n 处理脚本的实现\n我选择 rust 作为脚本的实现语言，这个其实无所谓，甚至其它的语言有更好的 Markdown 文件元数据处理框架，我没有去折腾了，这里怎么简单怎么来。\n提示\n如果说要考虑未来图片及相关附件的复制，以及解析，选择一个成熟的 Markdown 解析器是非常重要的。\n\n Markdown 文件结构拆分\n首先我们要做的事是把 Markdown 文件的元数据和内容拆分区分出来，在处理 Markdown 文件过程中，我们使用一个 Phase 枚举，来表示我们处理到了哪个阶段：\n#[derive(PartialEq)]enum Phase {    START,    METADATA,    CONTENT,}\n为了简化问题，我们认为 Markdown 文件一定是由元数据、正文的形式组成，并且元数据一定是由 --- 分隔。如果文件的第一行不是 ---，我们认为它没有元数据。假设我们已经读取到了文件的原始内容，我们记它为 raw，以下的代码片断对整个文件进行了解析：\nlet mut phase = Phase::START;let mut metadata = String::new();let mut content = String::new();for line in raw.lines() {  if phase == Phase::CONTENT {    content += &amp;format!(\"{line}\\n\");    continue;  } else if line.trim() == \"---\" {    match phase {      Phase::START =&gt; phase = Phase::METADATA,      Phase::METADATA =&gt; {        phase = Phase::CONTENT;        migrate_metadata(metadata)      }      _ =&gt; {}    }    continue;  } else if phase == Phase::START {    return None;  }  metadata += &amp;format!(\"{line}\\n\");}\n在上面的代码片段中的第 21 行，如果文章一开始不是 ---，说明它没有元数据，而没有元数据的文章我们认为是不会用来发布的（没有 published 元数据），故这里我们直接返回，直接跳过这个文件即可。\n Markdown 文件元数据的处理\n接起来我们需要对元数据处理，包括键值的映射、以及特定的一些元数据值的获取:\nlet metadata_mappings = HashMap::from([    (\"id\", \"id\"),    (\"date_created\", \"date\"),    (\"categories\", \"categories\"),]);let mut metadata = String::new();let mut current: Option&lt;String&gt; = None;let metadata_key_prefix = Regex::new(r\"^(\\w+):(.*)\").unwrap();let tags_line = Regex::new(r\"^[]*-[ ]*(.*)\").unwrap();let mut published = false;let mut id: Option&lt;String&gt; = None;let mut last_key = \"\";for line in self.metadata.lines() {  if let Some(caps) = metadata_key_prefix.captures(line) {    if let Some(current) = &amp;current {      metadata += current;    }    let (key, value) = (caps.get(1).unwrap().as_str(), caps.get(2).unwrap().as_str());    last_key = key;    if key == \"published\" {      if value.trim() == \"true\" {        published = true      } else {        return Err(exit_codes::OK);      }    } else if key == \"id\" {      id = Some(value.trim().to_string());    }    if let Some(key) = metadata_mappings.get(&amp;key) {      current = Some(format!(\"{key}:{value}\\n\"))    } else {      current = None;    }  } else if let Some(value) = current {    current = Some(value + &amp;format!(\"{line}\\n\"));  } else if last_key == \"tags\" {    if let Some(caps) = tags_line.captures(line) {      let tag = caps.get(1).unwrap().as_str();      self.tags.push(tag.to_string())    }  }}self.metadata = format!(\"title: \\\"{title}\\\"\\n{metadata}\");if published &amp;&amp; id != \"\" {  match id {    Some(id) =&gt; Ok(id),    None =&gt; Err(ID_ABSENT_AND_SKIP),  }} else {  Err(NOT_PUBLISHED_AND_SKIP)}\n该代码片段中，我们处理了三个特殊的元数据，一个是 id，表示文章的 ID，如果它的值不存在，我们认为它不应该被发布；另外一个元数据是 tags，由于 Obsidian 我使用了 Obsidian Prettifier 插件，它会直接把 tags 强制转换成数组类型，所以这里我直接认为 tags 一定是空定义一行，然后后面若干行的 - 打头的数组的形式；最后，需要单独找出来 published 的值，如果是 false 或者不存在，表示不发布，退出即可。\n注意\n这里的处理逻辑，不同的人习惯不一样，而且和 Obsidian 的文章的元数据关联性极大，需要按自己的习惯进行处理。比如说，如果你的 tags 可以是单个（一行）或者多个的情况，那得自己特殊处理。另外由于 rust 没有比较好的 Makrdown 文件的库，为了简化需求，这里我直接用正则强行搞了，没有考虑扩展性。\n\n 内容标签处理\n由于个人的习惯，我会在文章的开关标记这个文章的标签，而不一定会放在元数据中，故我做了一下内容这边的处理，比如说我的文章长这个样子：\n---metadata: key---#blog #obsidian内容正文\n这里，我直接把文章开头的标签抠出来，放到元数据的标签中进行合并（注意，老的文章有可能已经有一些 tags 了，所以这里是做合并），然后把它们从正文中去掉，当遇到不是空行也不是标签定义行的时候，就不做任何处理。\n此外，我们需要把 Obsidian Callouts[1] 转义成 Bootstrap Callouts，这里也只是简单做了处理。具体的对比如下：\nObsidianHexo&gt; [!tag-kind|indent] 提示&gt;&gt; 内容{% note tag-kind %}&lt;p style=\"text-decoration: underline;\"&gt; 提示 &lt;/p&gt;内容{% endnote %}\n大概的实现片断如下：\nlet mut content = String::new();let mut beginning = true;let mut in_note_block = false;let tags_line = Regex::new(\"^[]*#([^ ]+)(.*)\").unwrap();let note = Regex::new(  r\"^&gt;[]*\\[(!(default|primary|success|info|warning|danger))(\\|\\w+)?][ ]*(\\w+)\",).unwrap();let quote = Regex::new(r\"^&gt;[ ]*(.*)\").unwrap();for line in self.content.lines() {  if beginning &amp;&amp; line.trim().starts_with(\"#\") {    let mut line = line;    let mut ok = true;    while ok {      ok = false;      if let Some(caps) = tags_line.captures(line) {        if let Some(tag) = caps.get(1) {          self.tags.push(tag.as_str().to_string());          line = caps.get(2).unwrap().as_str();          ok = true        }      }    }    continue;  } else if line.trim() != \"\" {    beginning = false;  }  if !in_note_block {    if let Some(caps) = note.captures(line) {      let (tag, title) =        (caps.get(2).unwrap().as_str(), caps.get(4).unwrap().as_str());      in_note_block = true;      content += &amp;format!(\"{{% note {tag} %}}\\n&lt;p style=\\\"text-decoration: underline;\\\"&gt;{title}&lt;/p&gt;\\n\")    } else {      content += &amp;format!(\"{line}\\n\");    }    continue;  }  if let Some(caps) = quote.captures(line) {    let line = caps.get(1).unwrap().as_str();    content += &amp;format!(\"{line}\\n\");  } else {    in_note_block = false;    content += &amp;format!(\"{{% endnote %}}\\n\");    content += &amp;format!(\"{line}\\n\");  }}if in_note_block {  content += &amp;format!(\"{{% endnote %}}\\n\");}self.content = content;\n 自动化\n如果有必要，可以考虑用 CI/CD 来进行部署，不过由于我的博客是直接用 hexo-deployer-git 的，故我的部署和发布脚本是放在一个叫 deploy.zsh 的脚本中，这个脚本第一步做同步的工作，第二步进行 hexo deploy。\n\n\n\nhttps://help.obsidian.md/Editing+and+formatting/Callouts ↩︎\n\n\n\n","categories":["development"],"tags":["blog","obsidian"]},{"title":"POJ1459 多源多汇网络流经典模型","url":"/2010/11/26/obsidian/8272d078-9bc7-4945-91dd-0155a1e08aa9/","content":"这题是算法导论上的经典模型，将发电站看成源，用户看成汇，这样就形成了多源多汇网络流模型，直接加一个总的源汇即可。\n源到发电站的容量为发电站的容量，用户到汇 的容量为用户容量，直接跑最大流即可。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 120;const int oo = 0x3f3f3f3f;struct Edge {  int num, ne, cap;} e[2 * MAX * MAX];int pre[MAX], pree[MAX], low[MAX], gap[MAX], cur[MAX], p[MAX];int dist[MAX];int n, st, ed, K;int get() {  int ret = 0;  bool flag = false;  char ch;  while ((ch = getchar()) &lt; '0' || ch &gt; '9')    if (ch == '-') break;  if (ch == '-')    flag = true;  else    ret = ch - '0';  while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') ret = ret * 10 + ch - '0';  return flag ? -ret : ret;}void add(const int&amp; u, const int&amp; v, const int&amp; cap) {  e[K].num = v;  e[K].cap = cap;  e[K].ne = p[u];  p[u] = K++;  e[K].num = u;  e[K].cap = 0;  e[K].ne = p[v];  p[v] = K++;}int sap() {  int ret = 0;  bool done;  memset(dist, 0, sizeof(dist));  memset(gap, 0, sizeof(gap));  memset(low, 0, sizeof(low));  for (int i = 0; i &lt; n; i++) cur[i] = p[i];  low[st] = oo;  int u = st;  while (dist[u] &lt; n) {    done = true;    for (int i = cur[u]; ~i; i = e[i].ne) {      int v = e[i].num;      cur[u] = i;      if (e[i].cap &amp;&amp; dist[u] == dist[v] + 1) {        pre[v] = u;        pree[v] = i;        low[v] = min(low[u], e[i].cap);        u = v;        if (u == ed) {          do {            e[pree[u]].cap -= low[ed];            e[pree[u] ^ 1].cap += low[ed];            u = pre[u];          } while (u != st);          ret += low[ed];        }        done = false;        break;      }    }    if (done) {      gap[dist[u]]--;      if (!gap[dist[u]]) return ret;      dist[u] = n;      cur[u] = p[u];      for (int i = p[u]; ~i; i = e[i].ne) {        if (e[i].cap) dist[u] = min(dist[u], dist[e[i].num] + 1);      }      gap[dist[u]]++;      if (u != st) u = pre[u];    }  }  return ret;}int main() {  int nn, np, nc, m;  char ch;  while (~scanf(\"%d%d%d%d\", &amp;nn, &amp;np, &amp;nc, &amp;m)) {    n = nn + 2;    st = nn;    ed = nn + 1;    for (int i = 0; i &lt; n; i++) p[i] = -1;    K = 0;    while (m--) {      while ((ch = getchar()) != '(')        ;      int u = get();      int v = get();      int w = get();      add(u, v, w);    }    while (np--) {      int u = get();      int w = get();      add(st, u, w);    }    while (nc--) {      int u = get();      int w = get();      add(u, ed, w);    }    printf(\"%d\\n\", sap());  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"POJ2159 的二分匹配做法","url":"/2010/08/05/obsidian/830eb80b-fa1d-407a-813e-4199ca734719/","content":"虽然这题用排序可以轻松搞定，但是我们可以考虑用二分匹配，在 O(n2)O(n^2)O(n2) 的时间内得到答案。\n将两个字符串中每个字母的数目进行统计，然后得到一个有 26 对结点的二分图，对二分图跑一次最大匹配，当且仅当最大匹配数等于 262626 的时候，输出 YES，否则输出 NO。\n二分版本的代码，运用匈牙利算法实现：\n\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 27;int n, m;int pre[MAX];bool visit[MAX];bool conn[MAX][MAX];void init() {  memset(conn, 0, sizeof(conn));  memset(pre, -1, sizeof(pre));}bool dfs(int a) {  for (int i = 0; i &lt; n; i++) {    if (conn[a][i] == 1 &amp;&amp; !visit[i]) {      visit[i] = true;      if (pre[i] == -1 || dfs(pre[i])) {        pre[i] = a;        return true;      }    }  }  return false;}int BinaryMatch() {  int ans = 0;  for (int i = 0; i &lt; n; i++) {    memset(visit, 0, sizeof(visit));    if (dfs(i)) ans++;  }  return ans;}int main() {  char str[105];  int a[26] = {0}, b[26] = {0}, len;  init();  gets(str);  len = strlen(str);  for (int i = 0; i &lt; len; i++) a[str[i] - 'A']++;  gets(str);  len = strlen(str);  for (int i = 0; i &lt; len; i++) b[str[i] - 'A']++;  for (int i = 0; i &lt; 26; i++)    for (int j = 0; j &lt;= 26; j++)      if (a[i] == b[j])        conn[i][j] = true;      else        conn[i][j] = false;  n = 26;  if (BinaryMatch() == n)    printf(\"YES\\n\");  else    printf(\"NO\\n\");  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"Customize your own projectile project in Emacs","url":"/2024/05/14/obsidian/841f1444-988c-4df9-b863-677cd8822d72/","content":"When using projectile to manage a project folder, we can customize the project’s properties to help us more easily to build / test / run the project.\n\nAssuming we have a folder which contains all files in the project, and we want to quickly build / test the project, we can add a .projectile file at the root of the project folder tree, then add another .dir-locals.el file describing the customized command.\n((nil . ((projectile-project-name . \"Project name described in the status bar\")         ;; The empty string indicates current folder is the root of the proejct.\t (projectile-project-compilation-dir . \"\")\t (projectile-enable-caching . t)\t ;; Note that the prepare.sh is located at the root of the project.\t (projectile-project-compilation-cmd . \"./prepare.sh &amp;&amp; make build\")\t (projectile-project-test-cmd . \"./preare_test.sh &amp;&amp; make test\")\t (projectile-project-run-cmd . \"./start_app_engine &amp;&amp; make deploy\")\t ;; Bind the .h file from default C header to C++ header.\t (eval . (add-to-list 'auto-mode-alist'(\"\\\\.h\\\\'\" . c++-mode))))))\n","categories":["development"],"tags":["软件开发/编辑器"]},{"title":"POJ 3481 HDU1908 Double Queue SBT","url":"/2010/11/12/obsidian/8425174a-ab27-4e76-8050-363e1f8e6121/","content":"简单的平衡二叉树题，支持三个操作，插入、查询最值、删除，在结构体中用到了运算符重载，为了编码方便，如果不用重载，应该会跑得更快。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 1100000;struct In {  int id;  int pro;  In() {}  In(int id, int pro) : id(id), pro(pro) {}  bool operator==(const In&amp; in) const { return id == in.id &amp;&amp; pro == in.pro; }  bool operator&lt;(const In&amp; in) const {    if (pro != in.pro) {      return pro &lt; in.pro;    } else {      return id &lt; in.id;    }  }  bool operator&lt;=(const In&amp; in) const { return *this &lt; in || *this == in; }  bool operator&gt;(const In&amp; in) const { return !(*this &lt;= in); }  bool operator&gt;=(const In&amp; in) const { return !(*this &lt; in); }};struct Node {  int left, right, size, cnt;  In key;  void init() {    left = right = 0;    size = 1;  }} node[MAX];int tol;int root;void init() { tol = root = 0; }void Lt(int&amp; t) {  int k = node[t].right;  node[t].right = node[k].left;  node[k].left = t;  node[k].size = node[t].size;  node[t].size = node[node[t].left].size + node[node[t].right].size + 1;  t = k;  return;}void Rt(int&amp; t) {  int k = node[t].left;  node[t].left = node[k].right;  node[k].right = t;  node[k].size = node[t].size;  node[t].size = node[node[t].left].size + node[node[t].right].size + 1;  t = k;  return;}void keep(int&amp; t, bool flag) {  if (flag == 0) {    if (node[node[node[t].left].left].size &gt; node[node[t].right].size)      Rt(t);    else if (node[node[node[t].left].right].size &gt; node[node[t].right].size) {      Lt(node[t].left);      Rt(t);    } else      return;  } else {    if (node[node[node[t].right].right].size &gt; node[node[t].left].size)      Lt(t);    else if (node[node[node[t].right].left].size &gt; node[node[t].left].size) {      Rt(node[t].right);      Lt(t);    } else      return;  }  keep(node[t].left, 0);  keep(node[t].right, 1);  keep(t, 0);  keep(t, 1);  return;}void insert(int&amp; t, const In&amp; v) {  if (t == 0) {    t = ++tol;    node[t].init();    node[t].key = v;  } else {    node[t].size++;    if (v &lt; node[t].key)      insert(node[t].left, v);    else      insert(node[t].right, v);    keep(t, v &gt;= node[t].key);  }  return;}int del(int&amp; t, const In&amp; v) {  if (!t) return 0;  node[t].size--;  if (v == node[t].key || v &lt; node[t].key &amp;&amp; !node[t].left ||      v &gt; node[t].key &amp;&amp; !node[t].right) {    if (node[t].left &amp;&amp; node[t].right) {      int p = del(node[t].left, In(v.id + 1, v.pro));      node[t].key = node[p].key;      return p;    } else {      int p = t;      t = node[t].left + node[t].right;      return p;    }  } else    return del(v &lt; node[t].key ? node[t].left : node[t].right, v);}In select(int t, int k) {  if (k &lt;= node[node[t].left].size)    return select(node[t].left, k);  else if (k &gt; node[node[t].left].size + 1)    return select(node[t].right, k - node[node[t].left].size - 1);  return node[t].key;}int getmax(int t) {  while (node[t].right) t = node[t].right;  return t;}int getmin(int t) {  while (node[t].left) t = node[t].left;  return t;}int main() {  int id, pro;  init();  while (scanf(\"%d\", &amp;id), id) {    if (id == 1) {      scanf(\"%d%d\", &amp;id, &amp;pro);      insert(root, In(id, pro));    } else if (id == 2) {      if (tol == 0) {        puts(\"0\");      } else {        id = getmax(root);        printf(\"%d\\n\", node[id].key.id);        del(root, node[id].key);      }    } else {      if (tol == 0) {        puts(\"0\");      } else {        id = getmin(root);        printf(\"%d\\n\", node[id].key.id);        del(root, node[id].key);      }    }  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"splay 经典题目举例","url":"/2011/07/25/obsidian/86a18ca1-9f5b-419b-8ad3-4d1fdeec6802/","content":"数据结构专攻告一段落吧，把这段时间和以前做过的 splay 的题目拿出来晒晒，每题都写了一下简单的解题报告，每道题的做法最好要多花时间琢磨琢磨，splay 的题目主要就是中间过程的处理上比较麻烦。为了方便，我对区间操作都是将 l−1l-1l−1 结点 splay 到根，r+1r+1r+1 结点 splay 到根的右子树，定义根的右子树的左子树为关键结点。\n常见的 splay 问题的处理\n首先是标记，下放标记和上传标记最好分开写，否则的话非常容易出问题，我们下放标记记录的是孩子结点的信息，所以我们如果要对一个结点打标记，我们要先处理好这个结点，比如说这个结点权值加上一个值，左右子树交换等等。\n其次是区间操作上的方便性问题，对于平常的区间操作，如果每次询问都是删除 [l,r][l, r][l,r] 区间，这样我们可以在序列左右两端加上两个哨兵，这样处理起来方便，但是有的题目这样反而不好处理，比如翻转下标小于 x 的所有数，这样左边界不能成为翻转的对象。\n最后是比较重要的一点，就是如果减少时间的开销，一般我们对 splay 做 insert 操作的时候，我们要将加入到结点，或者子树的根结点 splay 到根，这样我们可以防止 splay 出现退化的情况，虽然这样还是会退化，但是均摊复杂度是可以接受的。\n\n HDU3487 &nbsp;Play with Chain\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3487\n大致题意\n给你一个序列，有两个操作，一个是把一段区间翻转，另外一个是把一段区间截下来放到另外一个位置，问你最后的序列长什么样。\n\n对于 FLIP 操作直接将 l−1l-1l−1 和 r+1r+1r+1 位置的结点伸展，然后在关键结点出将标记处理了。\n对于 CUT 操作，首先我们将关键子树分离，记得分离之前要 pushdown 关键根，然后将关键子树接到新的子树上去，注意这时候我们要记得将关键子树的父亲结点设为关键根，然后对关键根进行 update 操作。\n NOI2005 维护数列\n这题巴蜀的 OJ 挂掉了，现在没办法交，不过题目还是很有意思的，给你一个数列问你一系列的关于数列的问题，除了区间翻转以外的问题都可以转化为线段树来做，我们可以先将线段树想清楚，然后转化成 splay 的模型就可以了。\n利用 splay 来维护整个序列，最大子字段和注意一下需要处理的是必须至少选一个，所以我们加入的哨兵还有空结点的所有特征值为负无穷大，例外的是空结点的 sizesizesize 域以及和值应为 000。\n至于平衡树的处理，标记都是下放，特征值一定都是向上传递的，写的时候不要写错，此外要注意这题懒操作要写好，否则会 TLE。\n当时 WA 了一天，主要错的地方在于没有处理好哨兵的特征值，此外一定要注意我们可以把哨兵统一到结点中，只要其特征值取的好。\n本题注意全部数字都是负数的情况。\n POJ3580 &nbsp;Super Memo\nhttp://poj.org/problem?id=3580\n这题也是比较经典的入门题了，模型很裸，但是写起来要纠结一点儿。\n这题和常规的 splay 题类似，唯一的区别就是那个区间旋转，我们可以找到分界点，然后左半边右半边进行一次 reverse，然后整个区间再进行一次 reverse。\n NOI2003 文本编辑器\n很多 OI 选手津津乐道的题目，这题可以算是相当恶心的题目了，给你一个文本编辑器的模型，叫你模拟全部的操作，直接用 splay 来维护，然后加一个指针，表示现在光标的位置。\n标准的 splay 题，注意这题 delete 和 get 可能会越界，要判断，旋根的时候右边界必须是 size−1size-1size−1。\n此外数组要开足够大，开 10242×21024^2 \\times 210242×2 差不多。注意中间的处理不要写的太复杂，否则写挂了也不好处理。\n HDU1890 Robotic Sort\nhttp://acm.hdu.edu.cn/showproblem.php?pid=1890\n大致题意\n这题是给你一些不同的数，每次选择最小的翻转回它应该在的位置，叫你模拟这个过程。这题最后要保证相同数字的相对位置不变。\n\n经典 splay 问题，我们可以考虑记录每一个高度对应的结点的指针，用一个数组存起来，然后每次将其旋转到根，根的左子树加上 iii 加上 111 当做答案，然后翻转左子树，删除根结点。\n注意为了操作时产生不必要的麻烦，建议不加哨兵，删除根的时候特判一下，如果有左右孩子，那么就去找前驱后继，删除，否则直接 root 替换即可。\n FZU1978 Repair the brackets\nhttp://acm.fzu.edu.cn/problem.php?pid=1978\n给你一个括号序列，动态更新区间，包括区间取反，区间翻转，区间赋值，查询使得一个区间变成规则括号串的最小花费，对于一个位置把括号反向，需要 111 的花费。\n利用 splay 来维护全部的操作，定义左括号是 111 右括号是 −1-1−1，对于一个 Query，我们计算区间从左到右的和值最小值，记录 aaa 为这个最小值的绝对值，bbb 为这个区间的和减去这个最小值，那么答案就是 ⌈a2⌉+⌈b2⌉\\lceil\\frac{a}{2}\\rceil+\\lceil\\frac{b}{2}\\rceil⌈2a​⌉+⌈2b​⌉，注意都是上取整。\n由于需要进行区间的翻转，所以要记录右边的值，此外由于有区间的取反，所以要记录最大值。\n最后需要注意的是最小值不超过 000，最大值不小于 000。\n HDU2475 Box\nhttp://acm.hdu.edu.cn/showproblem.php?pid=2475\n给你一些盒子的相对关系，动态的对盒子进行合并、拆分，问你某个盒子最外层的盒子是什么。这题是经典的括号序列问题，如果不懂的，可以去百度一下，应该有相关的资料～\n利用 splay 来维护括号序列，对于一个 DFS 序列，我们入栈记录一次，出栈记录一次，我们用 x 表示 x 这个结点入栈的点，用 x+nx+nx+n 表示 xxx 出栈的点，那么对于这个问题可以轻松转化过来。\n对于 MOVE 操作，如果可以移动，我们进行 cut 操作和 add 操作。\n对于 cut 操作，我们将 xxx 和 x+nx+nx+n 分别旋根，这样我们可以得到一个 xxx 和 x+nx+nx+n，x+nx+nx+n 是根，xxx 是其左子树的某一个结点，这样 xxx 的左子树和 x+nx+nx+n 的右子树是无效的，我们剪掉它们，并且将 x+nx+nx+n 的右子树接到 x 的左子树最后，接着把 x+nx+nx+n 旋根，保证平衡性。\n对于 add 操作，我们将新的父亲结点旋到根，x+nx+nx+n 旋到根，然后进行连接，注意新的父亲结点的右子树，需要接到 x+nx+nx+n 的右子树上去。\n对于初始化，我们可以确定每一个结点的父亲结点，然后逐个进行 add 就是。\n最后的问题就是如何判断 yyy 是不是 xxx 的子树，这个的判断方法是先对 xxx 执行 cut 操作，注意这时候两个子树不要合并，然后再去查询 yyy 的根结点，如果 yyy 的根结点是 xxx，说明 yyy 是 xxx 的子树，最后记得复原。复原的时候要把 xxx 和 x+nx+nx+n 旋根，两个子树旋根，然后拼接。\n查询一个结点的根结点，其实就是 DFS 序列的起点，也就是所在树的最小元素，将 xxx 旋根，找左子树的最小值即可。\n HDU3726 Graph and Queries\nhttp://acm.hdu.edu.cn/showproblem.php?pid=3726\n给你一个图，有一些无向边，现在有三种操作，一个是改变点权，一个是删掉一条边，一个是查询结点 x 所在连通块第 kkk 大的点权。\n我们离线从后向前处理，对于每一个删边操作相当于是一个合并操作，然后对于每一个点来说，我们拉一个邻接表表示修改的权值。那么，对于每一个修改操作我们就将节点 splay 到根，然后删掉根结点，修改根结点，然后把结点加入树中。\n","categories":["ICPC总结"],"tags":["CSDN","ICPC"]},{"title":"HDU3656 Fire Station Dancing Links","url":"/2010/11/08/obsidian/87c6d4a8-2da9-4e26-a5da-f15e9b8bf6a7/","content":"这题 Dancing Links 写的好纠结，二分写挂了一次。\n这题的思路是预处理出所有点对的距离，然后进行对半径二分，跑重复覆盖即可。\n注意二分的时候不能对距离二分，那样会超时，我们考虑极限情况，也就是消防队恰好可以到达某一房子，也就是距离相等时的情况，这样，我们就维护一个 que 数组表示可以选到的距离，对此进行二分。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int oo = 0x3f3f3f3f;const int MAX = 120;const int head = 0;int up[MAX * MAX], down[MAX * MAX], left[MAX * MAX], right[MAX * MAX];int cnt[MAX], h[MAX], col[MAX * MAX];int K, ans;int nc;void remove(const int&amp; c) {  for (int i = down[c]; i != c; i = down[i]) {    left[right[i]] = left[i];    right[left[i]] = right[i];    cnt[col[i]]--;  }}void resume(const int&amp; c) {  for (int i = up[c]; i != c; i = up[i]) {    left[right[i]] = i;    right[left[i]] = i;    cnt[col[i]]++;  }}int evalute() {  bool vis[MAX] = {0};  int ret = 0;  for (int i = right[head]; i != head; i = right[i]) {    if (!vis[i]) {      ret++;      vis[i] = true;      for (int j = down[i]; j != i; j = down[j]) {        for (int k = right[j]; k != j; k = right[k]) {          vis[col[k]] = true;        }      }    }  }  return ret;}bool dfs(const int&amp; k) {  if (k + evalute() &gt; ans) {    return false;  }  if (right[head] == head) {    return true;  }  int s = oo, c = 0;  for (int i = right[head]; i != head; i = right[i]) {    if (cnt[i] &lt; s) {      s = cnt[i];      c = i;      if (cnt[i] &lt;= 1) {        break;      }    }  }  for (int i = down[c]; i != c; i = down[i]) {    remove(i);    for (int j = right[i]; j != i; j = right[j]) {      remove(j);    }    if (dfs(k + 1)) {      return true;    }    for (int j = left[i]; j != i; j = left[j]) {      resume(j);    }    resume(i);  }  return false;}void init() {  for (int i = 0; i &lt;= nc; i++) {    h[i] = -1;    left[i] = i - 1;    right[i] = i + 1;    up[i] = down[i] = i;    cnt[i] = 0;    col[i] = i;  }  left[head] = nc;  right[nc] = head;  K = nc;  for (int i = 1; i &lt;= nc; i++) {    h[i] = -1;  }}void add(const int&amp; r, const int&amp; c) {  K++;  col[K] = c;  up[K] = c;  down[K] = down[c];  if (h[r] == -1) {    h[r] = right[K] = K;  }  left[K] = h[r];  right[K] = right[h[r]];  left[right[K]] = K;  right[left[K]] = K;  up[down[K]] = K;  down[up[K]] = K;}struct Node {  int x, y;} city[MAX];int dis[MAX][MAX];int que[MAX * MAX], top;int sqr(int x) { return x * x; }int operator*(const Node&amp; a, const Node&amp; b) {  return sqr(a.x - b.x) + sqr(a.y - b.y);}void build(const int&amp; mid) {  init();  for (int i = 1; i &lt;= nc; i++) {    for (int j = 1; j &lt;= nc; j++) {      if (dis[i][j] &lt;= mid) {        add(i, j);      }    }  }}void run() {  int l = 0, r = top;  int mid, ans;  while (l &lt;= r) {    mid = (l + r) / 2;    build(que[mid]);    if (dfs(0)) {      ans = que[mid];      r = mid - 1;    } else {      l = mid + 1;    }  }  printf(\"%.6f\\n\", sqrt((double)ans));}int main() {  int T;  scanf(\"%d\", &amp;T);  while (T--) {    scanf(\"%d%d\", &amp;nc, &amp;ans);    for (int i = 1; i &lt;= nc; i++) {      scanf(\"%d%d\", &amp;city[i].x, &amp;city[i].y);    }    top = 0;    // here we deal with the distance between city and city.    for (int i = 1; i &lt;= nc; i++) {      for (int j = 1; j &lt;= nc; j++) {        que[top++] = dis[i][j] = city[i] * city[j];      }    }    int tmp = top;    sort(que, que + top);    top = 1;    for (int i = 1; i &lt; tmp; i++) {      if (que[i] != que[i - 1]) {        que[top++] = que[i];      }    }    run();  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"HDU1671 字典树","url":"/2010/11/06/obsidian/8a84cf38-3803-4706-b893-17312295274e/","content":"这题纠结了好久，之前没有考虑到 flag 标记，如果有如下的数据，之前的想法就错了:\n1200000000\n直接建字典树，注意一下几点：\n\n如果当前的结点是标记了 danger 的，那么就直接返回 false，表示有前缀。\n如果遍历到最后依然没有发现 danger 标记，要考虑这个结点有没有后继，如果有，说明他是某些结点的前缀，这个用 flag 标记。\n\n自己在代码里加了一些注释，以便理解。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cctype&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;deque&gt;#include &lt;functional&gt;#include &lt;iomanip&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;numeric&gt;#include &lt;queue&gt;#include &lt;set&gt;#include &lt;sstream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;using namespace std;const int MAX = 1000000;struct Node {  Node* ne[10];  bool danger, flag;  // if node has next pointer set the flag true} node[MAX], *root;int K;Node* New() {  // get a new pointer which has not be allocate.  Node* ret = &amp;node[K++];  for (int i = 0; i &lt; 10; i++) {    ret-&gt;ne[i] = NULL;  }  ret-&gt;danger = false;  ret-&gt;flag = false;  return ret;}void init() {  K = 0;  root = New();}bool insert(char* s) {  Node* ptr = root;  char* p = s;  int id;  // go along the tree and find whether  // s has a dangerous prefix.  while (*p) {    id = *(p++) - '0';    if (ptr-&gt;danger) {      return false;    }    if (ptr-&gt;ne[id] == NULL) {      ptr-&gt;ne[id] = New();    }    ptr-&gt;flag = true;    // set the flag true because this node has next pointer.    ptr = ptr-&gt;ne[id];  }  ptr-&gt;danger = true;  // notice: if the next pointer is not null  // we say s is a prefix of some words.  if (ptr-&gt;flag) {    return false;  }  return true;}int main() {  int t;  int n;  bool done;  char s[1100];  scanf(\"%d\", &amp;t);  while (t--) {    init();    scanf(\"%d\", &amp;n);    done = true;    for (int i = 0; i &lt; n; i++) {      scanf(\"%s\", s);      if (done) {        done = insert(s);      }    }    if (done) {      puts(\"YES\");    } else {      puts(\"NO\");    }  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"2010 Asia ACM-ICPC Regional Harbin","url":"/2010/10/20/obsidian/8f08d6c0-b7d2-49a2-a162-05d21ddaaa8f/","content":"最近很忙，基本上没时间写解题报告了，还是想写写当时比赛的情况，嗯，这篇文章是写的晚了点。\n来到哈尔滨的时候是报到前一天中午，我们应该是比较早到的队伍了，到了哈尔滨，刚走出去就感受到了什么是寒冷，9 月的哈尔滨，10°C 不到的温度，我直接套上了大衣，中午吃完饭到了招待所，做的第一件事，就把内衣换上了。。。\n热身赛比较悲剧，队友一时头脑发热，BFS 想成堆优化 Dijkstra，没有切圆\n\nA 题是 A+B，秒杀，当时这题交的人很多，导致了评测机卡壳的情况，还好决赛的时候评测机还是很给力的。\nB 题是个 KMP 加组合数学，好吧，当时没看出来，被队友的暴力直接水过。。。\nC 题简单 BFS，经过了这题才发现某孩子不知道边权为 1 的图可以用 BFS 跑最短路，好吧，我失策了，还好后来即使调整了下状态，没出大岔子。\nD 题是多校联合的陈题，给你 N 个点，选择三个点求最小形成的角度，直接枚举点，极角排序扫描即可，复杂度 O(n2×lgn)O(n^2 \\times lgn)O(n2×lgn) 的，当时没时间写了，就放弃了\n热身赛的后半小时，一直在测试 PC2 的性能，得到结论 RE 很困难，PE 判成 WA\n热身赛结束的下午，两个队友和另外一个队的孩子一起去观光了，我没去，没有在比赛前参观的习惯，照例一个人窝房间看了会儿电视，看了下模板\n第二天的比赛总体上来说比较正常，就是开题速度比较慢，50 多分钟了才过第一题，算是非常之慢了。。。\n50 分钟 F 题 1Y\n最短路的题，50 个点的。。好吧，之前被 A 卡了很久，队友看到这题水，就上去拍了，直接水掉。\n54 分钟 B 题 1Y\n贪心，正反排序直接计算即可，当时我还怀疑其正确性，两个队友都说这个思路是对的，就直接拍了\n87 分钟 A 题 1Y\n树形 DP，原来想的 DP 思路不怎么好，最短路想用预处理，后来想想，既然是树，就直接 DFS 带上距离了，还是要赞一下现场赛评测机的速度还是很快的。\n181 分钟 H 题 1Y\n最小费用流，这题是最小费用流的变形，当时队友建图改边权的没想好，卡了将近两个小时，囧死，还好过了这题，士气没有下跌。\n195 分钟 I 题 2Y\n唯一一题 WA 掉的题目，队友写公式的时候漏了一个 H，查了五分钟。。队友推公式的技术还是很强大的，数值积分 5 分钟出结果，这速度。。。\n248 分钟 E 题 1Y\n欧拉三角，DP，这题想到了暴小数据，就是没找到规律，百思不得其解为什么其他队伍都是暴小数据得到的递推式。。。这道题三个人一起各种 YY，总算在封榜后 8 分钟 1Y 了。\n剩下的时间都在看 J 题，当时没学过斜率优化，DP 方程也写错了，还是很可惜。。\n总的来说这次比赛状态不错，觉得能发挥好，不失误，不掉链子就可以了。\n瓦尔兹好给力，最后的绝地反超，还是很雷人的。\n","categories":["杂谈","ICPC总结"],"tags":["CSDN","ICPC","杂谈"]},{"title":"HDU3685 计算几何","url":"/2010/10/31/obsidian/8ff36422-f6af-490c-a849-1296bb71a508/","content":"下午和队友一起做了下杭州赛区的比赛题，结果被虐了，只过了三题，两个队友没一会儿就开始打酱油。。。。实在受不了。\n这道题裸的计算几何，求出多边形的重心，求重凸包，然后直接判断重心到凸包各点的投影是否在线段上，注意这里不用求出投影直接用点积即可，队友看错题 WA 了一次，我看了下图发现 90 的时候是不稳的。。。。到此整题就理论 AC 了，只要代码稳，可以轻松拿下。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int MAX = 50100;const double oo = 1e10;const double eps = 1e-8;struct Point {  double x, y;  double angle, dis;  Point() {}  Point(double x, double y) : x(x), y(y) {}};struct Line {  Point p1, p2;  Line() {}  Line(Point p1, Point p2) : p1(p1), p2(p2) {}};typedef vector&lt;Point&gt; Polygon;typedef vector&lt;Point&gt; Points;bool ZERO(double x) { return fabs(x) &lt; eps; }bool ZERO(Point p) { return ZERO(p.x) &amp;&amp; ZERO(p.y); }bool EQ(double x, double y) { return fabs(x - y) &lt; eps; }bool NEQ(double x, double y) { return fabs(x - y) &gt;= eps; }bool LT(double x, double y) { return NEQ(x, y) &amp;&amp; x &lt; y; }bool GT(double x, double y) { return NEQ(x, y) &amp;&amp; x &gt; y; }bool LEQ(double x, double y) { return EQ(x, y) || x &lt; y; }bool GEQ(double x, double y) { return EQ(x, y) || x &gt; y; }double sqr(double x) { return x * x; }bool operator==(const Point&amp; p1, const Point&amp; p2) {  return EQ(p1.x, p2.x) &amp;&amp; EQ(p1.y, p2.y);}bool operator!=(const Point&amp; p1, const Point&amp; p2) {  return NEQ(p1.x, p2.x) || NEQ(p1.y, p2.y);}bool operator&lt;(const Point&amp; p1, const Point&amp; p2) {  if (NEQ(p1.x, p2.x)) {    return p1.x &lt; p2.x;  } else {    return p1.y &lt; p2.y;  }}Point operator+(const Point&amp; p1, const Point&amp; p2) {  return Point(p1.x + p2.x, p1.y + p2.y);}Point operator-(const Point&amp; p1, const Point&amp; p2) {  return Point(p1.x - p2.x, p1.y - p2.y);}double operator*(const Point&amp; p1, const Point&amp; p2) {  return p1.x * p2.y - p1.y * p2.x;}double operator&amp;(const Point&amp; p1, const Point&amp; p2) {  return p1.x * p2.x + p1.y * p2.y;}double Norm(const Point&amp; p) { return sqrt(sqr(p.x) + sqr(p.y)); }bool comp(const Point&amp; left, const Point&amp; right) {  if (EQ(left.angle, right.angle)) {    return left.dis &lt; right.dis;  } else {    return left.angle &lt; right.angle;  }}void Scan(Points&amp; points, Polygon&amp; result) {  int i, k, n;  Point p;  n = points.size();  result.clear();  if (n &lt; 3) {    result = points;    return;  }  k = 0;  for (i = 1; i &lt; n; i++) {    if (EQ(points[i].y, points[k].y)) {      if (points[i].x &lt;= points[k].x) {        k = i;      }    } else if (points[i].y &lt; points[k].y) {      k = i;    }  }  swap(points[0], points[k]);  for (i = 1; i &lt; n; i++) {    points[i].angle =        atan2(points[i].y - points[0].y, points[i].x - points[0].x);    points[i].dis = Norm(points[i] - points[0]);  }  sort(points.begin() + 1, points.end(), comp);  result.push_back(points[0]);  for (i = 1; i &lt; n; i++) {    if ((i + 1 &lt; n) &amp;&amp; EQ(points[i].angle, points[i + 1].angle)) {      continue;    }    if (result.size() &gt;= 3) {      p = result[result.size() - 2];      while (GEQ((points[i] - p) * (result.back() - p), 0)) {        result.pop_back();        p = result[result.size() - 2];      }    }    result.push_back(points[i]);  }}Point center(const Polygon&amp; poly) {  Point p, p0, p1, p2, p3;  double m, m0;  p1 = poly[0];  p2 = poly[1];  p.x = p.y = m = 0;  for (int i = 2; i &lt; (int)poly.size(); i++) {    p3 = poly[i];    p0.x = (p1.x + p2.x + p3.x) / 3.0;    p0.y = (p1.y + p2.y + p3.y) / 3.0;    m0 = p1.x * p2.y + p2.x * p3.y + p3.x * p1.y - p1.y * p2.x - p2.y * p3.x -         p3.y * p1.x;    if (ZERO(m + m0)) {      m0 += eps;    }    p.x = (m * p.x + m0 * p0.x) / (m + m0);    p.y = (m * p.y + m0 * p0.y) / (m + m0);    m += m0;    p2 = p3;  }  return p;}bool isconter(const Points pts) {  double res = 0.0;  int n = pts.size();  for (int i = 0; i &lt; n; i++) {    res += (pts[i] * pts[(i + 1) % n]);  }  return res &gt; 0;}bool check(const Point&amp; p, const Line&amp; l) {  return LT((l.p1 - p) &amp; (l.p2 - l.p1), 0) &amp; &lt; ((l.p2 - p) &amp; (l.p1 - l.p2), 0);}Points pts, poly;int main() {  int t;  int n, ret;  Point p;  scanf(\"%d\", &amp;t);  while (t--) {    scanf(\"%d\", &amp;n);    ret = 0;    pts.clear();    for (int i = 0; i &lt; n; i++) {      scanf(\"%lf%lf\", &amp;p.x, &amp;p.y);      pts.push_back(p);    }    if (!isconter(pts)) {      reverse(pts.begin(), pts.end());    }    p = center(pts);    Scan(pts, poly);    n = poly.size();    poly.push_back(poly[0]);    for (int i = 0; i &lt; n; i++) {      if (check(p, Line(poly[i], poly[i + 1]))) {        ret++;      }    }    printf(\"%d\\n\", ret);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"HDU3491 网络流最小割模型","url":"/2010/11/27/obsidian/94148602-7a63-45a0-8c95-0adefd530180/","content":"本题是典型的最大流最小割模型，利用最大流等于最小割求解，将每个城市拆成两个点，之间连容量为 www 的边，注意起点和终点连容量为无穷大的边，然后为了方便，起点连源，终点连汇，容量也为无穷大，城市之间连容量为无穷大的双向边，直接跑最大流即可。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int get() {  char ch;  int flag = 0, tmp = 0;  for (ch = getchar(); ch &lt; 48 || ch &gt; 57; ch = getchar())    if (ch == int('-')) break;  if (ch == int('-'))    flag = 1;  else    tmp = int(ch) - 48;  for (ch = getchar(); 48 &lt;= ch &amp;&amp; ch &lt;= 57; ch = getchar())    tmp = tmp * 10 + int(ch) - 48;  return (flag) ? -tmp : tmp;}const int MAX = 210;const int oo = 0x3f3f3f3f;struct Edge {  int ne, num, cap;} e[2 * MAX * MAX];int pre[MAX], pree[MAX], low[MAX], gap[MAX], cur[MAX], dist[MAX];int p[MAX];int n, st, ed, K;void add(const int&amp; u, const int&amp; v, const int&amp; cap) {  e[K].num = v;  e[K].cap = cap;  e[K].ne = p[u];  p[u] = K++;  e[K].num = u;  e[K].cap = 0;  e[K].ne = p[v];  p[v] = K++;}int sap() {  int ret = 0;  bool done;  memset(dist, 0, sizeof(dist));  memset(gap, 0, sizeof(gap));  memset(low, 0, sizeof(low));  for (int i = 0; i &lt; n; i++) cur[i] = p[i];  int u = st;  gap[0] = n;  low[st] = oo;  while (dist[st] &lt; n) {    done = true;    for (int i = cur[u]; ~i; i = e[i].ne) {      int v = e[i].num;      cur[u] = i;      if (e[i].cap &amp;&amp; dist[u] == dist[v] + 1) {        pre[v] = u;        pree[v] = i;        low[v] = min(low[u], e[i].cap);        u = v;        if (u == ed) {          do {            e[pree[u]].cap -= low[ed];            e[pree[u] ^ 1].cap += low[ed];            u = pre[u];          } while (u != st);          ret += low[ed];        }        done = false;        break;      }    }    if (done) {      gap[dist[u]]--;      if (!gap[dist[u]]) return ret;      dist[u] = n;      cur[u] = p[u];      for (int i = p[u]; ~i; i = e[i].ne) {        if (e[i].cap) dist[u] = min(dist[u], dist[e[i].num] + 1);      }      gap[dist[u]]++;      if (u != st) u = pre[u];    }  }  return ret;}int main() {  int T;  int nc, m, u, v, w, s, t;  T = get();  while (T--) {    nc = get();    n = nc * 2 + 2;    st = 0;    ed = n - 1;    for (int i = 0; i &lt; n; i++) p[i] = -1;    K = 0;    m = get();    s = get();    t = get();    add(st, s, oo);    add(t + nc, ed, oo);    for (int i = 1; i &lt;= nc; i++) {      w = get();      if (i != s &amp;&amp; i != t)        add(i, i + nc, w);      else        add(i, i + nc, oo);    }    while (m--) {      u = get();      v = get();      add(u + nc, v, oo);      add(v + nc, u, oo);    }    printf(\"%d\\n\", sap());  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"Serve Static Website in a Server using Git","url":"/2018/06/18/obsidian/9669cce6-923f-4b32-a2b7-72a8c23fdb3e/","content":"Caution\nThis post will give a short instruction to serve your own static website (i.e. a website only contains static assets).\n\n\n Local git repository\nFirst of all, assume you have a local revision of the website, containing basic HTML files, images, JavaScript files, CSS style-sheets, etc, and the website is maintained by a private git repository.\n The post receive hook\nBefore deploying your local revision of the website, you need to add a post-receive hook in the server side to let the website well-served by the server web engine. For example, assume you use nginx to serve the remote website, and it’s served in the server side folder /var/www/my_blog, what you need to do is, checkout the website files into the folder without the git repository information (i.e. .git folder). This can be done by the script:\n#!/bin/shrm -rf /var/www/my_blog/*git --work-tree=/var/www/my_blog --git-dir=/srv/git/my_blog.git checkout -f\n Deploy the website by git push\nFinally, we can change your local revision of the website, then git commit &amp;&amp; git push the changes. After the change pushed successfully, the updated version will be copied to the right folder in the server side (e.g. the /var/www/my_blog/ mentioned below).\n","categories":["development"],"tags":["git","web"]},{"title":"SRM477 DIV2 250","url":"/2010/07/29/obsidian/97123086-071e-4522-a0cb-b2462ba2c941/","content":"简单题，赛后看了一下好多人对数组进行了排序，然后再进行枚举判断，我觉得这样并不是最好的方法，我的方法是开一个 bool 型的数组，has[i] 代表第 iii 天如果冲突，则需要改计划，这样每次对连续的 kkk 天进行枚举，用 O(nk)O(nk)O(nk) 的时间可以直接 check 完，每次检查 kkk 子串后，判断答案，如果比现有答案小，这更新答案，最后返回即可。\n\nint bestSchedule(int N, int K, vector&lt;int&gt; day) {  bool has[1100] = {0};  int sum, ret = 0x3f3f3f3f;  int n = day.size();  for (int i = 0; i &lt; n; i++) {    has[day[i]] = true;  }  for (int i = 1; i &lt;= N - K + 1; i++) {    sum = 0;    for (int j = 0; j &lt; K; j++) {      if (has[i + j]) sum++;    }    if (sum &lt; ret) ret = sum;  }  return ret;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"Codeforces Beta Round #25 D 题 Roads not only in Berland","url":"/2010/08/03/obsidian/973299c1-dd8a-4ee9-8fb9-ef4755822ae1/","content":"这题算是数据结构类型的题目了吧，运用并查集可以快速地解决此类问题，从头往后读取数据，如果读取到的两个点不在同一个集合里，就将他们合并，否则，这条边就是多余的，将多余的边放入栈 ststst 中。处理完边之后，线性扫一遍结点数组，找出所有的根结点放入栈 donedonedone 中。\n之后从 ststst 中取出一元素，将 donedonedone 中的两个元素连起来，然后任意去掉一个元素，留下一个元素，不断进行，直到栈 ststst 空了为止结束循环。\n这个过程主要是运用好栈和并查集。。\n\n第一题和第二题比较简单，就不在此多说，剩下的题目尝试写了下，没有写出。\n我的代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const int MAX = 1100;struct Node {  int x;  int y;} st[MAX];int p[MAX], rank[MAX], top = 0, done[MAX], dtop = 0;int n;void init() {  for (int i = 1; i &lt;= n; i++) {    p[i] = i;    rank[i] = 0;  }}int Find(int x) {  if (p[x] != x) p[x] = Find(p[x]);  return p[x];}void Link(int x, int y) {  if (rank[x] &lt; rank[y]) {    p[x] = y;  } else {    p[y] = x;    if (rank[x] == rank[y]) rank[x]++;  }}void Union(int x, int y) { Link(Find(x), Find(y)); }int main() {  int x, y;  scanf(\"%d\", &amp;n);  init();  for (int i = 0; i &lt; n - 1; i++) {    scanf(\"%d%d\", &amp;x, &amp;y);    if (Find(x) != Find(y)) {      Union(x, y);    } else {      st[top].x = x;      st[top].y = y;      top++;    }  }  for (int i = 1; i &lt;= n; i++) {    if (Find(i) == i) {      done[dtop] = i;      dtop++;    }  }  printf(\"%d\\n\", top);  while (top) {    x = done[dtop - 1];    y = done[dtop - 2];    dtop--;    top--;    printf(\"%d %d %d %d\\n\", st[top].x, st[top].y, x, y);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"HDU1506 线段树做法","url":"/2010/12/02/obsidian/9977e3ca-9adf-40e9-b09d-94bd953d662c/","content":"这道题本来是用 dp 做的，这几天都在练 dp，看了一下，可以用线段树来做，就尝试了一下，虽然不好写，但是还是可以做的 - -。\n这题的关键在于预处理出每个方格可以向左向右分别扩展多少长度，记录 lil_ili​ 和 rir_iri​ 分别表示第 iii 个格子可以向左向右扩展的格子数，那么如果选中了第 iii 个格子，面积就是 (li+ri+1)×hi(l_i + r_i + 1) \\times h_i(li​+ri​+1)×hi​，这样最后线性扫一遍就可以了。\nlil_ili​ 的求法，最直接的方法就是枚举，从该格子向左枚举，找到第一个比它小的格子，这个格子右边的都是可扩展的。\n这样做复杂度是 O(n2)O(n^2)O(n2) 的，对于 10510^5105 的数据量来说是不可以接受的，所以我们需要优化，用线段树维护每个区间的最小值，我们会发现这个格子事实上就是 iii 号格子左边区间的最靠右边的比它小的格子，这样就可以轻松转化为给定区间求区间中最靠右的比 xxx 小的元素的 ididid。\nrir_iri​ 的求法类似，所以要维护两棵线段树。\n最后问题迎刃而解，还要注意的就是需要用到 long long 类型。。。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 100010;struct Seg {  int l, r, id;  int mid() { return (l + r) &gt;&gt; 1; }} lt[MAX &lt;&lt; 2], rt[MAX &lt;&lt; 2];int l[MAX], r[MAX];long long h[MAX];void initl(int k, int l, int r) {  lt[k].l = l;  lt[k].r = r;  lt[k].id = -1;  if (l == r) return;  int mid = lt[k].mid();  initl(k &lt;&lt; 1, l, mid);  initl(k &lt;&lt; 1 | 1, mid + 1, r);}void initr(int k, int l, int r) {  rt[k].l = l;  rt[k].r = r;  rt[k].id = -1;  if (l == r) return;  int mid = rt[k].mid();  initr(k &lt;&lt; 1, l, mid);  initr(k &lt;&lt; 1 | 1, mid + 1, r);}void setl(int k, int idx) {  if (lt[k].l == lt[k].r) {    lt[k].id = idx;    return;  }  int mid = lt[k].mid();  if (idx &lt;= mid)    setl(k &lt;&lt; 1, idx);  else    setl(k &lt;&lt; 1 | 1, idx);  if (lt[k &lt;&lt; 1 | 1].id != -1 &amp;&amp; h[lt[k &lt;&lt; 1 | 1].id] &lt; h[lt[k &lt;&lt; 1].id]) {    lt[k].id = lt[k &lt;&lt; 1 | 1].id;  } else {    lt[k].id = lt[k &lt;&lt; 1].id;  }}void setr(int k, int idx) {  if (rt[k].l == rt[k].r) {    rt[k].id = idx;    return;  }  int mid = rt[k].mid();  if (idx &lt;= mid)    setr(k &lt;&lt; 1, idx);  else    setr(k &lt;&lt; 1 | 1, idx);  if (rt[k &lt;&lt; 1].id != -1 &amp;&amp; h[rt[k &lt;&lt; 1].id] &lt; h[rt[k &lt;&lt; 1 | 1].id]) {    rt[k].id = rt[k &lt;&lt; 1].id;  } else {    rt[k].id = rt[k &lt;&lt; 1 | 1].id;  }}int readl(int k, int a, int b, long long x) {  // if(lt[k].id!=-1)printf(\"Left %d %d %I64d\\n\",lt[k].l,lt[k].r,h[lt[k].id]);  if (h[lt[k].id] &gt; x) return -1;  if (lt[k].l == lt[k].r) return lt[k].id;  int mid = lt[k].mid();  if (b &lt;= mid)    return readl(k &lt;&lt; 1, a, b, x);  else if (a &gt; mid)    return readl(k &lt;&lt; 1 | 1, a, b, x);  else {    if (lt[k &lt;&lt; 1 | 1].id != -1 &amp;&amp; h[lt[k &lt;&lt; 1 | 1].id] &lt;= x) {      return readl(k &lt;&lt; 1 | 1, a, b, x);    } else {      return readl(k &lt;&lt; 1, a, b, x);    }  }}int readr(int k, int a, int b, long long x) {  if (h[lt[k].id] &gt; x) return -1;  if (rt[k].l == rt[k].r) return rt[k].id;  int mid = rt[k].mid();  if (b &lt;= mid)    return readr(k &lt;&lt; 1, a, b, x);  else if (a &gt; mid)    return readr(k &lt;&lt; 1 | 1, a, b, x);  else {    if (rt[k &lt;&lt; 1].id != -1 &amp;&amp; h[rt[k &lt;&lt; 1].id] &lt;= x) {      return readr(k &lt;&lt; 1, a, b, x);    } else {      return readr(k &lt;&lt; 1 | 1, a, b, x);    }  }}int main() {  int n;  while (scanf(\"%d\", &amp;n), n) {    for (int i = 0; i &lt; n; i++) {      scanf(\"%I64d\", &amp;h[i]);    }    initl(1, 0, n - 1);    initr(1, 0, n - 1);    l[0] = 0;    r[n - 1] = 0;    setl(1, 0);    setr(1, n - 1);    for (int i = 1; i &lt; n; i++) {      int id = readl(1, 0, i - 1, h[i]);      setl(1, i);      if (id == -1) {        l[i] = i;      } else {        l[i] = i - id - 1;        if (h[i] == h[id]) l[i] += l[id] + 1;      }    }    for (int i = n - 2; i &gt;= 0; i--) {      int id = readr(1, i + 1, n - 1, h[i]);      setr(1, i);      if (id == -1) {        r[i] = n - 1 - i;      } else {        r[i] = id - i - 1;        if (h[i] == h[id]) r[i] += r[id] + 1;      }    }    // for(int i=0;i&lt;n;i++)printf(\"%d \",l[i]);puts(\"\");    // for(int i=0;i&lt;n;i++)printf(\"%d \",r[i]);puts(\"\");    long long ret = 0;    for (int i = 0; i &lt; n; i++) {      ret = max(ret, (l[i] + r[i] + 1) * h[i]);    }    printf(\"%I64d\\n\", ret);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"Codeforces Beta Round #25 C 题 Roads in Berland","url":"/2010/08/16/obsidian/9a0ab001-19dc-443b-a4e7-f3abab173fac/","content":"这题很囧的 7、8 次 WA 都贡献给了 I64d。。。好吧我承认这个 CF 很强大。。。\n这题的思路如下：\n首先用 Floyd 在 O(n3)O(n^3)O(n3) 的时间复杂度内算出最短路总和 retretret\n更新的边 (x,y)(x, y)(x,y) 长度是 www，那么如果 w≥dist[x][y]w \\geq dist[x][y]w≥dist[x][y] 就不做处理，输出这时的 retretret\n如果 w&lt;dist[x][y]w&lt;dist[x][y]w&lt;dist[x][y]，那么枚举所有的结点，对结点 jjj 和 kkk\ndist[j][k]dist[j][k]dist[j][k] 的值就是 dist[j][k]dist[j][k]dist[j][k]、dist[j][x]+w+dist[y][k]dist[j][x]+w+dist[y][k]dist[j][x]+w+dist[y][k] 和 dist[j][y]+w+dist[x][k]dist[j][y]+w+dist[x][k]dist[j][y]+w+dist[x][k] 中的最小值。\n如果 dist[j][k]dist[j][k]dist[j][k] 的新值比原来的小，那么就更新 retretret 的值。\n为了优化时间，让 jjj 大于 iii，更新了 dist[j][k]dist[j][k]dist[j][k] 后顺便把 dist[k][j]dist[k][j]dist[k][j] 更新了\ndist[k][j]=dist[j][k]dist[k][j]=dist[j][k]\ndist[k][j]=dist[j][k]\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int MAX = 310;int p, q, k, n;LL dist[MAX][MAX];void Floyd() {  for (k = 1; k &lt;= n; k++)    for (p = 1; p &lt;= n; p++)      for (q = 1; q &lt;= n; q++)        if (dist[p][q] - dist[p][k] &gt; dist[k][q])          dist[p][q] = dist[p][k] + dist[k][q];}int main() {  int m;  int x, y, w, tmp;  LL ret = 0;  scanf(\"%d\", &amp;n);  for (int i = 1; i &lt;= n; i++) {    for (int j = 1; j &lt;= n; j++) {      scanf(\"%I64d\", &amp;dist[i][j]);    }  }  Floyd();  for (int i = 1; i &lt;= n; i++)    for (int j = i + 1; j &lt;= n; j++) ret += dist[i][j];  scanf(\"%d\", &amp;m);  for (int i = 0; i &lt; m; i++) {    scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;w);    if (x &gt; y) swap(x, y);    if (w &lt; dist[x][y]) {      for (int j = 1; j &lt;= n; j++) {        for (int k = j + 1; k &lt;= n; k++) {          tmp = dist[j][k];          if (dist[j][x] + w + dist[y][k] &lt; dist[j][k])            dist[j][k] = dist[j][x] + w + dist[y][k];          if (dist[j][y] + w + dist[x][k] &lt; dist[j][k])            dist[j][k] = dist[j][y] + w + dist[x][k];          if (dist[j][k] &lt; tmp) {            ret -= tmp - dist[j][k];            dist[k][j] = dist[j][k];          }        }      }    }    if (i) printf(\" \");    printf(\"%I64d\", ret);  }  printf(\"\\n\");  return 0;}\n总结：关于最短路中改变一条边权值的问题，可以通过边的两个顶点来进行更新\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"ZOJ2898 搜索优化","url":"/2010/10/24/obsidian/9cced43d-0341-4212-802f-982df5d5b7e1/","content":"这题暴力复杂度是 O(2n)O(2^n)O(2n) 的，对于 242424 的复杂度明显不可做，我的方法是进行优化，枚举前 n2\\frac{n}{2}2n​ 个，得到每个陷阱对应的宝物编号，这样对应了一个映射，然后枚举剩下的宝物，找到对应陷阱所对应的前半部分宝物，所有宝物的价值之和就是目前的答案，取最大的即可。\n宝物和陷阱可以用 int 和 long long 压缩，最后放入 map 中。复杂度 O(2n2)O(2^{\\frac{n}{2}})O(22n​)\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; trap[25];int v[25];int n, maxd;map&lt;long long, vector&lt;int&gt; &gt; mp;int ret;void run(int st, long long val) {  int ans, nst;  vector&lt;int&gt; part;  if (mp.find(val) == mp.end()) return;  part = mp[val];  int m = part.size();  for (int k = 0; k &lt; m; k++) {    nst = st | part[k];    ans = 0;    for (int i = 0; i &lt; n; i++) {      if (nst &amp; (1 &lt;&lt; i)) {        ans += v[i];      }    }    if (ans &gt; ret) ret = ans;  }}void dfs(int k, int st, long long val) {  int nst;  long long nval;  if (k == maxd) {    if (mp.find(val) == mp.end()) {      vector&lt;int&gt; v;      v.push_back(st);      mp[val] = v;    } else {      mp[val].push_back(st);    }    return;  }  int m = trap[k].size();  dfs(k + 1, st, val);  nst = st;  nval = 0;  nst |= (1 &lt;&lt; k);  for (int i = 0; i &lt; m; i++) {    nval |= (1ll &lt;&lt; trap[k][i]);  }  dfs(k + 1, nst, val ^ nval);}void dfs2(int k, int st, long long val) {  int nst;  long long nval;  if (k == n) {    run(st, val);    return;  }  int m = trap[k].size();  dfs2(k + 1, st, val);  nst = st;  nval = 0;  nst |= (1 &lt;&lt; k);  for (int i = 0; i &lt; m; i++) {    nval |= (1ll &lt;&lt; trap[k][i]);  }  dfs2(k + 1, nst, val ^ nval);}int main() {  int m, x;  while (~scanf(\"%d\", &amp;n)) {    mp.clear();    ret = 0;    for (int i = 0; i &lt; n; i++) {      trap[i].clear();      scanf(\"%d%d\", &amp;v[i], &amp;m);      for (int j = 0; j &lt; m; j++) {        scanf(\"%d\", &amp;x);        trap[i].push_back(x);      }    }    maxd = n / 2;    dfs(0, 0, 0ll);    dfs2(maxd, 0, 0ll);    printf(\"%d\\n\", ret);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"由 POJ3468 想到的线段树懒操作","url":"/2010/09/30/obsidian/9cda6088-14ac-46db-b864-51008ede07b7/","content":"这题被范围卡了挺久，线段树的懒操作是指访问到的指定区间如果在需要求的区间内部，那么就直接返回，这样，就遇到了一个问题，就是如何记录子区间的状态，用一个 deldeldel 变量来记录子区间的状态，注意，是子区间，这样我们就可以用精简的代码来完成更新区间查找区间的操作。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;typedef long long LL;const int MAX = 210000;struct Seg {  int l, r;  LL val;  LL del;} seg[4 * MAX];int arr[MAX];void init(int k, int l, int r) {  seg[k].l = l;  seg[k].r = r;  seg[k].del = 0;  if (l == r) {    seg[k].val = arr[l];    return;  }  int mid = (l + r) &gt;&gt; 1;  init(k &lt;&lt; 1, l, mid);  init(k &lt;&lt; 1 | 1, mid + 1, r);  seg[k].val = seg[k &lt;&lt; 1].val + seg[k &lt;&lt; 1 | 1].val;}void add(int k, int a, int b, LL v) {  if (seg[k].l &gt; b || seg[k].r &lt; a) return;  if (seg[k].l &gt;= a &amp;&amp; seg[k].r &lt;= b) {    seg[k].val += v * (seg[k].r - seg[k].l + 1);    seg[k].del += v;    return;  }  if (seg[k].del) {    seg[k &lt;&lt; 1].val += seg[k].del * (seg[k &lt;&lt; 1].r - seg[k &lt;&lt; 1].l + 1);    seg[k &lt;&lt; 1 | 1].val +=        seg[k].del * (seg[k &lt;&lt; 1 | 1].r - seg[k &lt;&lt; 1 | 1].l + 1);    seg[k &lt;&lt; 1].del += seg[k].del;    seg[k &lt;&lt; 1 | 1].del += seg[k].del;    seg[k].del = 0;  }  add(k &lt;&lt; 1, a, b, v);  add(k &lt;&lt; 1 | 1, a, b, v);  seg[k].val = seg[k &lt;&lt; 1].val + seg[k &lt;&lt; 1 | 1].val;}LL sum(int k, int a, int b) {  if (seg[k].l &gt; b || seg[k].r &lt; a) return 0;  if (seg[k].del) {    seg[k &lt;&lt; 1].val += seg[k].del * (seg[k &lt;&lt; 1].r - seg[k &lt;&lt; 1].l + 1);    seg[k &lt;&lt; 1 | 1].val +=        seg[k].del * (seg[k &lt;&lt; 1 | 1].r - seg[k &lt;&lt; 1 | 1].l + 1);    seg[k &lt;&lt; 1].del += seg[k].del;    seg[k &lt;&lt; 1 | 1].del += seg[k].del;    seg[k].del = 0;  }  if (seg[k].l &gt;= a &amp;&amp; seg[k].r &lt;= b) return seg[k].val;  LL k1 = sum(k &lt;&lt; 1, a, b);  LL k2 = sum(k &lt;&lt; 1 | 1, a, b);  return k1 + k2;}int main() {  int n, m;  int x, y;  LL v;  char op[10];  // freopen(\"in.txt\",\"r\",stdin);  while (~scanf(\"%d%d\", &amp;n, &amp;m)) {    for (int i = 1; i &lt;= n; i++) {      scanf(\"%d\", &amp;arr[i]);    }    init(1, 1, n);    for (int i = 0; i &lt; m; i++) {      scanf(\"%s%d%d\", op, &amp;x, &amp;y);      if (op[0] == 'Q') {#ifdef DEBUG1 puts(\"******************\");        for (int i = 1; i &lt; 4 * n; i++) {          if (seg[i].l) {            printf(\"%d %d %lld %lld\\n\", seg[i].l, seg[i].r, seg[i].val,                   seg[i].del);          }        }        puts(\"******************\");#endif printf(\"%lld\\n\", sum(1, x, y));      } else {        scanf(\"%lld\", &amp;v);        add(1, x, y, v);      }    }  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"poj3074 与 3076 Dancing Links 解数独","url":"/2010/10/06/obsidian/9db6bf9b-ae3d-415c-a8b2-96577744d6f7/","content":"好吧，我承认这个数独的图不好弄，建图建了好久，才想到每一行就四个结点，数独转化为精确覆盖问题的方法还是参照 Knuth 的论文，如果读取到一个格子是空的，那么加 999 行，分别表示这个格子填 111 到 999 这 999 个数字，如果读取到的格子是一个数字，那么就加一行就可以了，然后列有 9×9×49 \\times 9 \\times 49×9×4 列， 前 8 1 列表示这一行表示填的是第 iii 行第 jjj 列的格子，接下来 818181 列表示 第 i 行填写 kkk，接下来 818181 列表示第 jjj 列填写 4，最后 818181 列表示对应九宫格填写 kkk。转化为精确覆盖之后，直接跑 dlx 的 dfs 就可以了，主要还是建图，对于 3076 的 16×1616 \\times 1616×16 做法如出一辙。\n\n我的代码：\n3074：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 1000;const int oo = 0x3f3f3f3f;const int nC = 9 * 9 * 4;const int delta[] = {1, 82, 163, 244};const int head = 0;int cnt[MAX], st[MAX];int left[MAX * MAX], right[MAX * MAX], up[MAX * MAX], down[MAX * MAX];int row[MAX * MAX], col[MAX * MAX];struct Ans {  int r, c, k;} ans[MAX * MAX];int M, K;void remove(const int&amp; c) {  left[right[c]] = left[c];  right[left[c]] = right[c];  for (int i = down[c]; i != c; i = down[i]) {    for (int j = right[i]; j != i; j = right[j]) {      up[down[j]] = up[j];      down[up[j]] = down[j];      cnt[col[j]]--;    }  }}void resume(const int&amp; c) {  for (int i = up[c]; i != c; i = up[i]) {    for (int j = left[i]; j != i; j = left[j]) {      down[up[j]] = j;      up[down[j]] = j;      cnt[col[j]]++;    }  }  left[right[c]] = c;  right[left[c]] = c;}bool dfs(const int&amp; k) {  if (right[head] == head) {    char s[100] = {0};    for (int i = 0; i &lt; k; i++) {      s[ans[st[i]].r * 9 + ans[st[i]].c] = ans[st[i]].k + '0';    }    puts(s);    return true;  }  int s = oo, c = 0;  for (int i = right[head]; i != head; i = right[i]) {    if (cnt[i] &lt; s) {      s = cnt[i];      c = i;    }  }  remove(c);  for (int i = down[c]; i != c; i = down[i]) {    st[k] = row[i];    for (int j = right[i]; j != i; j = right[j]) {      remove(col[j]);    }    if (dfs(k + 1)) return true;    for (int j = left[i]; j != i; j = left[j]) {      resume(col[j]);    }  }  resume(c);  return false;}void init() {  left[head] = nC;  right[head] = 1;  up[head] = down[head] = head;  for (int i = 1; i &lt;= nC; i++) {    left[i] = i - 1;    right[i] = (i + 1) % (nC + 1);    up[i] = down[i] = i;    cnt[i] = 0;    col[i] = i;    row[i] = 0;  }  M = 0;  K = nC;}int makecolhead(const int&amp; c) {  K++;  cnt[c]++;  col[K] = c;  row[K] = M;  left[K] = right[K] = K;  up[K] = c;  down[K] = down[c];  up[down[K]] = K;  down[up[K]] = K;  return K;}void addcol(const int&amp; id, const int&amp; c) {  K++;  cnt[c]++;  col[K] = c;  row[K] = M;  left[K] = id;  right[K] = right[id];  left[right[K]] = K;  right[left[K]] = K;  up[K] = c;  down[K] = down[c];  up[down[K]] = K;  down[up[K]] = K;}void addrow(const int&amp; i, const int&amp; j, const int&amp; k) {  int id;  M++;  ans[M].r = i;  ans[M].c = j;  ans[M].k = k + 1;  id = makecolhead(9 * i + j + delta[0]);  addcol(id, 9 * i + k + delta[1]);  addcol(id, 9 * j + k + delta[2]);  addcol(id, (i / 3 * 3 + j / 3) * 9 + k + delta[3]);}int main() {  char s[100];  while (*gets(s) != 'e') {    init();    for (int i = 0; i &lt; 9; i++) {      for (int j = 0; j &lt; 9; j++) {        if (s[i * 9 + j] == '.') {          for (int k = 0; k &lt; 9; k++) {            addrow(i, j, k);          }        } else {          addrow(i, j, s[i * 9 + j] - '1');        }      }    }    dfs(0);  }  return 0;}\n3076:\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int oo = 0x3f3f3f3f;const int nR = 16 * 16 * 16 + 10;const int nC = 16 * 16 * 4;const int MAX = nR * 4 + nC + 10;const int delta[] = {1, 16 * 16 + 1, 16 * 16 * 2 + 1, 16 * 16 * 3 + 1};const int head = 0;int cnt[nC + 10], st[nC + 10];int left[MAX], right[MAX], up[MAX], down[MAX];int row[MAX], col[MAX];struct Ans {  int r, c, k;} ans[MAX];int M, K;void remove(const int&amp; c) {  left[right[c]] = left[c];  right[left[c]] = right[c];  for (int i = down[c]; i != c; i = down[i]) {    for (int j = right[i]; j != i; j = right[j]) {      up[down[j]] = up[j];      down[up[j]] = down[j];      cnt[col[j]]--;    }  }}void resume(const int&amp; c) {  for (int i = up[c]; i != c; i = up[i]) {    for (int j = left[i]; j != i; j = left[j]) {      down[up[j]] = j;      up[down[j]] = j;      cnt[col[j]]++;    }  }  left[right[c]] = c;  right[left[c]] = c;}bool dfs(const int&amp; k) {  if (right[head] == head) {    char s[300] = {0};    for (int i = 0; i &lt; k; i++) {      s[ans[st[i]].r * 16 + ans[st[i]].c] = ans[st[i]].k + 'A';    }    for (int i = 0; i &lt; 16; i++) {      for (int j = 0; j &lt; 16; j++) {        putchar(s[i * 16 + j]);      }      puts(\"\");    }    return true;  }  int s = oo, c = 0;  for (int i = right[head]; i != head; i = right[i]) {    if (cnt[i] &lt; s) {      s = cnt[i];      c = i;    }  }  remove(c);  for (int i = down[c]; i != c; i = down[i]) {    st[k] = row[i];    for (int j = right[i]; j != i; j = right[j]) {      remove(col[j]);    }    if (dfs(k + 1)) return true;    for (int j = left[i]; j != i; j = left[j]) {      resume(col[j]);    }  }  resume(c);  return false;}void init() {  left[head] = nC;  right[head] = 1;  up[head] = down[head] = head;  for (int i = 1; i &lt;= nC; i++) {    left[i] = i - 1;    right[i] = (i + 1) % (nC + 1);    up[i] = down[i] = i;    cnt[i] = 0;    col[i] = i;    row[i] = 0;  }  M = 0;  K = nC;}int makecolhead(const int&amp; c) {  K++;  cnt[c]++;  col[K] = c;  row[K] = M;  left[K] = right[K] = K;  up[K] = c;  down[K] = down[c];  up[down[K]] = K;  down[up[K]] = K;  return K;}void addcol(const int&amp; id, const int&amp; c) {  K++;  cnt[c]++;  col[K] = c;  row[K] = M;  left[K] = id;  right[K] = right[id];  left[right[K]] = K;  right[left[K]] = K;  up[K] = c;  down[K] = down[c];  up[down[K]] = K;  down[up[K]] = K;}void addrow(const int&amp; i, const int&amp; j, const int&amp; k) {  int id;  M++;  ans[M].r = i;  ans[M].c = j;  ans[M].k = k;  id = makecolhead(16 * i + j + delta[0]);  addcol(id, 16 * i + k + delta[1]);  addcol(id, 16 * j + k + delta[2]);  addcol(id, (i / 4 * 4 + j / 4) * 16 + k + delta[3]);}int main() {  char str[300];  char s[300];  int pos;  bool blocks = false;  while (~scanf(\"%s\", str)) {    if (blocks)      puts(\"\");    else      blocks = true;    init();    pos = 0;    for (int i = 0; i &lt; 16; i++) s[pos++] = str[i];    for (int i = 1; i &lt; 16; i++) {      scanf(\"%s\", str);      for (int j = 0; j &lt; 16; j++) {        s[pos++] = str[j];      }    }    for (int i = 0; i &lt; 16; i++) {      for (int j = 0; j &lt; 16; j++) {        if (s[i * 16 + j] == '-') {          for (int k = 0; k &lt; 16; k++) {            addrow(i, j, k);          }        } else {          addrow(i, j, s[i * 16 + j] - 'A');        }      }    }    dfs(0);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"SRM480 DIV1 250 分","url":"/2010/08/27/obsidian/a44fcfbf-944c-4442-b2ac-2048f8c70a33/","content":"好吧，我承认这题很简单 (不会 STL 的孩子把这句话无视)，看错题目导致成功挂零。。。无语死了。。。\n今天的 250 不是很难，要点有：\n\n对字符串的切割，手写切割函数比较保险，当然会用 STL 的字符串流的可以直接按照空格切割。\n查找关键字，嗯，这里有个好技巧，用红黑树 (set) 来维护全部的危险关键字即可。\n判断条件，只有当危险关键字超过定值的时候才是危险网站，否则不是。\n当一个网站是危险网站的时候，他的全部关键字都是危险的，这时候，我们要把全部的关键字加入红黑树中管理。\n由于 4 的原因，要扫描 NNN 次 (类似贝尔曼福德算法)，加入的顺序就不是原来的顺序了，这里在最后对其 id 进行一次排序，可以用一个映射 map 来存储下标。\n\n\n我的代码 (核心部分)：\nset&lt;string&gt; st;map&lt;string, int&gt; id;bool use[60];bool comp(const string&amp; a, const string&amp; b) { return id[a] &lt; id[b]; }bool check(const string&amp; key, int num) {  int len = key.length();  string ret;  vector&lt;string&gt; v;  int cnt = 0, size = 0;  for (int i = 0; i &lt; len; i++) {    ret = \"\";    while (i &lt; len &amp;&amp; key[i] != ' ') {      ret += key[i];      i++;    }    v.push_back(ret);  }  size = v.size();  for (int i = 0; i &lt; size; i++)    if (st.find(v[i]) != st.end()) {      cnt++;    }  if (cnt &gt;= num) {    for (int i = 0; i &lt; size; i++) st.insert(v[i]);    return true;  } else    return false;}class InternetSecurity { public:  vector&lt;string&gt; determineWebsite(vector&lt;string&gt; add, vector&lt;string&gt; key,                                  vector&lt;string&gt; dang, int num) {    int n = add.size();    vector&lt;string&gt; v;    memset(use, 0, sizeof(use));    id.clear();    st.clear();    for (int i = 0; i &lt; n; i++) id[add[i]] = i;    int size = dang.size();    for (int i = 0; i &lt; size; i++) st.insert(dang[i]);    for (int k = 0; k &lt; n; k++)      for (int i = 0; i &lt; n; i++)        if (!use[i] &amp;&amp; check(key[i], num)) {          use[i] = true;          v.push_back(add[i]);        }    sort(v.begin(), v.end(), comp);    return v;  }};\n总结：看题仔细，不要因为题目难懂就囫囵吞枣，最近开始讨厌看题，这是不好的现象。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"POJ3081 网络流","url":"/2010/11/26/obsidian/a67ab12f-a491-4971-9633-b9302a3fbc77/","content":"常见的多限制匹配问题，每头牛需要选择一种食物和一种饮料，每种食物和饮料只能被一头牛选到，所以直接建图，分三部分，左边为所有的食物，和源连边，容量为 111，右边是饮料，和汇连边，容量为 111，为了达到每头牛都只能选择一种食物和饮料的目的，中间为牛，每头牛拆成两个点，两个点连边，容量为 111，点 111 和食物连，点 222 和饮料连，在这基础上直接跑最大流即可。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 402;const int oo = 0x3f3f3f3f;struct Edge {  int num, ne, cap;} e[MAX * MAX];int pre[MAX], pree[MAX], low[MAX], p[MAX];int gap[MAX], cur[MAX], dist[MAX];int n, st, ed, K;int get() {  char ch;  bool flag = false;  int ret = 0;  while ((ch = getchar()) &lt; '0' || ch &gt; '9')    if (ch == '-') break;  if (ch == '-')    flag = true;  else    ret = ch - '0';  while ((ch = getchar()) &gt;= '0' &amp;&amp; ch &lt;= '9') ret = ret * 10 + ch - '0';  return ret;}int sap() {  int ret = 0;  bool done;  memset(gap, 0, sizeof(gap));  memset(dist, 0, sizeof(dist));  memset(low, 0, sizeof(low));  for (int i = 0; i &lt; n; i++) {    cur[i] = p[i];  }  gap[0] = n;  low[st] = oo;  int u = st;  while (dist[st] &lt; n) {    done = true;    for (int i = cur[u]; ~i; i = e[i].ne) {      int v = e[i].num;      cur[u] = i;      if (e[i].cap &amp;&amp; dist[u] == dist[v] + 1) {        pre[v] = u;        pree[v] = i;        low[v] = min(low[u], e[i].cap);        u = v;        if (u == ed) {          do {            e[pree[u]].cap -= low[ed];            e[pree[u] ^ 1].cap += low[ed];            u = pre[u];          } while (u != st);          ret += low[ed];        }        done = false;        break;      }    }    if (done) {      gap[dist[u]]--;      if (!gap[dist[u]]) return ret;      dist[u] = n;      for (int i = p[u]; ~i; i = e[i].ne) {        if (e[i].cap) {          dist[u] = min(dist[u], dist[e[i].num] + 1);        }      }      gap[dist[u]]++;      cur[u] = p[u];      if (u != st) u = pre[u];    }  }  return ret;}void add(const int&amp; u, const int&amp; v, const int&amp; cap) {  e[K].num = v;  e[K].cap = cap;  e[K].ne = p[u];  p[u] = K++;  e[K].num = u;  e[K].cap = 0;  e[K].ne = p[v];  p[v] = K++;}int main() {  int np, f, d;  int m1, m2, x;  while (~scanf(\"%d%d%d\", &amp;np, &amp;f, &amp;d)) {    n = 2 * np + f + d + 2;    st = 0;    ed = n - 1;    for (int i = 0; i &lt; n; i++) p[i] = -1;    K = 0;    for (int i = 1; i &lt;= f; i++) {      add(st, i, 1);    }    for (int i = 1; i &lt;= d; i++) {      add(i + 2 * np + f, ed, 1);    }    for (int i = 1; i &lt;= np; i++) {      add(i + f, i + np + f, 1);    }    for (int i = 1; i &lt;= np; i++) {      m1 = get();      m2 = get();      while (m1--) {        x = get();        add(x, i + f, 1);      }      while (m2--) {        x = get();        add(i + f + np, x + f + 2 * np, 1);      }    }    printf(\"%d\\n\", sap());  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"ACM-ICPC EC-Final 2015 简单题解","url":"/2016/01/31/obsidian/a79b28c2-065f-4986-8eb1-3c4d4def65f4/","content":"本篇简单描述一下 ACM/ICPC EC-Final 2015 的题解（非官方）。\n\n A. Boxes and Balls\nTags: 数学\n满足条件的球的数量一定是某个整数 mmm 对应的 m(m+1)2\\frac{m(m+1)}{2}2m(m+1)​ ，所以我们要找到最大的值，使得\nm(m+1)2≤N\\frac{m(m+1)}{2} \\leq N\n2m(m+1)​≤N\n第一种方法是直接解方程，直接解出以下方程的根\nm(m+1)2=N\\frac{m(m+1)}{2} = N\n2m(m+1)​=N\n然后在合适的精度范围内进行调整，得到正确的 mmm 。\n另外一种方法是直接二分，找到最大满足条件的 mmm ，但是要注意二分检查的过程，不要超 long long 了。\n B. Business Cycle\nTags: 杂题\n二分答案，然后首先计算一圈的和的增量，如果增量是小于等于 000 的，直接模拟即可。\n如果和增量大于 000 ，模拟前两圈，然后计算循环节，然后检查最后一圈的答案。\n细节比较多，需要仔细考虑。\n C. Suffixes and Palindromes\nTags: 字符串 贪心 图论（伪）\n将后缀排序和 Manacher 算法同时考虑，根据输入给的信息可以得到 AiA_iAi​ 和 AjA_jAj​ 的关系，是\nAi≥AjA_i \\geq A_j\nAi​≥Aj​\n或者\nAi&gt;AjA_i &gt; A_j\nAi​&gt;Aj​\n根据限制条件进行贪心或者差分约束。\n D. Change\nTags: 搜索 暴力\n这题网上大家表示很多人没注意到可以兑换多次（雾）。\n对于每一个输入对 (A,B)(A, B)(A,B) ，你只要兑换一次（ 0.010.010.01 ）或者两次（ 0.020.020.02 ）就可以得到想要的钱。\n用搜索或者 DP 去检查有没有可能不通过 BBB 或者任何和为 BBB 的组合得到 A−0.01A - 0.01A−0.01 ，如果没有，说明 BBB 是必需的，否则 AAA 兑换 BBB 就需要两次。\n E. Colorful Floor\nTags: 组合数学\n我们定义集合 XXX 的环基 CnC_nCn​ ，颜色的集合是 KKK ，那么有\n∣KX/Cn∣=1n∑i∣nϕ(i)∣K∣n/i\\left|K^X/C_n\\right| = \\frac{1}{n}\\sum_{i \\mid n}\\phi(i)\\left|K\\right|^{n/i}\n∣∣∣​KX/Cn​∣∣∣​=n1​i∣n∑​ϕ(i)∣K∣n/i\n接下来，我们把集合从 XXX 扩展到 X×YX \\times YX×Y ，那么有\n∣KX×Y/Cn×Cm∣=1nm∑i∣nϕ(i)ϕ(j)∣K∣nmlcm(i,j)\\left|K^{X \\times Y}/C_n \\times C_m\\right| = \\frac{1}{nm}\\sum_{i \\mid n}\\phi(i)\\phi(j)\\left|K\\right|^{\\frac{nm}{lcm(i, j)}}\n∣∣∣​KX×Y/Cn​×Cm​∣∣∣​=nm1​i∣n∑​ϕ(i)ϕ(j)∣K∣lcm(i,j)nm​\n我们考虑一个群 GGG 的等价类，当一个等价类在一个置换 ppp 下，满足 xˉ∈KX/G\\bar{x} \\in K^X/Gxˉ∈KX/G 时，我们有\np(xˉ)=xˉp(\\bar{x}) = \\bar{x}\np(xˉ)=xˉ\n回忆下 Burnside 引理，\n∣KX/G∣=1∣G∣∑g∈G#{x∈KX∣xg=x}\\left|K^X/G\\right| = \\frac{1}{|G|}\\sum_{g \\in G}\\#\\left\\{x \\in K^X \\mid xg = x\\right\\}\n∣∣∣​KX/G∣∣∣​=∣G∣1​g∈G∑​#{x∈KX∣xg=x}\n扩展成我们二维的情况，就是：\n#{xˉ∈KX/G∣p(xˉ)=xˉ}=1∣G∣∑g∈G#{x∈KX∣xg=px}\\#\\left\\{\\bar{x} \\in K^X/G \\mid p(\\bar{x}) = \\bar{x}\\right\\} = \\frac{1}{|G|}\\sum_{g \\in G}\\#\\left\\{x \\in K^X \\mid xg = px\\right\\}\n#{xˉ∈KX/G∣p(xˉ)=xˉ}=∣G∣1​g∈G∑​#{x∈KX∣xg=px}\n我们假定 g=(g1g2⋯gk)(⋯ )⋯(⋯ )g = (g_1 g_2 \\cdots g_k)(\\cdots)\\cdots(\\cdots)g=(g1​g2​⋯gk​)(⋯)⋯(⋯) ， x=(c1c2⋯ck)(⋯ )⋯(⋯ )x = (c_1 c_2 \\cdots c_k)(\\cdots)\\cdots(\\cdots)x=(c1​c2​⋯ck​)(⋯)⋯(⋯) ，根据条件\nxg=pxxg = px\nxg=px\n我们有\np(c1)=c2,p(c2)=c3,⋯ ,p(ck)=c1p(c_1) = c_2, p(c_2) = c_3, \\cdots, p(c_k) = c_1\np(c1​)=c2​,p(c2​)=c3​,⋯,p(ck​)=c1​\n对于任意的在环里的颜色 ccc 我们有 pk(c)=cp^k(c) = cpk(c)=c 。\n所以我们的答案是\n1nm∑i∣n&nbsp;j∣mϕ(i)ϕ(j)K(i,j)nmlcm(i,j)\\frac{1}{nm}\\sum_{\\substack{i \\mid n \\ j \\mid m}}\\phi(i)\\phi(j)K(i, j)^{\\frac{nm}{lcm(i, j)}}\nnm1​i∣n&nbsp;j∣m​∑​ϕ(i)ϕ(j)K(i,j)lcm(i,j)nm​\n其中\nK(i,j)=#{x∈K∣plcm(i,j)(c)=c}K(i, j) = \\#\\left\\{x \\in K \\mid p^{lcm(i, j)}(c) = c\\right\\}\nK(i,j)=#{x∈K∣plcm(i,j)(c)=c}\n F. Hungry Game of Ants\nTags: 动态规划\n我们考虑将蚂蚁按开始的方向分类，我们会发现，如果一个蚂蚁是向左走，那么它左边一整段向右走的都会被它吃掉，然后可以得到一个区间的和重量的蚂蚁，接下来，我们就考虑，再左边的那一整段的和，如果小于这一段的和，就会被这一整段吃掉。\n我们直接定义状态 dp[i]dp[i]dp[i] 表示考虑到第 iii 只蚂蚁，那么，对于 i&gt;ki&gt;ki&gt;k 的情况，我们需要它们被左边的吃掉，所以有\ndp[i]=∑j&nbsp;j(j+1)≥i(i+1)/2dp[j]dp[i] = \\sum_{\\substack{j \\\\\\ j(j+1) \\geq i(i+1)/2}} dp[j]\ndp[i]=j&nbsp;j(j+1)≥i(i+1)/2​∑​dp[j]\n对于 i=ki=ki=k 的情况，由于我们是从左向右递推的，所以我们要求第 kkk 只蚂蚁可以吃掉左边来的蚂蚁，所以有\ndp[i]=∑j&nbsp;j(j+1)&lt;i(i+1)/2dp[j]dp[i] = \\sum_{\\substack{j \\\\\\ j(j+1) &lt; i(i+1)/2}} dp[j]\ndp[i]=j&nbsp;j(j+1)&lt;i(i+1)/2​∑​dp[j]\n对于 i&lt;ki&lt;ki&lt;k 的情况，我们不需要考虑任何的条件，所以有\ndp[i]=2idp[i] = 2^i\ndp[i]=2i\n最后的答案是 dp[n]dp[n]dp[n] 。\n G. Legacy of Void\nTags: 动态规划 树分治\n看心情后面补（挖坑）。。。\n H. Open Face Chinese Poker\nTags： 动态规划 模拟\n我们定义状态 dp[mask][i][j]dp[mask][i][j]dp[mask][i][j] 表示使用了 maskmaskmask 这些卡（这是一个二进制的 orbits），前三张卡的 rank 是 iii （我们可以定义 High Card 的值是 000 ，没有分数的值是 111 ，剩下的有分数的从 222 递增，总共有 242424 种情况），中间 5 张卡的 rank 是 jjj （除了没分数以为，剩下的递增，总共有 888 种情况）。\n然后我们可以用枚举处理出 (145)\\binom{14}{5}(514​) 种 rank，然后转移就好了。\n I. Champions League\nTags: 动态规划\n直接将 323232 个国家做 orbits 定义状态 dp[mask]dp[mask]dp[mask] 然后按国家进行 dp，用 hash 和 BFS 做记忆化和扩展。\n比较重要的一点是，整个 DP 的过程是针对国家的，每一个 level 的队伍数量是固定的。\n虽然状态看上去有 2322^{32}232 ，实际上的状态数量是 (84)4\\binom{8}{4}^4(48​)4 。\n J. Dome and Steles\nTags: 贪心\n对于每个石碑，它可以放的最小的半径可以计算出来，是\nri=max(ai,bi)24+min(ai,bj)2r_i = \\sqrt{\\frac{max(a_i, b_i) ^ 2}{4} + min(a_i, b_j) ^ 2}\nri​=4max(ai​,bi​)2​+min(ai​,bj​)2​\n二分答案，对于每一个石碑我们可以得到它可以放的位置，比如说是区间 [−pi,pi][-p_i, p_i][−pi​,pi​] ，其中 pi=R2−ri2p_i = \\sqrt{R^2 - r_i^2}pi​=R2−ri2​​ 。\n然后我们按 pip_ipi​ 从大到小排序，贪心放在左边或者右边的位置。\n K. Convex Polyhedron\nTags: 三维几何\n首先，我们可以求出点集所表示的三维凸包对应的所有面，由于 n≤50n \\leq 50n≤50 ，所以我们可以在 O(n4)O(n^4)O(n4) 时间内得到。\n然后，我们通过 O(n3)O(n^3)O(n3) 枚举三个面，可以检查这三个面划分的 888 个子空间（可以通过 232^323 枚举法方向向量得到空间的指示向量），我们可以知道面 C1C_1C1​ ， C2C_2C2​ ， ⋯\\cdots⋯ ， CkC_kCk​ 是通过这个子空间指示向量正面看，可以看见的，那么从这个方向看到的最大面积是\n∑i=1kSi⋅ni⃗\\sum^{k}_{i = 1}{S_i \\cdot \\vec{n_i}}\ni=1∑k​Si​⋅ni​​\n其中 SiS_iSi​ 是面 CiC_iCi​ 的面积， ni⃗\\vec{n_i}ni​​ 是这个面的单位法向量。\n得到的向量的长度之中最大的就是答案。\n总体复杂度 O(n4)O(n^4)O(n4) 。\n L. Multiplication Table\nTags: 数学\n如果没有数字，答案是 Yes 。\n如果只有一个数字，我们枚举这个数字的组合 X×YX \\times YX×Y ，然后看这个 table 能不能被包含在乘法表中。\n如果有多个数字，那么我们可以通过解方程的方法唯一确定 table 的位置，然后检查是否满足。\n M. November 11th\nTags: 杂题\n对于每一行单独处理。\n最大值是两个人隔着坐，如果有一段连续的区间长度是 LLL ，那么最大值是 ⌊L2⌋\\left\\lfloor\\frac{L}{2}\\right\\rfloor⌊2L​⌋ 。\n最小值是一个人可以占连续的三个位置，那么最小值就是 ⌈L3⌉\\left\\lceil\\frac{L}{3}\\right\\rceil⌈3L​⌉ 。\n","categories":["ICPC题解"],"tags":["ICPC题解"]},{"title":"POJ1742 多重背包","url":"/2010/12/07/obsidian/a7a1acaa-a569-476f-971d-74199bc57c5f/","content":"典型的单调队列优化 dp。对于 nnn 类物品，某类物品的数量为 kkk，价值为 vvv，容量为 www。那么考虑到这个种类的物品的时候有如下 dp 方程：\n设 dp[i]dp[i]dp[i] 表示容量为 iii 的时候得到的最大价值，那么我们就有：\ndp[i]=max⁡{dp[i−k×w]+k×v}dp[i]=\\max\\{dp[i-k \\times w]+k \\times v\\}\ndp[i]=max{dp[i−k×w]+k×v}\n换一种写法:\ndp[mod+k×w]=max⁡{dp[mod+j×w]+(k−j)×v}dp[mod+k \\times w]=\\max\\{dp[mod+j \\times w]+(k-j) \\times v\\}\ndp[mod+k×w]=max{dp[mod+j×w]+(k−j)×v}\n这里为了方便，我们用 sjs_jsj​ 表示 dp[mod+j×w]dp[mod+j \\times w]dp[mod+j×w]，所以就有\ndp[mod+k×w]=max⁡{sj+(k−j)×v}=max⁡{sj−j×v}+k×vdp[mod+k \\times w]=\\max\\{s_j + (k-j) \\times v\\} = \\max\\{s_j-j \\times v\\}+k \\times v\ndp[mod+k×w]=max{sj​+(k−j)×v}=max{sj​−j×v}+k×v\n这里 kkk 已经是定值，也就是说 dp[mod+k×w]dp[mod+k \\times w]dp[mod+k×w] 只和一定范围内的 sj−j×vs_j-j \\times vsj​−j×v 的最大值有关，可以用单调队列优化。总的复杂度是 O(N×V)O(N \\times V)O(N×V) 的。\n这道题比较简单，由于价值都 是 1 的，我们就直接开一个 bool 型数组存储是否存在解就可以了。然后枚举到的 kkk 如果 dp[k]dp[k]dp[k] 是可达的，那么我们就将其 id 入队，否则就不管，另外由于价值一样，所以不要记录价值。\n此类背包问题还可以进一步地优化，如果 kkk 等于 111 的时候直接写 0-1 背包，如果物品可以取得的总容量大于背包总容量，那么就直接写完全背包，因为这两种写法和单调队列相比常数小了非常多。\n最后考虑到很大的输入输出量，选择 C++ 编译器。\n\n完整代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 100010;bool dp[MAX];int id[MAX], c[120], v[120], f, b;int main() {  int n, m;  freopen(\"in.txt\", \"r\", stdin);  while (scanf(\"%d%d\", &amp;n, &amp;m), n || m) {    for (int i = 1; i &lt;= m; i++) dp[i] = false;    dp[0] = true;    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;v[i]);    for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;c[i]);    for (int i = 0; i &lt; n; i++) {      int w = c[i] * v[i];      if (c[i] == 1) {        for (int j = m; j &gt;= v[i]; j--) {          if (dp[j - v[i]]) dp[j] = true;        }      } else if (w &gt;= m) {        for (int j = v[i]; j &lt;= m; j++) {          if (dp[j - v[i]]) dp[j] = true;        }      } else {        for (int j = 0; j &lt; v[i]; j++) {          f = b = 0;          for (int k = j; k &lt;= m; k += v[i]) {            if (f != b &amp;&amp; k - id[f] &gt; w) f++;            if (dp[k]) {              id[b++] = k;            } else if (f != b) {              dp[k] = true;            }          }        }      }    }    int ret = 0;    for (int i = 1; i &lt;= m; i++)      if (dp[i]) ret++;    printf(\"%d\\n\", ret);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"UVA11990 Dynamic Inversion 树套树","url":"/2011/09/30/obsidian/ab14ab9c-0c4b-48e1-b119-9bc67897b5e6/","content":"这题很经典的动态逆序对问题，我们可以利用树套树来解决它，首先我们得到一个总体的思路\n对于每一个操作，我们先利用树状数组求出一个逆序对，然后进行查询统计，对于每一个删除操作，我们只要查询这个元素之前的比它大的还有后面的比它小的有多少，逆序对就减少多少，这个操作可以利用树套树搞定\nlrj 的题好囧，这题线段树一直 T，后来想到可以用区间的加减性，写了一个树状数组套平衡树就过了 - -\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"HDU3957 Dancing Links","url":"/2011/08/19/obsidian/b0187338-a9eb-419e-a68c-c79f12ab5974/","content":"好吧，昨天被这题虐惨了，照着模板敲漏了一句话，导致 1005 没有时间写了。这题可以算是一个比较经典的 Dancing Links 的题了，我们将问题抽象这如下一个模型。\n大致题意\n给你一个 R×CR \\times CR×C 的 0-1 矩阵，要求选出最小数量的行使得每一列至少被覆盖一次，并且有限制某一些行中只能至多选择一行。\n\n我们将模型抽象化，有两种方法来解决此类问题。\n第一种方法是建立一个有 2×N2 \\times N2×N 行，3×N3 \\times N3×N 列的矩阵，行代表的是选择哪些人的哪一个形态，前 2×N2 \\times N2×N 列代表的是 NNN 个人的两种形态，后面 NNN 列表示选择了某个人，这样我们可以这么理解，前 2×N2 \\times N2×N 列是我们必须至少覆盖一次的，后 NNN 列是我么至多覆盖一次的，那么我们就在前 2×N2 \\times N2×N 列进行重复覆盖，后面 NNN 列进行精确覆盖，此外，判断是否得到了一组解，只要判断前 2×N2 \\times N2×N 列是否已经被完全覆盖了即可。这个矩阵的规模是 50×7550 \\times 7550×75 的。\n第二种方法是建立一个 2×N2 \\times N2×N 行 2×N2 \\times N2×N 列的矩阵，直接跑重复覆盖，此外用一个数组标记某一个人是否被选择过，如果一个人的某一形态被选择过，那么另外一个形态对应的行就不能选择，这个矩阵的规模是 50×5050 \\times 5050×50 的。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"Setup your HTTPS website using Certbot","url":"/2019/04/01/obsidian/b0879869-9bc9-4cf6-8d5d-f9a59fc8e788/","content":"When you are considering support basic HTTPS blog, you may choose Certbot to perform a self-assign certificate, according to the Offical Tutorial [1].\n\nAfter installed the tool, you may check whether /etc/cron.d/certbot was configured, if not, you may add it by performing command line:\nsudo certbot renew --dry-run\nOr add it manually into the corresponding file:\nSHELL=/bin/shPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin0 */12 * * * root test -x /usr/bin/certbot -a \\! -d /run/systemd/system &amp;&amp; perl -e 'sleep int(rand(43200))' &amp;&amp; certbot -q renew\n\n\n\nhttps://certbot.eff.org/instructions?ws=nginx&amp;os=ubuntufoca ↩︎\n\n\n\n","categories":["development"],"tags":["软件开发/安全","运维/服务器配置"]},{"title":"HDU1244 最大连续子字段和最终加强版","url":"/2010/12/17/obsidian/b14d9b7c-de3b-45bc-be71-77f7a1f62b03/","content":"记录 dp[i][j]dp[i][j]dp[i][j] 表示以第 iii 个元素结尾，有 jjj 组的时候的最大和，那么有\ndp[i][j]=max⁡{dp[k][j−1]}+sum[i−lj+1][i]dp[i][j]=\\max\\{dp[k][j-1]\\}+sum[i-l_j+1][i]\ndp[i][j]=max{dp[k][j−1]}+sum[i−lj​+1][i]\n其中 k+lj≤ik+l_j \\leq ik+lj​≤i，那么这样的转移是 O(n)O(n)O(n) 的，为了优化，记录 s[i][j]s[i][j]s[i][j] 表示 s[0][j]s[0][j]s[0][j] 到 s[i][j]s[i][j]s[i][j] 中的最大 dp 值，那么可以在 O(1)O(1)O(1) 的时间内做到转移，最后可以得到一个转移方程：\ndp[i][j]=s[i][j−1]+sum[i−lj+1][i]。dp[i][j]=s[i][j-1]+sum[i-l_j+1][i]。\ndp[i][j]=s[i][j−1]+sum[i−lj​+1][i]。\n注意 sumsumsum 数组可以用前 nnn 项和得到。\n我的代码中用 valvalval 直接表示前 nnn 项和。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 1200;int dp[MAX][25], s[MAX][25], l[MAX], val[MAX];int main() {  int n, m;  while (scanf(\"%d\", &amp;n), n) {    scanf(\"%d\", &amp;m);    for (int i = 1; i &lt;= m; i++) {      scanf(\"%d\", &amp;l[i]);    }    val[0] = 0;    for (int i = 1; i &lt;= n; i++) {      scanf(\"%d\", &amp;val[i]);      val[i] += val[i - 1];    }    memset(dp, 0, sizeof(dp));    memset(s, 0, sizeof(s));    for (int j = 1; j &lt;= m; j++) {      for (int i = 1; i &lt;= n; i++) {        if (i - l[j] &gt;= 0) {          dp[i][j] = s[i - l[j]][j - 1] + val[i] - val[i - l[j]];        }        s[i][j] = max(s[i - 1][j], dp[i][j]);      }    }    int ret = 0;    for (int i = 1; i &lt;= n; i++) {      ret = max(ret, dp[i][m]);    }    printf(\"%d\\n\", ret);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"POJ2021 Relative Relatives","url":"/2010/08/29/obsidian/b89c71f7-7844-472b-ad5d-8f34cd3b46f8/","content":"这题用到了 STL 的强大功能，简单图论，但是需要进行 hash，我运用的是 map 来 hash。\n首先是建图，将父子关系连有向边，从父亲到孩子，这样我们就可以通过 DFS 一遍找到全部的年龄。注意 map 的定义。最后用一个 rbt 来维护最后的解有序，当然，你也可以运用向量 vector 来维护，总的时间复杂度是 O(nlgn)O(nlgn)O(nlgn) 的。\n\n我的代码：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;string&gt;using namespace std;struct Ans {  string name;  int age;  bool operator&lt;(const Ans&amp; ans) const {    if (age != ans.age)      return age &gt; ans.age;    else      return name &lt; ans.name;  }};map&lt;string, int&gt; age;map&lt;string, map&lt;string, int&gt; &gt; mp;set&lt;Ans&gt; st;void dfs(string name) {  map&lt;string, int&gt;::iterator it;  for (it = mp[name].begin(); it != mp[name].end(); it++) {    if (!age[(*it).first]) {      age[(*it).first] = age[name] - (*it).second;      dfs((*it).first);    }  }}int main() {  int t, cnt = 0, n, num;  string a, b;  char s[120];  map&lt;string, int&gt;::iterator it;  set&lt;Ans&gt;::iterator iter;  Ans ans;  scanf(\"%d\", &amp;t);  while (t--) {    cnt++;    mp.clear();    age.clear();    age[\"Ted\"] = 100;    scanf(\"%d\", &amp;n);    while (n--) {      scanf(\"%s\", s);      a = s;      scanf(\"%s\", s);      b = s;      scanf(\"%d\", &amp;num);      mp[a][b] = num;    }    dfs(\"Ted\");    st.clear();    for (it = age.begin(); it != age.end(); it++) {      ans.name = (*it).first;      ans.age = (*it).second;      st.insert(ans);    }    printf(\"DATASET %d\\n\", cnt);    for (iter = st.begin(); iter != st.end(); iter++) {      if ((*iter).name == \"Ted\") continue;      printf(\"%s %d\\n\", (*iter).name.c_str(), (*iter).age);    }  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"CCPC 2015 简单题解","url":"/2015/10/22/obsidian/bedc9e3e-133f-49b2-a192-6d552cb09be3/","content":"本篇简单描述一下 CCPC 2015 决赛的题解（非官方）。\n\n Secrete Master Plan\nTags: 杂题\n把输入的格子数字按顺时针或者逆时针顺序放到两个数组中，然后用 for 循环判断能不能通过 shift 来使得两个数组相同。\n Build Towers\nTags: 启发式搜索\n把状态进行 hash，然后跑 A* 或者 IDA*，一个简单的估价函数可以是\nh(s)=size−6h(s) = size - 6\nh(s)=size−6\n其中 sss 是状态，sizesizesize 是当前状态中单独块的个数，比如说 0−10-10−1 算是 111 块，0−1,3−50-1,3-50−1,3−5 算是 222 块。\n一个比较好的优化是，把每个塔进行排序，行按照塔上木棍的数量从小到大，一样的时候，按字典序，这样可以把重复的状态减少。\n The Battle of Chibi\nTags: 数据结构 动态规划 图论\n定义状态 dp[i][j]dp[i][j]dp[i][j] 表示选了 iii 个考虑到了前 jjj 个，这 iii 个是严格递增的方法数，转移方程：\ndp[i][j]=∑ak&lt;aj(dp[i−1][k])dp[i][j] = \\sum_{a_k &lt; a_j}(dp[i - 1][k])\ndp[i][j]=ak​&lt;aj​∑​(dp[i−1][k])\n这里的转移可以用树状数组进行优化，转移是 O(lg⁡N)O(\\lg N)O(lgN) 的，总体复杂度 O(N⋅Mlg⁡N)O(N \\cdot M \\lg N)O(N⋅MlgN)。\n Pick The Sticks\nTags: 动态规划\n把金条按长度从大到小排序，定义状态 dp[i][j][k]dp[i][j][k]dp[i][j][k] 表示考虑到前 iii 个金条，选了 jjj 个，它们的长度和是 kkk，可以获得的最大价值，直接 0-1 背包就可以，其中 jjj 是 0-2 的，如果 jjj 是 000 或者 111，那么新选择的金条有效长度减半，否则就用原长。由于这题说的是重心，为了方便处理，可以把所有的长度乘以 222 方便转移。\n Ba Gua Zhen\nTags: 数学 图论\n先构建一棵生成树，对于所有的非树边，求出对应的简单环的异或和，这样我们可以得到 M−NM - NM−N 个数，最后这题的问题就可以转化为给 M−NM - NM−N 个数，选出一些数出来，使得异或和最大。这个可以用类似高斯消元的思想在 O(60×(M−N))O(60 \\times (M - N))O(60×(M−N)) 时间内求得。\n The Battle of Guandu\nTags: 图论\n根据题意可以构建出一个不等式组，把这个不等式组，求个对偶形式，可以发现模型由一个单纯形的问题转化成了差分约束系统，可以建图跑最短路得到答案。\n Ancient Go\nTags: 杂题\n对于每个白子跑 DFS 或者 BFS 找气，只要气是 (1) 就说明下一步可以吃子。\n Sudoku\nTags: 搜索 暴力\n简单的搜索或者枚举就可以。枚举的话就直接枚举每一行的排列是什么然后判断，排列方式只有 242424 种，最暴力的做法也就 O(244×N2)O(24^4 \\times N^2)O(244×N2)。\n Mahjong\nTags: 动态规划 状态压缩\n动态规划，定义 dp[i][j][s]dp[i][j][s]dp[i][j][s] 表示考虑到第 iii 种牌，一共用了 jjj 个，sss 表示一个压缩的状态，这个状态记录的是一个三元组 (i,j,k)(i,j,k)(i,j,k)，表示考虑到 iii，其中 i−2i-2i−2 剩下了 jjj 个，i−1i-1i−1 剩下了 kkk 个，这样的状态定义可以比较方便处理重复的情况。其中对于每个状态，sss 的值是很少的，这里可以直接预处理出来合法的 sss。\n Walk Around The Campsite\nTags: 几何 动态规划\n对于每一个点，我们都要知道站在它位置上可以 “看到” 哪些点，这里将所有的线段拆分成三种事件，一种是一个发现了一个新的线段，一个是一个线段将要被删除，还有一个是查询一个点是不是能从中心点看到。由于所有的线段最多只会在端点相交，所以我们可以用平衡树维护线段的序，平衡树的 key 是沿当前角度上从中心点看，这个线段到中心点的距离，值是线段，这样对于查询点的事件，我们只要看它是不是在最近的线段上就可以了。\n处理完有效的信息之后就是一个很简单的转移（卧槽为毛这么多 dp）：\ndp[i]=max(dp[k]−dist(k,i)+vi)dp[i] = max(dp[k] - dist(k, i) + v_i)\ndp[i]=max(dp[k]−dist(k,i)+vi​)\n其中，从 kkk 可以看到 iii。最后答案是 max(dp[i])max(dp[i])max(dp[i])。\n Game Rooms\nTags: 动态规划\n再吐槽下为毛这么多 dp（不\n定义状态 dp[i][j][k]dp[i][j][k]dp[i][j][k] 表示考虑到第 iii 层，上次和这一层一样的活动室是在 jjj 层，当前楼层放 k(0,1)k(0, 1)k(0,1) 这个活动室的最小代价。转移的时候可以处理出 ∑ai\\sum{a_i}∑ai​ 和 i×aii \\times a_ii×ai​ 然后在 O(1)O(1)O(1) 时间内转移。\n Huatuo’s Medicine\nTags: 杂题\n签到 0.0\n#! /usr/bin/env python2T = int(raw_input())for cas in xrange(0, T):    print \"Case #%d: %d\" % (cas + 1, 2 * int(raw_input()) - 1)\n","categories":["ICPC题解"],"tags":["ICPC题解"]},{"title":"HDU1255 覆盖的面积 扫描线","url":"/2010/09/20/obsidian/c21428e3-c972-4798-b9a7-ec147f556a10/","content":"好久没写扫描线了，今天想拿些数据结构题目练手，在题目分类里面看到了这题，就拍上了。\n扫描线排序离散化，线段树的区间代表 yyy 的脚标，然后对 yyy 进行离散化，二分查找对应的 y。\nvalvalval 用来记录区间被覆盖的次数，严格 O(nlgn)O(nlgn)O(nlgn) 的访问，然后直接扫描一遍就可以了。\n对精度要求不高，原来数组开小了，epsepseps 设成 1e-8 就 WA 了，不知道是数据开到 100010001000 不够还是 epsepseps 太小。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;const double eps = 1e-6;const int MAX = 10100;int n, len;double sum;struct Node {  int l, r, val;  double area;};Node seg[4 * MAX];struct Line {  // each sub contains two lines, left and right.  double x, y1, y2;  bool s;  // true- left, false - right  bool operator&lt;(const Line&amp; line) const { return x &lt; line.x; }};Line line[2 * MAX];double line_y[2 * MAX];int Read(double num) {  int left, mid, right;  left = 0;  right = len - 1;  while (left &lt;= right) {    mid = (left + right) / 2;    if (fabs(num - line_y[mid]) &lt; eps) return mid;    if (num - line_y[mid] &gt; eps)      left = mid + 1;    else      right = mid - 1;  }  return -1;}// clearvoid Init(int k, int l, int r) {  seg[k].l = l;  seg[k].r = r;  seg[k].val = 0;  seg[k].area = 0;  if (l + 1 &lt; r) {    int mid = (l + r) / 2;    Init(2 * k, l, mid);    Init(2 * k + 1, mid, r);  }}void Update(int k) {  if (seg[k].val &gt; 1)    seg[k].area = line_y[seg[k].r] - line_y[seg[k].l];  // calculate area  else if (seg[k].r - seg[k].l == 1)    seg[k].area = 0;  else    seg[k].area = seg[2 * k].area + seg[2 * k + 1].area;}void Insert(int k, int l, int r) {  if (seg[k].r - seg[k].l == 1) {    seg[k].val++;    Update(k);    return;  }  int mid = (seg[k].l + seg[k].r) / 2;  if (l &lt; mid) Insert(k * 2, l, r);  if (r &gt; mid) Insert(k * 2 + 1, l, r);  Update(k);}void Remove(int k, int l, int r) {  if (seg[k].r - seg[k].l == 1) {    seg[k].val--;    Update(k);    return;  }  int mid = (seg[k].l + seg[k].r) / 2;  if (l &lt; mid) Remove(2 * k, l, r);  if (r &gt; mid) Remove(2 * k + 1, l, r);  Update(k);}// add (x1,y1)-(x2,y2) line set.void Add(double x1, double y1, double x2, double y2, int i) {  int k = 2 * i;  line[k].x = x1;  line[k].y1 = y1;  line[k].y2 = y2;  line[k].s = 1;  line[k + 1].x = x2;  line[k + 1].y1 = y1;  line[k + 1].y2 = y2;  line[k + 1].s = 0;  line_y[k] = y1;  line_y[k + 1] = y2;}void run() {  // when input the cubes, use add() to add them.  // then sort the array line and line_y. //in here, n is double of the number  // of cubes. left and right. after that, we delete the epactal lines in the  // set. then insert the lines into segment tree. let len is the new range of  // lines.  n *= 2;  sort(line, line + n);  sort(line_y, line_y + n);  len = 1;  for (int i = 1; i &lt; n; i++)    if (line_y[i] != line_y[i - 1]) line_y[len++] = line_y[i];  Init(1, 0, len - 1);  sum = 0.0;  int l, r;  // s=delta_x*delta_y  for (int i = 0; i &lt; n - 1; i++) {    l = Read(line[i].y1);    r = Read(line[i].y2);    if (line[i].s)      Insert(1, l, r);    else      Remove(1, l, r);    sum += seg[1].area * (line[i + 1].x - line[i].x);  }  printf(\"%.2f\\n\", sum);}int main() {  double x1, x2, y1, y2;  int t;  scanf(\"%d\", &amp;t);  while (t--) {    scanf(\"%d\", &amp;n);    for (int i = 0; i &lt; n; i++) {      scanf(\"%lf%lf%lf%lf\", &amp;x1, &amp;y1, &amp;x2, &amp;y2);      Add(x1, y1, x2, y2, i);    }    run();  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"CDOJ1300 LCIS","url":"/2010/12/03/obsidian/c5bbd8be-a466-43b3-bec3-b859feca9ebf/","content":"这道题当初想当然的认为 LCIS 只要求出 LCS 记录路径然后求 LCS 的 LIS 就可以，发现根本不是这回事儿。。\n这题很明显的 dp，但是转移方程写的各种戳。。。。- -\n最裸的 dp 方程：\ndp[i][j]=max⁡{dp[ki][kj]}+1dp[i][j]=\\max\\{dp[k_i][k_j]\\}+1\ndp[i][j]=max{dp[ki​][kj​]}+1\n其中：\n{ki&lt;ikj&lt;jai=akibj=bkj\\begin{cases}\n k_i&lt;i \\\\\n k_j&lt;j \\\\\n a_i = a_{k_i} \\\\\n b_j = b_{k_j}\n \\end{cases}\n⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​ki​&lt;ikj​&lt;jai​=aki​​bj​=bkj​​​\ndp[i][j]dp[i][j]dp[i][j] 表示以 aia_iai​ 和 bjb_jbj​ 结尾的 LCIS。\n这样转移正确性就不做证明了，很明显，但是转移费用太高了，是 O(n2)O(n^2)O(n2) 的转移，这样总的时间复杂度就变成了 O(n4)O(n^4)O(n4)。对于 100010001000 的数据不可接受。\n改进版本：\ndp[i][j]=max⁡{dp[ki][j−1]}+1dp[i][j] = \\max\\{dp[k_i][j-1]\\}+1\ndp[i][j]=max{dp[ki​][j−1]}+1\n其中：\n{ki&lt;iai=bj\\begin{cases}\nki&lt;i \\\\\na_i = b_j\n\\end{cases}\n{ki&lt;iai​=bj​​\n这时候 dp[i][j]dp[i][j]dp[i][j] 表示以 aia_iai​ 结尾，bjb_jbj​ 或其之前元素结尾的 LCIS。\n这样转移就可以写成 O(n)O(n)O(n) 的转移，加上 O(n2)O(n^2)O(n2) 的状态，算法复杂度是 O(n3)O(n^3)O(n3)。\n注意，这时候还有一个很显著的优化，记录一个下标 ppp 使得 ap≤bja_p \\leq b_jap​≤bj​ 并且 dp[p][j−1]dp[p][j-1]dp[p][j−1] 是 dp[0][j−1]dp[0][j-1]dp[0][j−1] 到 dp[i−1][j]dp[i-1][j]dp[i−1][j] 中最大的，这样转移就是 O(1)O(1)O(1) 的\ndp[i][j]=dp[p][j−1]+1dp[i][j]=dp[p][j-1]+1\ndp[i][j]=dp[p][j−1]+1\n至此，我们的 O(n2)O(n^2)O(n2) 的 dp 方程就已经完成，总的复杂度就是 O(n2)O(n^2)O(n2)，对于 100010001000 的数据量正好适合\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 1100;int dp[MAX][MAX], a[MAX], b[MAX];int get() {  char ch;  int flag = 0, tmp = 0;  for (ch = getchar(); ch &lt; 48 || ch &gt; 57; ch = getchar())    if (ch == int('-')) break;  if (ch == int('-'))    flag = 1;  else    tmp = int(ch) - 48;  for (ch = getchar(); 48 &lt;= ch &amp;&amp; ch &lt;= 57; ch = getchar())    tmp = tmp * 10 + int(ch) - 48;  return (flag) ? -tmp : tmp;}int main() {  int t;  int lena, lenb;  t = get();  while (t--) {    lena = get();    lenb = get();    for (int i = 1; i &lt;= lena; i++) a[i] = get();    for (int i = 1; i &lt;= lenb; i++) b[i] = get();    for (int i = 0; i &lt;= lena; i++) dp[i][0] = 0;    for (int j = 1; j &lt;= lenb; j++) {      dp[0][j] = 0;      int p = 0;      for (int i = 1; i &lt;= lena; i++) {        dp[i][j] = dp[i][j - 1];        if (a[i] == b[j] &amp;&amp; dp[i][j] &lt; dp[p][j - 1] + 1) {          dp[i][j] = dp[p][j - 1] + 1;        } else if (a[i] &lt; b[j] &amp;&amp; dp[i][j] &gt; dp[p][j - 1]) {          p = i;        }      }    }    int ret = 0;    for (int i = 0; i &lt;= lena; i++) {      ret = max(ret, dp[i][lenb]);    }    printf(\"%d\\n\", ret);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"论 ACM ICPC","url":"/2012/02/24/obsidian/c720bef2-6abf-47ae-9743-59a25c824a94/","content":"这段时间老是有许多新人向我问到 ACM 相关的问题。比如它与工作的关系，对我以后的工作到底有没有帮助？还比如说第二年的训练计划应该是什么样的？还有的孩子问到，我寒假玩儿的一个寒假，又该怎么办？\n看到这些问题，我自己也感慨万千，一眨眼自己在这方面也涉猎了两年多了，经过那一段时间的纠结，最终还是决定第三年继续。大家选择 ACM 的理由的很多很多，为了以后方便找工作？充实生活？巩固学科基础？不管是为了功利心理也好，还是纯粹的兴趣也罢，最后共同的结果就是我们选择了 ACM 作为自己大学生活的一部分。\n\n 我们可以从 ACM 中学到什么？\n首先，作为一个团队活动，我们可以从中感受到团队合作的魅力，只可以感受团队合作给我们带来有那种不一样的感觉，当然，也可以从中认识更多的志同道合的朋友。\n其次，ACM 是一个学习的过程，对我来说，在这两年里，我自己学到了许多上课不会涉及的东西，自己吸收其它方面知识变得更快了，对于即将从事 IT 产业的我们来说，学习能力是一个非常重要的能力。\n最后，要取得好的成绩，我们要掌握许许多多的知识，而大部分的知识，都是计算机学科、数学学科的基础，比如说微积分、线性代数、概率论、数据结构等等。\n ACM 需要的是坚持而不是三分钟热度\n大一开班会的时候提及到过大学四年的规划，记得当时选这个的人挺多的，坚持半年的也很多，但是到了大一下学期，一个寒假回来，坚持下来的就没有几个了，而到了最后参加讲座的就更少了。这说明的什么？可能是没有兴趣吧，ACM 是一个需要坚持的竞赛活动，不是简简单单的混个三、四个月就可以有成绩的，只因为付出了，才会有后来的回报。\n很久以前就听学长们说了一句话\n\nACM ICPC 不应该成为大学生活的全部，但是我们却时常后悔没有把我们的全部投入进去。\n\n很多人常常在失败的时候抱怨自己的队友，把失败归咎于自己的团队，当然也有人把所有的责任推到自己的身上。我们要记住，ACM 是三个人的活动，不是你一个人的，更不是你队友的。三个人坚持下来了，我们要的不一定是得到辉煌的成就，最主要的还是那深厚的友谊加上和朋友们一起奋斗的过程。\n 关于 ACM 的种种小事\n 交流是重中之重\n成为集训队的成员已经有两年的时光了，在每年新的一轮训练开始时，最经常见到的就是一个新人的队伍，甚至是有一定配合的老队伍的三个人，各自做各自的，从始至终都没有什么交流，说的最多的就是这题过了，这题挂了，或者是你先下来，我先写另外一道，等等。切记一点，ACM 是三个人的活动，并不是 1+1+1 那么简单的，如果三个人各自为战，这和个人活动有什么区别？1+1+1&lt;1 是常常遇到的事儿，出现这类问题最主要的原因就是各自为战。\n 做事要有一个整体规划\n到现在，我见到的最多的解题策略，包括我自己曾经用的，都是 reading-thinking-coding-thinking-coding-debug-thinking-debug-submit。对于一个中档题来说，这个过程可能需要 30 到 50 分钟不等，往往很多人觉得 50 分钟和 30 分钟是没区别的。在过题之后估计整个过程，许多人会把实际上是 50 分钟的时间估计成半小时，然后就觉得时间充裕。不管是做 ACM 也好，平时做事也罢，有一个非常重要的环节，那就是 Programming，这可不是 Programmer 相关的单词，而是 Dynamic Programming 中的 Programming，它是规划的意思，相同的一个 ACM 问题，如果你在上机前多花 5 分钟规划，你可以在 coding 和 debug 阶段省下很多的时间。记住，理想的解题过程应该是 reading-thinking-programming-coding-debug-submit，甚至对代码能力好的人来说，debug 这个环节可以省略。\n 克服对新知识的抵触心理\n第一年训练结束之后，队伍解散，我也开始新知识的储备，那时候对 DP 有着很大的抵触心理，后来在寒假逼着自己看了几篇 DP 优化相关的论文，结果虽说不上喜欢上了 DP，至少对 DP 的抵触心理小了很多。世上不存在什么不可能学会的知识，我们要做的仅仅是培养兴趣而已。\n 代码越短越好 or 写的代码越长说明自己越牛？\n我想一定的不少人觉得代码越短越好，或者代码越长说明自己越强。很明显这种想法并没有任何的科学性。coding 是一门艺术，拿 coding 和写文章作对比，可谓大同小异，作为一个团队的成员，我们要做的是使自己的 文章 可读性更强，而不是刻意地去压缩、扩充自己的代码。解题的过程，个人能力差异最小的就是 coding 在过程，差异最大的是 thking 和 debug 的时间。代码比别人的长了点儿，coding 多花了时间，但是 debug 的时候队友可以给自己更多的帮助不是么？\n 为什么我投入了这么多却没有得到回报？\n很多人，包括我自己，都遇到过这类问题。当遇到这类问题的时候，有的人会选择退却，有的人会选择反思，当然也有人选择不管不问，使用以往的方式继续下去。遇到这类问题，我们要做的事就是找到问题的根源，我想最大的一个原因，就是不够专注。何谓专注？专注不是一整天只吃一顿饭，即使逃课也要训练，专注也不是花大量的时间，只学了本来一个小时就可以学会的知识。高中的时候，很多同学问我为什么做作业比他们快，其实高中的时候效率高的原因仅仅是不在做作业的时候听音乐而已（我发现自己没法做到那样的状态了，训练的时候没法做到原来那么专注，有点可惜）。在训练的时候，我习惯把电脑静音，拔去散热器的电源，我不希望散热底座风扇转动的声音影响自己的思考，虽然我的思维很慢。有的人（有时候我也有这样的毛病）喜欢在训练还没结束的时候就在群里得瑟，或者在训练一半的时候发现剩下的题目自己肯定没戏，就放弃了。我觉得这都不是一个好的习惯，养成好的习惯可以让你有更大的成就的。\n 谈谈 ACM 的学习氛围\n我常见到很多人在群里抱怨题目看不懂，当然也不排除这些题目描述真的写得很渣的原因。如果一套题，特别是好题，你发现自己很多题都看不懂意思的话，那只能说你有点浮躁了。\n虽然不愿意这么说，但这却是事实，做 ACM 最需要的是一个氛围，一个平常十分融洽，训练的时候却严肃的氛围。其实我不喜欢训练的时候开玩笑，以前不少老队员和我说：何老师，你的表情太呆板啦，和我们一样嘻嘻哈哈的多好。我可能习惯了，平时都不会嘻嘻哈哈的，但是我并不反对平时没有训练的时候大家活跃一点，毕竟大家是在一个集体之中，需要更多的沟通交流。我也不反对平时一起玩游戏、一起听音乐、杀人、三国杀，娱乐活动是生活不可缺少的一部分，这我还是知道的。但是在训练的时候得瑟、逛社交网络、在 QQ 空间里瞎逛就不可取了。\n凡事都不会是绝对公平的，不管在什么情况下，不公平的事可谓是屡见不鲜了。copy 他人的代码（或者自己以前写的代码），太过于 乐于助人 等等。我想很多人在前期会有想不出来马上就看题解的习惯，慢慢演变成了这样，当他意识到事情的严重性的时候，却很难改正了。甚至有人并没有意识到这里面对自己的危害有多深，而到了最后的赛场才后悔莫及。\n SCL 到底是好是坏？\nSCL，大部分人称其为 模板 模块 标程 等，对很多人来说，可能是比赛场上必不可少的 武器 吧？不过我的观点是能不用就不用，大多数人使用 SCL 的原因是其中的代码并不是他自己实现的，有可能是 google 的，或者其他队员、学长实现的。我并不反对这种行为，但是比赛比的就是代码实现能力，至少，你要对这份代码相当熟悉才行。\n之所以不推荐用 SCL，主要的原因是它会阻碍代码能力的提升，习惯用 SCL 之后，你会发现自己写代码越来越容易写挂，1Y 率大幅度下降，随着自己学的东西越来越多，积累的 SCL 越多，代码能力就下降的越快。SCL 仅仅是为了正式比赛心安的一个工具，而不是训练的工具。\n ACM 与大学生活\n作为 ACMer，我认为 ACM 给我带来最多的好处，那就是充实了我的大学生活，让我喜欢上了看课外书。看书不能囫囵吞枣，否则你可能连原理都掌握不了。此外，最重要的是实践，一个新的算法，要自己试着实现。当然，实现之前一定要理清步骤，另一方面，我们还需要通过和他人的交流，让自己对某方面的知识的理解更进一步。\n还有一个和我们大学生活相关的话题，那就是 GPA。很多人因为 ACM 把学业扔了而挂了很多科，这可以说他们把时间全花在 ACM 上了么？当然不能。曾经问过学长类似的问题，得到的答案就是 GPA 相比 ACM 来说，公司虽然看中能力，但是更看中基础课的掌握程度，而 GPA 就是表现这个的最方便的方式。GPA 说明了一个人对待学习的态度，也表现了一个人的学习能力。总而言之，我的建议地能不挂科就不挂科，毕竟挂科后要花更多时间去折腾自己的学业。\n最后，想提及一下作息时间的问题，大一大二作息时间一天比一天混乱，特别是周末或者课少的时候，本人熟悉的 ACMer 中，有 90% 的是夜猫子，每天 2、3 点睡觉都是常事，而这样的作息时间导致了白天精神萎靡的情况。最近一直 11 点睡 7 点起，上课没有犯困过，感觉良好。\n不管怎么说，既然要把 ACM 作为自己大学生活的全部，那么就认真地投入吧，好好享受这个过程才是最关键的不是么？\n","categories":["杂谈"],"tags":["ICPC","杂谈"]},{"title":"HDU3449 Consumer 条件背包 DP","url":"/2010/10/20/obsidian/caa476da-ce09-4426-a984-2f0d6e5920cf/","content":"这道题应该是背包问题里堪称经典的问题了，表示刚开始学 DP，这类问题也很快弄懂了。\n题目大意\n给你一些分组，每组物品放在一个盒子里，每组物品都有几种物品，有自己的价格 ccc 和价值 vvv，现在要买一个物品时，要买它对应的盒子，盒子的价格是 ppp，问你花一定的钱最多买到的物品价值是多少。\n\n这类问题要用到两个数组，dp[0][i]dp[0][i]dp[0][i] 表示 iii 块钱可以买到的最大价值，dp[1][i]dp[1][i]dp[1][i] 表示考虑到当前盒子时，iii 块钱可以买到的最大价值，首先 dp[0]dp[0]dp[0] 置为 000，枚举全部的盒子，dp[1]dp[1]dp[1] 置为 −∞-\\infty−∞ 表示买不到，更新的转移可以从 dp[0]dp[0]dp[0] 转移也可以从 dp[1]dp[1]dp[1] 转移，从 dp[0]dp[0]dp[0] 转移表示你还没有买盒子，要附加上盒子的价格，dp[1]dp[1]dp[1] 表示你买过盒子了，就直接转移就可以了，转移方程如下:\ndp[1][k]=max⁡{dp[1][k]dp[1][k−c[i][j]]+v[i][j]dp[0][k−c[i][j]−p[i]]+v[i][j]dp[1][k] = \\max \\begin{cases}\ndp[1][k] \\\\\ndp[1][k-c[i][j]]+v[i][j] \\\\\ndp[0][k-c[i][j]-p[i]]+v[i][j]\n\\end{cases}\ndp[1][k]=max⎩⎪⎪⎨⎪⎪⎧​dp[1][k]dp[1][k−c[i][j]]+v[i][j]dp[0][k−c[i][j]−p[i]]+v[i][j]​\n注意每次 dp[1]dp[1]dp[1] 的置 −∞-\\infty−∞ 操作，以及每次枚举完当前盒子后用 dp[1]dp[1]dp[1] 更新 dp[0]dp[0]dp[0] 的值。\ndp[0][j]=max⁡(dp[0][j],dp[1][j])dp[0][j]=\\max(dp[0][j],dp[1][j])\ndp[0][j]=max(dp[0][j],dp[1][j])\n\n我的完整代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int oo = 0x3f3f3f3f;int dp[2][100100];int p[60], m[60];int c[60][12], v[60][12];int main() {  int n, w;  while (~scanf(\"%d%d\", &amp;n, &amp;w)) {    for (int i = 0; i &lt; n; i++) {      scanf(\"%d%d\", &amp;p[i], &amp;m[i]);      for (int j = 0; j &lt; m[i]; j++) {        scanf(\"%d%d\", &amp;c[i][j], &amp;v[i][j]);      }    }    for (int i = 0; i &lt;= w; i++) {      dp[0][i] = 0;    }    for (int i = 0; i &lt; n; i++) {      for (int j = 0; j &lt;= w; j++) {        dp[1][j] = -oo;      }      for (int j = 0; j &lt; m[i]; j++) {        for (int k = w; k &gt;= c[i][j]; k--) {          if (dp[1][k - c[i][j]] &gt;= 0 &amp;&amp;              dp[1][k] &lt; dp[1][k - c[i][j]] + v[i][j])            dp[1][k] = dp[1][k - c[i][j]] + v[i][j];          if (k &gt;= c[i][j] + p[i])            dp[1][k] = max(dp[1][k], dp[0][k - c[i][j] - p[i]] + v[i][j]);        }      }      for (int j = 0; j &lt;= w; j++) {        dp[0][j] = max(dp[0][j], dp[1][j]);      }    }    printf(\"%d\\n\", *max_element(dp[0], dp[0] + w + 1));  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"我误删了我的日常工作目录 - 记一次命令行误操作","url":"/2019/12/18/obsidian/cca8bce5-c791-4f4d-949f-90417eb888a3/","content":"某天做日常工作的时候遇到了一个小问题，有一个在远程的开发机（不是任何的部署环境）中的测试不能通过。因为相同的测试在本地是可以通过的，于是我打算将远程的代码目录直接通过 rsync 同步到本地来二次检查测试是不是由于不同内核导致，还是由于测试顺序随机导致的。\n\n我在自己的 group 目录，执行了如下的指令将远程的某个 project 子目录同步到当前的 project 目录下：\nrsync --delete -e ssh -v -r remote-development-server:~/group/project/ .\n当同步完了之后，ls 发现所有的文件被同步到当前目录而不是 project 下，而且由于加了 --delete 参数，我的当前分组目录下的子目录全部被删除了。这次命令之后，我从记忆中罗列了一下在本地开发环境的损失：\n\n若干的本地配置被删除，包括比较敏感的不会被 check in 到 repostiory 的文件，和若干 .dir-locals.el 配置。\n两个比较常用的本地脚本项目（由于只是个人使用，没有做远程备份或者是其它位置的备份）。\n（可能存在的）一些微小的本地项目改动，不过由于个人有随手 commit 并同步到远程的习惯，有的话也不会是特别大的改动。\n\n由于本地目前没有做过于小时间范围内的数据自动同步，基本上就只能重新 clone 远程的代码了。这件事发生之后，我就每次执行命令行的时候都有点疑神疑鬼的，感觉需要一个 NFS 才能拯救我。为了防止命令行误操作导致不可预知的数据损失，我还特地看了一下 rsync 命令的几个比较有特点的同步表现：\n第一种是，如果源位置的目录是没有以 / 结尾的，那么包括源目录本身会被复制到目标目录，比如\nrsync -v -r source . # copy to ./sourcersync -v -r source destination # copy to destination/source\n另外一种是，源位置的目录后加了 /，表示这个目录内部的文件复制到目标目录（不包括源目录自己），比如\nrsync -v -r source/ . # copy to ./rsync -v -r source/ destination # copy to destination/\n这种情况下，相当于把 source 目录中的文件复制到目标目录，如果你加了 --delete 参数，那么目标目录下的无关文件和目录都会被删除。\n至于为什么我会删除掉了的工作目录，是因为我用了 oh-my-zsh，虽然我的配置会自动删除目录之后的 /，但是我一时脑抽，看自动删除就加回去了，就导致了这个悲剧发生。关于平时用 rsync 的注意点，建议少加 --delete 参数，或者用之前先 --dry-run 一下，另外，用第一种做法可以防止类似的事发生，如果你想要将 source/folder 备份到 destination/folder，建议在 destination 目录执行第一种命令。\n","categories":["development"],"tags":["软件开发/版本控制","运维/故障排查"]},{"title":"通过私有 Git 仓库同步 IntelliJ 的配置","url":"/2020/01/05/obsidian/ccb2651e-665b-4051-a04b-1a123d64e91d/","content":"平时在用 IntelliJ 开发 Java 和 Kotlin 项目的时候经常会遇到要在多台电脑上同步自己的 IDE 配置的情况，这里的 IDE 配置不仅仅包括 UI 布局、字体等，还包括快捷键、插件列表、文件关联等。我们可以用自己在 git 服务器上的一个私有 git 仓库来同步我们的配置。\n\n平时可以用的比较稳定的是 github，如果在国内需要考虑速度的话，可以用 gitee。如果用非 github 的平台的话，要注意用 PEM 格式的私钥，当然可以统一用 PEM 格式的私钥来专门做同步配置的事：\nsh-keygen -m PEM -C \"&lt;user-mail&gt;\" -f github-intellij-sync\n生成私钥之后在 .ssh/config 中添加平台的私钥，然后通过 File -&gt; Settings Repository 就可以同步配置到云端了。\nHost github.com    IdentityFile ~/.ssh/github-intellij-sync\n","categories":["development"],"tags":["软件开发/版本控制","软件开发/IDE配置"]},{"title":"Supports MathJax in angular2 with TypeScript","url":"/2016/05/31/obsidian/cd2feb08-60f6-41cc-8725-52aa87e7ea14/","content":"If we use data binding through Angular2 and doing rendering on UI side, we may find that the MathJax text is not rendered. That’s because we need to re-render the string value every time we change it.\nThere is a simple module example to handle with, which use event handler binded and will be trigered when value changed.\n\nimport { Directive, ElementRef, OnChanges, Input } from \"@angular/core\";declare var MathJax: {  Hub: {    Queue: (param: Object[]) =&gt; void;  };};@Directive({ selector: \"[mathJax]\" })export class MJD implements OnChanges {  @Input(\"mathJax\") private value: string = \"\";  constructor(private element: ElementRef) {}  ngOnChanges() {    this.element.nativeElement.innerHTML = this.value;    MathJax.Hub.Queue([\"Typeset\", MathJax.Hub, this.element.nativeElement]);  }}\nOn the template HTML file, we can use this directive like this:\n&lt;div class=\"math-element\" id=\"equation\" [mathJax]=\"equationTexString\"&gt;&lt;/div&gt;\nOn the other hand, remember add the MJD directive into the component directive list:\n@Component({  selector: \"equation-component\",  directives: [MJD],})export class EquationComponent {  private equationTexString: string = \"\";}\n","categories":["development"],"tags":["软件开发","NodeJS"]},{"title":"POJ1753 位压缩 BFS","url":"/2010/07/31/obsidian/d08255b6-071c-41dd-ae8d-58dca2a65bab/","content":"在很多情况下，我们可以用一个整数或者多个整数把多变的状态压缩，这样有利于空间上的优化，虽然在代码量上并不能得到多少的好处，但是遇到数据量大的时候还是可以有一定的效果的。\n以 POJ1753 为例，这题是推荐题中的简单题了，一般的搜索完全可以过，甚至不用搜索。。。\n\n我的方法是把 BFS 的状态压缩，由于每个牌面就 444 乘以 444，也就是 161616 个格子，每个格子只有黑白两种状态，用一个 int 型数就可以装下整个状态。\n将牌面从上到下从左到右编号 000 到 151515，这样 int 型数从低位开始的第 i 位标记为 000 或者 111，分别表示白色和黑色，用位运算进行状态转移。\n看下我的结构体：\nstruct Node {  int code;  int table;  int depth;  int last;} start;\n\ncode 表示这个状态中各个格子是否被翻过，对应位如果为 111，则表示被按过，这种题目有一个显著的特点，那就是一个格子之多翻一次，否则和没翻是一个效果，这样我们记录了格子后就可以知道哪些格子被我们翻过，那些没有。\ntable 表示状态牌面的情况，第 i 位如果为 1 表示这位是黑色，否则为白色。\ndepth 表示从初状态到此状态的步数。\nlast 表示装移到这个状态翻转的格子编号，这样，我们每次都从最后一个翻转的格子之后的格子开始搜索，不会重复搜索。\n\n另外，位压缩之后，写一个状态转移函数 hash()，用于转移状态。\nint hash(int table, int op) {  int st;  st = (1 &lt;&lt; op);  if (op % 4 &gt; 0) st |= (1 &lt;&lt; (op - 1));  if (op % 4 &lt; 3) st |= (1 &lt;&lt; (op + 1));  if (op / 4 &gt; 0) st |= (1 &lt;&lt; (op - 4));  if (op / 4 &lt; 3) st |= (1 &lt;&lt; (op + 4));  return (table ^ st);}\n其中 tabletabletable 参数就是需要变换的牌面，opopop 代表翻转的格子的编号，函数中的 st 变量表示需要翻转的位，如果第 i 位需要翻转，则这位就是 111，否则为 000，首先第 opopop 位一定是需要翻转的，然后四个 if 判断格子的位置，当格子在最左边的时候，opmod  4op \\mod 4opmod4 等于 000，最上边的时候，op4\\frac{op}{4}4op​ 等于 000，以此类推，当格子不是最左边的时候，要对其左边 (op−1)(op-1)(op−1) 位置的格子进行翻转，因此更新 ststst 变量第 (op−1)(op-1)(op−1) 位为 111，其他的类似。\n在 BFS 函数中，末状态就是 151515 个 000 或者 161616 个 000 (216−12^{16}-1216−1)，这样直接用判断整数是否相等就可以搞定。\n主程序完整代码如下：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct Node {  int code;  int table;  int depth;  int last;} start;int hash(int table, int op) {  int st;  st = (1 &lt;&lt; op);  if (op % 4 &gt; 0) st |= (1 &lt;&lt; (op - 1));  if (op % 4 &lt; 3) st |= (1 &lt;&lt; (op + 1));  if (op / 4 &gt; 0) st |= (1 &lt;&lt; (op - 4));  if (op / 4 &lt; 3) st |= (1 &lt;&lt; (op + 4));  return (table ^ st);}int bfs() {  Node node, next;  queue&lt;Node&gt; q;  node.code = 0;  node.table = start.table;  node.depth = 0;  node.last = -1;  if (node.table == 0 || node.table == ((1 &lt;&lt; 16) - 1)) return 0;  q.push(node);  while (!q.empty()) {    node = q.front();    q.pop();    for (int i = node.last + 1; i &lt; 16; i++) {      if ((node.code &amp; (1 &lt;&lt; i)) == 0) {        next.code = (node.code | (1 &lt;&lt; i));        next.table = hash(node.table, i);        next.depth = node.depth + 1;        next.last = i;        if (next.table == 0 || next.table == ((1 &lt;&lt; 16) - 1)) return next.depth;        q.push(next);      }    }  }  return -1;}int main() {  char str[10];  start.table = 0;  for (int i = 0; i &lt; 4; i++) {    gets(str);    for (int j = 0; j &lt; 4; j++) {      if (str[j] == 'b') {        start.table |= (1 &lt;&lt; (i * 4 + j));      }    }  }  int ret = bfs();  if (ret == -1)    printf(\"Impossible\\n\");  else    printf(\"%d\\n\", ret);  return 0;}\n反思：这题 BFS 位压缩其实还可以优化，code 和 last 的作用是一样的，因为每次都从最后翻转的那位的后一位开始搜索，不用判断 code 变量，可以考虑将结构体变量再去掉一个。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"MacOS 下用 Homebrew 配置 jekyll","url":"/2015/06/14/obsidian/d58ac588-efef-4682-9277-ff51d990731d/","content":"本文描述一个简单的在 Mac OS 系统中使用 Homebrew 配置 Jekyll 的方式。\n\nJekyll 有两个比较重要的依赖，一个是 Ruby ，一个是 libffi ，一般来说我们可以用 Homebrew 直接搞定它们\nbrew install ruby libffiruby -v\n然后就在安装 jekyll 的时候，指定好 include path 了，注意这里不能用\nexport CPATH=~/homebrew/Cellar/libffi/&lt;ffi-version&gt;/lib/libffi-&lt;ffi-version&gt;/include/gem install jekyll\n因为 brew install 会新打开一个 shell 进程，我们可以用\nCPATH=~/homebrew/Cellar/libffi/&lt;ffi-version&gt;/lib/libffi-&lt;ffi-version&gt;/include/ gem install jekyll\n这样可以安装成功\n","categories":["development"],"tags":["jekyll","macos","homebrew"]},{"title":"配置 Rabbit MQ 全局的消息过期时间","url":"/2024/01/04/obsidian/d5f6f84d-1d35-4221-8b72-9ab0cb4bdbbc/","content":"在我们支持第三方系统对接的时候，消息队列往往是一个比较常用的推送解决方案，但是为了防止第三方系统不接收消息，或者保证消息的有效性，我们会考虑为队列添加 TTL 属性，来使得消息自动过期。\n注意\n不是所有的队列，或者所有的业务都需要配置过期时间，如果这个队列是由我们自己系统做管控，而且要保证它们都被第三方系统消费，这种情况下不能有自动过期策略，或者有其它的诸如死信队列这样的机制。\n\n\n 根据规则配置队列的自动过期时间\n根据官方文档 [1]，我们可以通过 Set-Policy 机制，为不同的队列配置不同的 ttl policy，以下是一个最简单的例子：\nrabbitmqctl set_policy TTL \".*\" '{\"message-ttl\":60000}' --apply-to queues\n以上命令中，我们把所有队列都配置上了自动过期时间为 60 秒。\n\n\n\nDefine Queue TTL for Queues Using a Policy ↩︎\n\n\n\n","categories":["development"],"tags":["软件开发/消息队列"]},{"title":"Codeforces Beta Round #28 B 题","url":"/2010/09/18/obsidian/da478d0e-24a1-47d4-add4-e6b0cb05d41c/","content":"今天悲剧的第一题没看懂题，好吧，不会做，B 题最简单，放出来。\n这题的思路实际上是并查集，先定义一个数组 ststst 表示现在的状态，目标状态是 1，2，3，⋯，n1，2，3，\\cdots，n1，2，3，⋯，n，那么，每次查找 iii 和 i+v[i]i+v[i]i+v[i] 和 i−v[i]i-v[i]i−v[i] 三个数，把他们合并，表示他们可以互相转换，那么用 O(n)O(n)O(n) 的复杂度扫一遍，可以把全部的元素属于什么集合预处理出来，最后只要判断 st[i]st[i]st[i] 和 iii 是不是一个集合里的就可以了。\n今天无聊复习 C++，封装了个并查集的类，刚好用上。。。\n\n我的代码：\n#include &lt;cstdio&gt;using namespace std;class Set { private:  const static int maxsize = 110000;  int p[maxsize];  int rank[maxsize];  int size;  void Link(int x, int y);  void init(); public:  Set();  Set(const int&amp; n);  Set(Set&amp; st);  int Find(int x);  void Union(int x, int y);  bool Same(int x, int y);  bool Union2(int x, int y);  bool IsRoot(int x);  void Reset();  void Reset(const int&amp; n);  int Size();};void Set::Link(int x, int y) {  if (rank[x] &gt; rank[y])    p[y] = x;  else {    p[x] = y;    if (rank[x] == rank[y]) rank[y]++;  }}int Set::Size() { return size; }void Set::init() {  for (int i = 1; i &lt;= size; i++) {    p[i] = i;    rank[i] = 0;  }}Set::Set() {  size = maxsize - 1;  init();}Set::Set(const int&amp; n) {  size = n;  if (n &lt; maxsize) init();}Set::Set(Set&amp; st) {  size = st.size;  for (int i = 1; i &lt;= size; i++) {    p[i] = st.p[i];    rank[i] = st.rank[i];  }}int Set::Find(int x) {  if (!IsRoot(x)) p[x] = Find(p[x]);  return p[x];}void Set::Union(int x, int y) {  int px = Find(x);  int py = Find(y);  if (px != py) {    Link(px, py);  }}bool Set::Same(int x, int y) { return Find(x) == Find(y); }bool Set::Union2(int x, int y) {  int px = Find(x);  int py = Find(y);  if (px != py) {    Link(px, py);    return false;  } else    return true;}bool Set::IsRoot(int x) { return p[x] == x; }void Set::Reset() {  size = maxsize - 1;  init();}void Set::Reset(const int&amp; n) {  size = n;  if (n &lt; maxsize) init();}int main() {  int n;  int a[110];  int v;  scanf(\"%d\", &amp;n);  Set st(n);  for (int i = 1; i &lt;= n; i++) {    scanf(\"%d\", &amp;a[i]);  }  for (int i = 1; i &lt;= n; i++) {    scanf(\"%d\", &amp;v);    if (i + v &lt;= n) st.Union(a[i], a[i + v]);    if (i - v &gt;= 1) st.Union(a[i], a[i - v]);  }  for (int i = 1; i &lt;= n; i++) {    if (!st.Same(i, a[i])) {      puts(\"NO\");      return 0;    }  }  puts(\"YES\");  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"POJ3468 线段树的区间操作","url":"/2010/08/01/obsidian/ddcf275f-5cb0-4677-abd2-207b388dead7/","content":"今晚做这题，因为使用 int 型贡献了不少的 WA，最后改成 long long 就过了。这题一看就可以明显注意到使用线段树来写了，原来不是很经常写更新区间的问题，在此对更新区间查找区间的题目进行一下总结。\n更新区间的函数，注意记录一个增量 addaddadd 来表示这个区间从它的父亲结点继承下来的增量，当我们找到一个区间时候，就把增量全部转化为 sumsumsum，也就是这个区间的总和，然后对 addaddadd 进行继承操作，最后清空 addaddadd，之后就是三种情况的二分了。\n对于求和函数，类似的，我们要先处理继承问题，然后二分查找结果，最后返回。\n更新区间查找区间的题目一般比较烦，需要记录父亲结点继承的增量，所以我们把 seg[k]seg[k]seg[k] 对应的区间的边界也加入到结点信息中，这样可以大大减少函数的参数。\n\n我的代码如下：\n#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;typedef long long LL;const int MAX = 100100;struct Node {  int low, high;  LL sum;  LL add;} seg[4 * MAX];int a[MAX];void init(int k, int low, int high);void update(int k, int a, int b, int v);LL sum(int k, int a, int b);int main() {  int n, q;  char op[2];  int x, y, v;  scanf(\"%d%d\", &amp;n, &amp;q);  for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;a[i]);  init(1, 1, n);  for (int i = 0; i &lt; q; i++) {    scanf(\"%s\", op);    if (op[0] == 'Q') {      scanf(\"%d%d\", &amp;x, &amp;y);      printf(\"%lld\\n\", sum(1, x, y));    } else if (op[0] == 'C') {      scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;v);      update(1, x, y, v);    }  }  return 0;}void init(int k, int low, int high) {  seg[k].add = 0;  seg[k].low = low;  seg[k].high = high;  if (low == high) {    seg[k].sum = a[low];    return;  }  int mid = (low + high) &gt;&gt; 1;  init(2 * k, low, mid);  init(2 * k + 1, mid + 1, high);  seg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;}void update(int k, int a, int b, int v) {  seg[k].sum += (seg[k].high - seg[k].low + 1) * seg[k].add;  if (seg[k].low != seg[k].high) {    seg[2 * k].add += seg[k].add;    seg[2 * k + 1].add += seg[k].add;  }  seg[k].add = 0;  if (a &gt; seg[k].high || b &lt; seg[k].low) return;  if (a &lt;= seg[k].low &amp;&amp; b &gt;= seg[k].high) {    seg[k].sum += (seg[k].high - seg[k].low + 1) * v;    if (seg[k].low != seg[k].high) {      seg[2 * k].add += v;      seg[2 * k + 1].add += v;    }    return;  }  update(2 * k, a, b, v);  update(2 * k + 1, a, b, v);  seg[k].sum = seg[2 * k].sum + seg[2 * k + 1].sum;}LL sum(int k, int a, int b) {  seg[k].sum += (seg[k].high - seg[k].low + 1) * seg[k].add;  if (seg[k].low != seg[k].high) {    seg[2 * k].add += seg[k].add;    seg[2 * k + 1].add += seg[k].add;  }  seg[k].add = 0;  if (a &gt; seg[k].high || b &lt; seg[k].low) return 0;  if (a &lt;= seg[k].low &amp;&amp; b &gt;= seg[k].high) return seg[k].sum;  LL k1 = sum(2 * k, a, b);  LL k2 = sum(2 * k + 1, a, b);  return k1 + k2;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"SRM477 DIV2 500","url":"/2010/07/29/obsidian/de1d9334-f9a8-4ace-a289-9c76a5b40b92/","content":"这题要转换一下思维来做，从第一行开始，枚举同一行相邻的两个格子，如果不是同一类型 (即不同时为水或者同时为陆地)，就判定这条边是合法的。\n对于剩余的边，从第二行开始，判断每个格子上方的边是否符合处于两种类型格子之间即可，这样就可以不重复地把全部的边都检查完，由于边缘的边都不算，也让我们很方便的不需要考虑太多的边界条件。\n\nint beachLength(vector&lt;string&gt; v) {  int n = v.size();  int len[100];  int ret = 0;  for (int i = 0; i &lt; n; i++) {    len[i] = v[i].length();    for (int j = 0; j &lt; len[i]; j++) {      if ((j != 0) &amp;&amp; (v[i][j] != v[i][j - 1])) ret++;      if (i == 0) continue;      if (i % 2 == 0) {        if (((j - 1 &gt;= 0) &amp;&amp; (j - 1 &lt; len[i - 1])) &amp;&amp;            (v[i][j] != v[i - 1][j - 1]))          ret++;        if (((j &gt;= 0) &amp;&amp; (j &lt; len[i - 1])) &amp;&amp; (v[i][j] != v[i - 1][j])) ret++;      } else {        if (((j &gt;= 0) &amp;&amp; (j &lt; len[i - 1])) &amp;&amp; (v[i][j] != v[i - 1][j])) ret++;        if (((j + 1 &gt;= 0) &amp;&amp; (j + 1 &lt; len[i - 1])) &amp;&amp;            (v[i][j] != v[i - 1][j + 1]))          ret++;      }    }  }  return ret;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"SRM151 DIV2","url":"/2010/07/29/obsidian/deeddae1-9de0-45b5-a0e8-bb3c07c2eebc/","content":"最近开始拍 TC 的陈题，这应该算是第二套 AK 的题目了吧，题目不是很难，很适合练习拍代码的速度。。。\n\n 250 分：Prefix Code\n这题单纯的暴力过的，枚举第 iii 个串是不是其他串的前缀，利用一个函数直接判定，这样的时间复杂度为 O(n2)O(n^2)O(n2) 对于 n≤50n \\leq 50n≤50 的数据来说完全没有问题。\nclass PrefixCode { public:  bool check(string str, string sub) {    int len = str.length();    int sublen = sub.length();    if (sublen &gt; len) return false;    if (str.substr(0, sublen) == sub) return true;    return false;  }  string isOne(vector&lt;string&gt; words) {    int n = words.size();    string ret;    char str[100];    for (int i = 0; i &lt; n; i++) {      for (int j = 0; j &lt; n; j++) {        if (i == j) continue;        if (check(words[j], words[i])) {          ret = \"No, \";          sprintf(str, \"%d\", i);          ret += str;          return ret;        }      }    }    ret = \"Yes\";    return ret;  }}；\n 500 分：Birthday\n判断当前时间之后第一个过生日的人的日期，简单的排序即可，注意人名都是字母，用 0000 表示当前的时间对应的人名，这样把全部的人加上这个哨兵总共 n+1n+1n+1 个元素进行排序，最后输出哨兵的后一位元素，查找是线性的查找，总共的复杂度为 O(nlogn)O(nlogn)O(nlogn)，即排序的复杂度。\n注意当哨兵是最后一个的时候输出第一个元素，这里取模来直接达到这个效果。\nstruct Node {  string name;  int month;  int day;  bool operator&lt;(const Node&amp; node) const {    if (month != node.month)      return month &lt; node.month;    else      return day &lt; node.day;  }};class Birthday { public:  string getNext(string date, vector&lt;string&gt; bir) {    Node node;    vector&lt;Node&gt; v;    char str[100];    int n;    int pos;    string a;    v.clear();    node.name = \"0000\";    node.month = (date[0] - '0') * 10 + date[1] - '0';    node.day = (date[3] - '0') * 10 + date[4] - '0';    v.push_back(node);    n = bir.size();    for (int i = 0; i &lt; n; i++) {      int len = bir[i].length();      node.month = (bir[i][0] - '0') * 10 + bir[i][1] - '0';      node.day = (bir[i][3] - '0') * 10 + bir[i][4] - '0';      node.name = bir[i].substr(6, len - 6);      v.push_back(node);    }    sort(v.begin(), v.end());    for (int i = 0; i &lt; n + 1; i++)      if (v[i].name == \"0000\") {        pos = i;        break;      }    pos = (pos + 1) % v.size();    sprintf(str, \"%02d/%02d\", v[pos].month, v[pos].day);    a = str;    return a;  }}；\n 1000 分：Merge Sort\n叫你模拟归并排序的过程，输出比较次数，直接手写归并排序，遇到比较就计数器加 1，模拟完就返回结果，注意题目要求的划分方式和合并方式和我们一般写的代码有差距，如果两个子数组的个数不同，那么要求前一个的元素个数小于后面的元素个数，当两个子数组的头元素相等的时候，将两个元素都放入父亲结点对应的数组，这样比较次数为 1 次，而不是先随便放入一个，剩下一个和后面的元素比较。\nclass MergeSort { public:  int ret;  int a[100];  void Merge(int p, int q, int r) {    int n1 = q - p + 1;    int n2 = r - q;    vector&lt;int&gt; left;    vector&lt;int&gt; right;    for (int i = 0; i &lt; n1; i++) left.push_back(a[p + i]);    for (int j = 0; j &lt; n2; j++) right.push_back(a[q + j + 1]);    int i = 0, j = 0, k = p;    while (i &lt; n1 &amp;&amp; j &lt; n2) {      ret++;      if (left[i] &lt; right[j]) {        a[k++] = left[i];        i++;      } else if (left[i] == right[j]) {        a[k++] = left[i];        a[k++] = right[j];        i++;        j++;      } else {        a[k++] = right[j];        j++;      }    }    if (i == n1) {      for (; j &lt; n2; j++) a[k++] = right[j];    } else {      for (; i &lt; n1; i++) a[k++] = left[i];    }  }  void Sort(int p, int r) {    if (p &lt; r) {      int q = (p + r) &gt;&gt; 1;      int n1 = q - p + 1;      int n2 = r - q;      if (n1 &gt; n2) q--;      Sort(p, q);      Sort(q + 1, r);      Merge(p, q, r);    }  }  int howManyComparisons(vector&lt;int&gt; num) {    int len = num.size();    ret = 0;    for (int i = 0; i &lt; len; i++) a[i] = num[i];    Sort(0, len - 1);    return ret;  }}；\n 总结\n这套题适合用于提高编码能力，要求能在最短的时间内模拟出结果，三题应该都算是模拟题，第二题的排序可以用系统库函数直接处理，无需手写。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"SRM479DIV2 题解","url":"/2010/08/15/obsidian/e3f99066-05b8-4d67-9d1f-2bf7c4142e47/","content":"昨晚 (可以算是今天凌晨) 的 SRM 479，题目的难度可以说不是很难，三题我都在这里简单地说下思路：\n\n第一题：比较水的题目，从前向后加，如果总和大于 fuelfuelfuel 了，那么跳出，对应的 iii 就是答案。\n代码：\nint find(vector&lt;int&gt; flights, int fuel) {  int ret = 0;  int num;  int n = flights.size();  num = n;  for (int i = 0; i &lt; n; i++) {    if (ret + flights[i] &lt;= fuel)      ret += flights[i];    else {      num = i;      break;    }  }  return num;}\n第二题：简单的贪心，对 teateatea 和 coffeecoffeecoffee 分别计算，每次都走到最远的没有服务过的人那里，这样花时最少，用另外的数组来记录要 coffeecoffeecoffee 的旅客编号，因为要从大到小，所以 for 循环从 n−1n-1n−1 开始，另外要对向量 teateatea 进行排序，从大到小。\n注意乘客服务的时间可以直接计算，倒饮品的时间也可以直接算，剩下的就是计算走的时间了。\n代码：\nint find(int n, vector&lt;int&gt; tea) {  int nTea = tea.size();  int nCof = 0;  int ret = 4 * n;  int cof[1005];  bool type[1005] = {0};  for (int i = 0; i &lt; nTea; i++) type[tea[i]] = true;  for (int i = n; i &gt; 0; i--)    if (!type[i]) {      cof[nCof++] = i;    }  if (nTea % 7)    ret += (nTea / 7 + 1) * 47;  else    ret += nTea / 7 * 47;  if (nCof % 7)    ret += (nCof / 7 + 1) * 47;  else    ret += nCof / 7 * 47;  sort(tea.begin(), tea.end(), greater&lt;int&gt;());  for (int i = 0; i &lt; nTea; i += 7) {    ret += 2 * tea[i];  }  for (int i = 0; i &lt; nCof; i += 7) {    ret += 2 * cof[i];  }  return ret;}\n第三题，比较烦的题，因为 nnn 是小于等于 888 的，这样，我们可以先用 dfs 构造出最后乘客的可能顺序，然后进行模拟，计算出指定序下需要的时间，当然，但这个时间超过了 boardingTimeboardingTimeboardingTime 的时候，是无效的，直接返回，不用计算出确切的时间，我的做法是当时间大于 boardingTime+5boardingTime+5boardingTime+5 的时候就直接掐掉函数运行，直接 break。\n另外，要用到许多辅助数组进行状态的维护，tabletabletable 数组用来模拟，tmptmptmp 数组用来保存乘客的顺序，用于 dfs。\n代码比较长：\nvoid Set() {  for (int i = n + 1; i &lt;= 2 * n; i++) {    if (tt[i] &gt; 0) {      tt[i]--;      if (tt[i] == 0) {        table[i] = 0;        done++;      }    }  }}int solve() {  memset(tt, -1, sizeof(tt));  done = 0;  int ans = 0;  while (done &lt; n) {    Set();    ans++;    if (ans &gt; maxtime + 5) break;    for (int i = 2 * n; i &gt; 0; i--) {      if (table[i]) {        if (i == table[i] + n) {          if (tt[i] &lt; 0)            tt[i] = 74;          else            continue;        } else {          if (table[i + 1] == 0) {            table[i + 1] = table[i];            table[i] = 0;          }        }      }    }  }  return ans - 1;}void dfs(int k) {  if (k &gt; n) {    for (int i = n + 1; i &lt;= 2 * n; i++) tmp[i] = 0;    for (int i = 1; i &lt;= 2 * n; i++) table[i] = tmp[i];    int ans = solve();    if (ans &lt;= maxtime) ret++;  } else {    if (source[k] == -1) {      for (int i = 1; i &lt;= n; i++) {        if (!use[i]) {          use[i] = true;          tmp[k] = i;          dfs(k + 1);          use[i] = false;        }      }    } else {      tmp[k] = source[k];      dfs(k + 1);    }  }}int find(vector&lt;int&gt; pattern, int boardingTime) {  n = pattern.size();  memset(use, 0, sizeof(use));  for (int i = 0; i &lt; n; i++) {    source[i + 1] = pattern[i];    use[source[i + 1]] = true;  }  ret = 0;  maxtime = boardingTime;  dfs(1);  return ret;}\n总结：编码能力还是可以，就是思路不是很清晰，第三题从看题到开始拍代码，花了太多时间，导致了前两题有时间优势的情况下没有把第三题 K 掉，有点可惜，接下来就是做 Division 1 了，但愿我不要在 Division 1 上出什么差错。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"用 GSLB 和 GCS 部署自己的 Serverless 博客","url":"/2020/01/11/obsidian/e7663dcb-10ef-4aaa-96cb-738304e14bfa/","content":"我们平时在选择博客的解决方案的时候，可能会考虑用一个自己云端的 VM 来作为自己博客的一个载体，在这台 VM 上安装自己要的 http 服务，比如 apache 或者 nginx，然后把自己的静态资源放在 VM 中 host 给世界各地的人。 但是这样有一个不好的地方，如果你完全不用这台 VM 呢？比如说，你只是要部署一个自己的博客，但是平时除了写博文并部署以外你不会去关心自己的那台 VM，这样的话，其实你完全没有必要用 VM 的解决方案，可以直接考虑 Storage 的解决方案。 所谓的 Storage 解决方案就是，将自己的静态网页资源放在 Storage Service 中，国内可以考虑 Google Storage，国内可以考虑阿里 OSS 等解决方案商，然后通过一个 Loader Balancer 来做自己的静态资源的路由。\n接下来，我将介绍一种通过 Storage Service 和 Load Balancer 结合的解决方案，让我们不用考虑自己的 VM 资源，不用考虑维护自己的云主机。\n\n 原理\n\nStorage Service\n\n它是用来接管用户的静态资源的一种服务，通常可以用来存储网站的静态资源，或者是一个 PaaS 解决方案商的单结点的配置、或者是其它资源的 Archive 等，在目前我们现在的需求下，我们要的是一个可以方便只读访问的资源的集合，明显这是一个比较好的不需要买服务器的一个方式。\n另外，通常来说 Storage Service 都是按资源的大小来付费的，这也是一个比 VM 好的地方。\n不过要注意，有一些 Storage Service 的解决方案，是按单个文件大小付费的，比如说如果文档大小小于 4KB 就按 4KB 付费，这样的话，可能会对我们考虑费用的时候会有影响。\n\n\nLoad Balancer\n\n由云服务解决方案提供商提供的一个用于路由和负载均衡的服务，对于大量的路由网关的情况下可以考虑在 DNS 上绑定多个 Load Balancer 来做在 DNS 上的负载均衡和区域拆分。\n一般的云服务提供商会为 Load Balancer 提供一个外网 IP，在自己的 DNS 提供商上为自己的域名绑定上这个 IP 就可以实现通过这个 Load Balancer 的入口来访问自己的网站了。\n如果说，我们要部署的不是一个静态博客，而是一个有后台的博客，我们也可以通过 Load Balancer 的路由配置，将比如 /api/**/* 这样的 URL 地址绑定到我们的后台上去， 这个后台可以是一个 VM，也可以是 FaaS 中的一个函数，也可以是自己维护的 Kubernetes 集群的一个 Ingress，等等。\n通过简单的路由配置，我们可以避免自己维护 Kubernetes 或者类似的集群，也可以不用自己起一个 nginx 做路由和负载均衡了。\n\n\n\n 通过 Google Cloud 来实践\n\n首先我们要在 Google Cloud 上开通 Storage Service，并为自己的博客的域名绑定一个 bucket，并且这个 bucket 的名字需要和自己的子域名相同（注意一点，只有子域名才能做 DNS CNAME record，也就是说只能把 Serverless 的服务入口绑定到自己的子域名中，如果要考虑要根域名绑定，需要考虑 Web Forwarding 或者类似的技术，不在本文展开讨论了）。\n\n\n在创建 bucket 之前，我们需要先通过 https://search.google.com/search-console/welcome 这个网站来对自己的根域名进行自己的域名认证。\n通过域名认证之后，在 Storage -&gt; Browser 页面可以创建一个自己该网站的 bucket，其中名字是自己的博客的域名（子域名），数据模式按普通的来，权限选择默认的 Fine-grained。\n创建完了 bucket 之后，在 bucket 的详情页中选择 Permissions，添加一个用户是 allUsers 权限是 Storage Object Viewer 的记录，表示这些静态资源将可以被任何人看到。\n如果你的网站有特别的 404 页面和主页，可以通过在 bucket 列表面中，选择行末的三个点，选择 Edit website configuration，配置默认页面和 404 页面的文件路径。\n\n\n绑定之后，可以通过 gsutil 或者 hexo-deployer-gcs 来把自己的静态网站从目录 public 复制到云端的 bucket 中。\n接下来，在 Google Cloud 的控制台中，打开 Network Services -&gt; Load Balancer，创建自己的 Load Balancer，生成的静态 IP 可以通过 VPC Network -&gt; External IP addresses 来做绑定。\n最后，把自己的网站 IP 绑定到自己的域名中，通过 DNS A record 绑定即可。\n\n","categories":["development"]},{"title":"Serve Hexo blog using Docker","url":"/2018/08/02/obsidian/e8545467-024b-4b30-8a24-6aeeba33ef10/","content":"You can simply add a Dockerfile which looks like:\nFROM node:alpine AS builderRUN npm config set unsafe-perm true &amp;&amp; npm install -g hexo-cliCOPY . /appWORKDIR /appRUN npm install &amp;&amp; hexo generateFROM httpd:alpineCOPY --from=builder /app/public /usr/local/apache2/htdocs/\nThen call docker build -t image:tag . to build your own blog. To run the blog locally, you can simply run command docker run -p {host_port}:80 image:tag.\n","categories":["development"],"tags":["blog","web","hexo","docker","devops"]},{"title":"HDU2955 动态规划一维状态一维转移","url":"/2010/12/02/obsidian/e8ae26bc-c05b-49cc-b8af-1d21300303a6/","content":"这题囧了，看完了题目和样例，非常兴奋的写了个 0-1 背包上去，发现 WA 了，后来仔细想想不对，要求的是最大的安全系数 (暂且这么认为 - -)，这样定义的方程最有比较大的变化。\n做如下定义：\n定义 dp[i]dp[i]dp[i] 为抢了 iii 元钱的最大安全系数，注意初始化的时候 dp[0]=1dp[0] = 1dp[0]=1，其他的设置成没有访问过，这里为了好转移，我将除了 dp[0]dp[0]dp[0] 之外的 dpdpdp 元素置为 −1-1−1 。转移很好想，就是如下这个方程：\nfor (int i = 0; i &lt; n; i++) {  for (int j = max_money; j &gt;= w[i]; j--) {    if (dp[j - w[i]] != -1) { dp[j]=max(dp[j],dp[j-w[i]]*p[i];    }  }}\n注意 pip_ipi​ 表示的安全系数，这样数据中输入的并不是，所以要记得转化\n这样用 O (n^2) 的时间复杂度就可以搞定这道 dp 题。\n\n我的完整代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 11000;double dp[MAX];int vol;struct Node {  int w;  double p;} node[120];int main() {  int t, n;  double p;  scanf(\"%d\", &amp;t);  while (t--) {    scanf(\"%lf%d\", &amp;p, &amp;n);    p = 1 - p;    vol = 0;    for (int i = 0; i &lt; n; i++) {      scanf(\"%d%lf\", &amp;node[i].w, &amp;node[i].p);      vol += node[i].w;      node[i].p = 1 - node[i].p;    }    for (int i = 0; i &lt;= vol; i++) {      dp[i] = -1;    }    dp[0] = 1;    for (int i = 0; i &lt; n; i++) {      for (int j = vol; j &gt;= node[i].w; j--) {        if (dp[j - node[i].w] != -1 &amp;&amp; dp[j] &lt; dp[j - node[i].w] * node[i].p) {          dp[j] = dp[j - node[i].w] * node[i].p;        }      }    }    for (int i = vol; i &gt;= 0; i--) {      if (dp[i] &gt;= p) {        vol = i;        break;      }    }    printf(\"%d\\n\", vol);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"Codeforces Beta Round #34 解题报告","url":"/2010/10/11/obsidian/f131420e-8c75-4e71-97fd-23aeb3bb920c/","content":"嗯，今晚状态不错，除了卡最后一题以外没有什么太大的问题。\n最后一题到最后还是 wa 了，估计卡精度卡的不够好。\n\n A&nbsp;Reconnaissance 2\n好吧，水题，直接暴力，枚举相邻元素即可，注意一下最后一个和第一个相邻就好了。\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int ar[1100];int main() {  int n;  int ret = 0;  int a, b;  int now;  scanf(\"%d\", &amp;n);  for (int i = 1; i &lt;= n; i++) {    scanf(\"%d\", &amp;ar[i]);  }  ret = abs(ar[n] - ar[1]);  a = 1;  b = n;  for (int i = 1; i &lt; n; i++) {    now = abs(ar[i] - ar[i + 1]);    if (now &lt; ret) {      ret = now;      a = i;      b = i + 1;    }  }  printf(\"%d %d\\n\", a, b);  return 0;}\n B Sale\n这题还是水，贪心，直接找到最小的 mmm 个加起来，注意要小于 000 的，大于等于 000 的就 break，先排序。\n注意 nnn 和 mmm 双重限制，i&lt;ni&lt;ni&lt;n 和 j&lt;mj&lt;mj&lt;m\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;int ar[1100];int main() {  int n, m;  int ret = 0;  scanf(\"%d%d\", &amp;n, &amp;m);  for (int i = 0; i &lt; n; i++) {    scanf(\"%d\", &amp;ar[i]);  }  sort(ar, ar + n);  for (int i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m; i++) {    if (ar[i] &lt; 0) {      j++;      ret -= ar[i];    } else {      break;    }  }  printf(\"%d\\n\", ret);  return 0;}\n C&nbsp;Page Numbers\n这题直接排序，找相邻的两个数字是不是连在一起的，是就归在一起，否则新开一个区间，把原来的区间打印出来。\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;char s[11000] = {0};int ar[120], n = 0;void hash() {  int now;  for (int i = 0; s[i]; i++) {    now = 0;    while (s[i] &amp;&amp; s[i] != ',') {      now = now * 10 + s[i++] - '0';    }    ar[n++] = now;  }}int main() {  gets(s);  hash();  int fi, se;  bool flag = false;  sort(ar, ar + n);  fi = se = ar[0];  for (int i = 1; i &lt; n; i++) {    if (ar[i] == ar[i - 1] || ar[i] == ar[i - 1] + 1) {      se = ar[i];    } else {      if (flag)        putchar(',');      else        flag = true;      if (fi == se)        printf(\"%d\", fi);      else        printf(\"%d-%d\", fi, se);      fi = se = ar[i];    }  }  if (flag)    putchar(',');  else    flag = true;  if (fi == se)    printf(\"%d\", fi);  else    printf(\"%d-%d\", fi, se);  puts(\"\");  return 0;}\n D&nbsp;Road Map\n基础图论，建立一颗树，注意根是 r1r_1r1​，第一步就是连边，然后直接从 r2r_2r2​ 开始 DFS，记录父亲就可以了，由于 nnn 很大，开成邻接表。\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 51000;struct Edge {  int num, ne;} e[2 * MAX];int p[MAX], K;int val[MAX], vis[MAX] = {0};void add(const int&amp; u, const int&amp; v) {  e[K].num = v;  e[K].ne = p[u];  p[u] = K++;}void dfs(int k, int fa) {  val[k] = fa;  for (int i = p[k]; i != -1; i = e[i].ne) {    if (!vis[e[i].num]) {      vis[e[i].num] = true;      dfs(e[i].num, k);    }  }}int main() {  int n, r1, r2;  int x;  scanf(\"%d%d%d\", &amp;n, &amp;r1, &amp;r2);  for (int i = 1; i &lt;= n; i++) p[i] = -1;  K = 0;  for (int i = 1; i &lt;= n; i++) {    if (i == r1) continue;    scanf(\"%d\", &amp;x);    add(i, x);    add(x, i);  }  vis[r2] = true;  dfs(r2, 0);  bool done = false;  for (int i = 1; i &lt;= n; i++) {    if (i == r2) continue;    if (done)      putchar(' ');    else      done = true;    printf(\"%d\", val[i]);  }  puts(\"\");  return 0;}\n总结：恶心模拟还是没写够 - -，计算几何太薄弱 - -\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"POJ2253 的 Kruskal 做法","url":"/2010/08/13/obsidian/f474d159-b39f-4099-8256-24bcfa871b6e/","content":"许多分类，把这题分到了最短路里面，也看过一些用 Floyd、SPFA 的写法，但是我觉得，这题没必要想太复杂，直接建立最小生成树，在建树的过程中，如果加入了一条边，使得起点和终点连通了，那么这条边一定是最大的那条，也就是答案。\n我的代码如下，每次加入一条边，判断 0、1 的连通性。\n\n#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std;struct Edge {  int from;  int to;  double weight;  bool operator&lt;(const Edge&amp; edge) const { return weight &lt; edge.weight; }};const int MAX = 201;int n, cnt;int p[MAX], rank[MAX];Edge edge[MAX * MAX];double x[MAX], y[MAX];void Init() {  for (int i = 0; i &lt; n; i++) {    p[i] = i;    rank[i] = 0;  }}void Link(int x, int y) {  if (rank[x] &lt; rank[y])    p[x] = y;  else {    p[y] = x;    if (rank[x] == rank[y]) rank[x]++;  }}int Find(int x) {  if (p[x] != x) p[x] = Find(p[x]);  return p[x];}void Union(int x, int y) { Link(Find(x), Find(y)); }double Kruskal() {  sort(edge, edge + cnt);  Init();  for (int i = 0; i &lt; cnt; i++) {    if (Find(edge[i].from) != Find(edge[i].to)) Union(edge[i].from, edge[i].to);    if (Find(0) == Find(1)) {      return edge[i].weight;    }  }  return 0.0;}int main() {  double ret;  int cas = 1;  while (scanf(\"%d\", &amp;n), n) {    for (int i = 0; i &lt; n; i++) scanf(\"%lf%lf\", &amp;x[i], &amp;y[i]);    cnt = 0;    for (int i = 0; i &lt; n; i++)      for (int j = i + 1; j &lt; n; j++) {        edge[cnt].from = i;        edge[cnt].to = j;        edge[cnt].weight =            sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));        cnt++;      }    ret = Kruskal();    printf(\"Scenario #%d\\n\", cas++);    printf(\"Frog Distance = %.3f\\n\\n\", ret);  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"POJ3250 从多个方面考虑同一问题","url":"/2010/12/07/obsidian/f4acddbb-786d-44fd-9ba6-7fbdebded69b/","content":"有很多的方法过这题，以下介绍三种方法，主要思路是将序列反转（其实不反转也没什么），然后去找第 iii 个元素左边靠最右的比这个元素大的位置 jjj，那么 i−j+1i-j+1i−j+1 就是第 iii 个元素对应的解。\n\n第一种方法：利用线段树动态更新，完成上部分的查询，复杂度 O(nlg⁡n)O(n \\lg n)O(nlgn)。\n对线段树处理这类问题的方法就不详细说明了，想要了解的，看这篇文章\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 80001;const int oo = 0x3f3f3f3f;struct Node {  int l, r, val;} seg[MAX &lt;&lt; 2];int h[MAX];void init(int k, int l, int r) {  seg[k].l = l;  seg[k].r = r;  seg[k].val = -1;  if (l == r) {    return;  }  int mid = (l + r) &gt;&gt; 1;  init(k &lt;&lt; 1, l, mid);  init(k &lt;&lt; 1 | 1, mid + 1, r);}void add(int k, int idx) {  if (seg[k].l == seg[k].r) {    seg[k].val = idx;    return;  }  int mid = (seg[k].l + seg[k].r) &gt;&gt; 1;  if (idx &lt;= mid)    add(k &lt;&lt; 1, idx);  else    add(k &lt;&lt; 1 | 1, idx);  if (seg[k &lt;&lt; 1 | 1].val != -1 &amp;&amp; h[seg[k &lt;&lt; 1 | 1].val] &gt;= h[seg[k &lt;&lt; 1].val])    seg[k].val = seg[k &lt;&lt; 1 | 1].val;  else    seg[k].val = seg[k &lt;&lt; 1].val;}int read(int k, int idx, int v) {  if (seg[k].l &gt; idx) return -1;  if (h[seg[k].val] &lt; v) return -1;  if (seg[k].l == seg[k].r) return seg[k].val;  int mid = (seg[k].l + seg[k].r) &gt;&gt; 1;  if (idx &gt; mid &amp;&amp; h[seg[k &lt;&lt; 1 | 1].val] &gt;= v) {    return read(k &lt;&lt; 1 | 1, idx, v);  } else {    return read(k &lt;&lt; 1, idx, v);  }}int main() {  int n;  long long ret = 0;  scanf(\"%d\", &amp;n);  h[0] = oo;  for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;h[i]);  reverse(h + 1, h + n + 1);  init(1, 0, n);  add(1, 0);  for (int i = 1; i &lt;= n; i++) {    ret += i - read(1, i - 1, h[i]) - 1;    add(1, i);  }  printf(\"%lld\\n\", ret);  return 0;}\n第二种方法：利用一个单调栈，栈内维护一个递减的区间，记录在此元素之前比其大的元素序列的下标。新的元素入队，如果栈顶元素大于这个入队元素，那么结果就加上这个元素的下标减去栈顶元素下标再减去 111，否则栈顶元素出栈，以此类推。算法复杂度是 O(n)O(n)O(n) 的。\n算法实现其实很简单，只要维护一个栈，用 top 表示栈顶下标就可以了。\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 80005;const int oo = 0x3f3f3f3f;int st[MAX], h[MAX];int main() {  int n;  scanf(\"%d\", &amp;n);  h[0] = oo;  for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;h[i]);  reverse(h + 1, h + 1 + n);  int top = 0;  long long ret = 0;  st[top++] = 0;  for (int i = 1; i &lt;= n; i++) {    while (h[st[top - 1]] &lt; h[i]) top--;    ret += i - st[top - 1] - 1;    st[top++] = i;  }  printf(\"%lld\\n\", ret);  return 0;}\n第三种方法：利用并查集的思路直接做。记录 rir_iri​ 表示第 iii 个元素可以到达的最右边的下标，那么每次利用下面的方式压缩路径：\nr[i] = i;while (h[i] &gt; h[r[i] + 1]) r[i] = r[r[i] + 1];\n细节处理看我的代码，算法复杂度是 O(n×α(n))O(n \\times \\alpha(n))O(n×α(n)) 的。\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 80005;const int oo = 0x3f3f3f3f;int r[MAX], h[MAX];int main() {  int n;  long long ret = 0;  scanf(\"%d\", &amp;n);  h[n] = oo;  for (int i = 0; i &lt; n; i++) scanf(\"%d\", &amp;h[i]);  r[n] = n;  for (int i = n - 1; i &gt;= 0; i--) {    r[i] = i;    while (h[i] &gt; h[r[i] + 1]) r[i] = r[r[i] + 1];    ret += r[i] - i;  }  printf(\"%lld\\n\", ret);  return 0;}\n三个算法比较：\n对于第一个算法肯定是最慢的，毕竟 O(nlg⁡n)O(n \\lg n)O(nlgn) 的时间复杂度加上线段树的较大常数，和下面两个 O(n)O(n)O(n) 或者近似 O(n)O(n)O(n) 的算法来比，会逊色很多。\n从后两个算法运行时间上看，O(n×α(n))O(n \\times \\alpha(n))O(n×α(n)) 的第三种算法反而更快，可能是我单调栈常数太大了，或者我的序列反转过的原因。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"暑期集训总结","url":"/2010/08/29/obsidian/f775af2d-a383-4f0a-86ee-43959c3ba8e4/","content":"持续一个半月的暑期 ACM 集训暂时告一段落，想想也改把平时遇到的问题进行总结了。。\n在这个暑期的集训中，我们的能力可以说是发生了质的变化，想想去年刚接触 ACM 的时候做的趣味赛，以及前半年参加的校赛，从校初赛 5 题惊险出线到现在可以和队友在一起切题，感觉就是一眨眼间的事情。\n这最后的大半个月，我和两个队友基本上每天都做一套题，过题数从刚开始的 3、4 道到现在的 5、6 道，可以说我们在成长，整个集训队的孩子们都在成长。而在这个过程中，也暴露出了许多的问题，在此，我做出如下总结：\n\n\n题目的意思最重要，看题是整场比赛的开始，更是做好整场比赛的前提，我们队不止一次因为看错题目，送去了不该送去的罚时，可以只有看懂题意，才能理清思路，才能拍好代码，拍稳代码。此外，不能对题目厌烦，这样会大大地影响比赛时的状态和看题的速度，比赛的时候，不仅拍代码要快，看题也要快，Top Coder 之所以受算法界人士的欢迎就是因为它注重看题和拍代码的速度，而 TC 也是提升自己代码能力的一个好渠道。\n做题要果断，当你面对一题通过率极高并且已经过了很多人的题目，但你觉得暴力的时间复杂度太高时，也要敢于试验暴力算法，或者通过暴力算法找到规律，不能傻呆着想如何优化，你要想既然大家都可以过，我们也可以。\n要非常清楚自己队友的能力范围，我们队也出现过有了思路而觉得自己队友写不出，而换一个麻烦的思路的情况，这样会给队伍带来不必要的损失。往往就是这个损失，让一个队伍的排名比期望值相差过大。\n代码要稳，不管是简单的线段树，树状数组，还是难的计算几何和网络流，只要自己会写，就要写稳，速度要以稳为前提，如果代码不稳，即使速度很快，也要浪费更多的时间去 Debug，这也是不可取的。\n平时做题和比赛完全是两码事，不要觉得自己在 OJ 刷了多少题就可以在比赛的时候得到好名次，OJ 是用来练习自己擅长或者自己分配的类型的题目，而比赛才是王道，只有通过不断的比赛。才能让一个队伍成长的飞快。比赛的时候那种紧张激烈的氛围可以让一个队伍不断地积累到经验，可以让一个队伍的队员之间的配合更加的默契。记住一点，想要提高的更快，在平时在 OJ 做题之外，要积极参加各大赛事，现在许多学校都有举办月赛，TC 举办周赛，这些比赛都可以参加。\n基本功要扎实，这点我可能也比较缺，当你的基本功扎实了，那基本上不会排错代码，代码错误的地方会明显变少。\n队友之间的分工十分的重要，在什么时间，谁是主力，这要非常的明白，比如你的一个队友排简单题很快很稳，那么比赛前期就必须让他当主拍，又比如，你的一个队友擅长网络流或者计算几何，那么后期他就是你队伍的主力了，毕竟到后期，这些难题会成为制胜的关键。另外，队友之间的配合默契又要体现在分工上，每个人都要有各自擅长的地方，但是又不能太独立，不然遇到问题没办法让队友来帮忙查代码。\n看题顺序是个很讲究的问题，将所有题目分成三份，每个人看一些，当看到题目的时候标记上它属于什么类型的题目，当看到简单题的时候，要果断地把题扔给擅长拍此类问题的队友，然后继续往下看。要坚持把全部题目看完，不管是不是难题，如果遇到会做的题目，但是这题提交数还是 0 的时候，完全不要觉得这题多难，觉得可以拍，而简单题都解决了 (或者这题本身就是一道简单题)，那么你完全可以之间拍这题。\n\n在此，我预祝 UESTC 的全部队员在 Regional 上取得好成绩！\n","categories":["杂谈","ICPC总结"],"tags":["CSDN","ICPC","杂谈"]},{"title":"POJ 1797 条件最大生成树","url":"/2010/11/18/obsidian/f89744a2-03ab-43c5-b486-fce5240bf5fc/","content":"这题做的囧死，看了样例很兴奋的写了个 dijkstra 交上去 WA，重新看了下题目，发现是每条路都有一个最大承载量，好吧，我又想错了，发现不是网络流，因为样例用最大流说不通，再仔细看了一遍题目，发现是叫你找一条路使得单条路的流量最大，果断写了个最大生成树，觉得最大生成树的最小边就是解，叫上去，再次 WA。\n想了一会儿才发现不对，如果有一条路流量很大，但是这条路建出来的时候生成树没有建好呢？后来在 Kruskal 函数里加了一句很重要的话，果断 AC。。。。。\n本题的思路就是求最大生成树，当 111 和 nnn 在一个集合里的时候就返回最小边权，这个边权就是解。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int MAX = 1100;const int oo = 0x3f3f3f3f;struct Edge {  int u, v, len;  bool operator&lt;(const Edge&amp; e) const { return len &gt; e.len; }  void read() { scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;len); }} e[MAX * MAX];int p[MAX], rank[MAX], n, m;void init() {  for (int i = 1; i &lt;= n; i++) {    p[i] = i;    rank[i] = 0;  }}int find(int x) { return p[x] = x == p[x] ? p[x] : find(p[x]); }void Link(int x, int y) {  if (rank[x] &gt; rank[y]) {    p[y] = x;  } else {    p[x] = y;    if (rank[x] == rank[y]) {      rank[y]++;    }  }}bool merge(int x, int y) {  int px = find(x);  int py = find(y);  if (px == py) {    return false;  }  Link(px, py);  return true;}int Kruskal() {  int ret = 0;  int cnt = 1;  init();  sort(e, e + m);  for (int i = 0; i &lt; m &amp;&amp; cnt &lt; n; i++) {    if (merge(e[i].u, e[i].v)) {      cnt++;      ret = e[i].len;    }    if (find(1) == find(n)) {      break;    }  }  return ret;}int main() {  int t, cnt = 1;  bool done = false;  scanf(\"%d\", &amp;t);  while (t--) {    if (done) {      puts(\"\");    } else {      done = true;    }    scanf(\"%d%d\", &amp;n, &amp;m);    for (int i = 0; i &lt; m; i++) {      e[i].read();    }    printf(\"Scenario #%d:\\n\", cnt++);    printf(\"%d\\n\", Kruskal());  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"跨 Kubernetes 集群对接 Vault by Hashicorp","url":"/2024/05/22/obsidian/f965de4e-1a74-49d7-b49a-ca27215a89e5/","content":"这篇文中，我将简单介绍如何在 Kubernetes 集群中通过 Bitnami 社区提供的 Helm Chart 搭建一个 Vault by Hashicorp 服务，并在另外一个 Kubernetes 集群中连接、读取它上面的密钥。\n在理解该篇文章之前，你可能需要有对 Kubernetes 以及 Helm 最基本的了解，如果你对这两者不怎么熟悉，可以到 Kubernetes 官方网站 [1]，以及 Helm 的官方网站 [2]，或者其它 Kubernetes 社区去了解更多的内容。在这篇文章中，我基于 Kubernetes &gt;= 1.24 以及 Helm &gt;= 3.8 进行展开说明。\n Vault by Hashicorp 简介\nVault by HashiCorp[3] （下文我们简称之为 Vault）是一个专注于安全性的工具，用于存储和管理敏感信息，包括但不限于令牌、密码、证书和加密密钥。它通过多种方式（UI、CLI 和 HTTP API）提供对这些敏感数据的访问控制，确保数据的安全性和保密性。用户可以通过这些接口来安全地存储、检索和管理他们的秘密数据，同时确保对这些数据的访问是经过严格控制的。\n对于 Kubernetes 来说，我们可以配置让它和 Vault 对接，来让特定的服务账号可以访问特定的 KV 密钥，方便不同团队有各自密钥的修改、查看权限，可以有效避免运维人员 “一家独大” 或者说只有他一个人可以修改配置而什么事都让他来做的情况。\n\n 快速搭建 Vault\n我们可以用 Bitnami 社区提供的 vault 应用 [4] 直接部署一个可以让我们快速上手的 Vault 服务，为了方便配置，我以 UI 配置的方式来介绍 Vault 服务内部所有的配置流程。\n 准备配置清单\n首先，我们可以查看 Chart 的 values 模板，这里提供一个相对比较精简的配置清单，为了方便这里我用了 local path provisioner[5] 作为存储类 [6]，你可以根据自己集群提供的不同的存储类修改 global.storageClass 配置。把如下文件存在 vault.yaml 中：\nglobal:  storageClass: local-pathserver:  image:    tag: 1.16.2-debian-12-r3  # extraEnvVars:  #   - name: VAULT_LOG_LEVEL  #     value: trace  ingress:    enabled: true    hostname: vault.example.com    ingressClassName: nginx    tls: false      resources:    requests:      cpu: 50m      memory: 128Mi    limits:      cpu: 1      memory: 1Giinjector:  enabled: false\n要注意的有几点：\n\n你需要根据你当前获取到的 bitnami/vault 应用配置中的镜像标签，来修改 server.image.tag 配置，一般来说我们是建议锁定版本的，以防出现服务不兼容的情况。\n我在配置中保留了日志等级的配置，如果有必要，可以取消注释。\n在正式使用的时候，server.ingress.tls 是需要配置成 true 的，而目前 Bitnami 的 Chart 配置不支持自定义 TLS 密钥的名称，需要用域名加 -tls 后缀来让生成的 ingress 支持 HTTPS，比如说你的域名是 vault.example.com，那么需要创建一个 TLS 证书 [7][8]，名称为 vault.example.com-tls。\n在这篇文章中，我们以跨集群为例子，所以我在这边把 injector 禁用了，另外目前 Bitnami 提供的 Injector 的服务配置有问题，只支持在同一个命名空间下执行相关的容器，用官方的 Injector 可以解决。\n\n 部署及初始化\n接下来，我们通过如下命令部署 Vault：\nkubectl create ns vaulthelm upgrade --install -n vault \\    vault oci://registry-1.docker.io/bitnamicharts/vault \\    -f vault.yaml\n等待服务启动的过程中，可以通过 kubectl -n vault get pods 查看运行状态，当服务启动完之后它应该是一个 “未就绪” 的状态：\nNAME             READY   STATUS    RESTARTS   AGEvault-server-0   0/1     Running   0          2m\n接下来，我们需要初始化我们的仓库：\nkubectl -n vault exec -it vault-server-0 -- \\    vault operator init -key-shares=5 -key-threshold=3\n这个命令会输出 5 个 unseal keys，以及一个 initial root token，请妥善保管。当初始化完之后，我们需要用这些 keys 来做 unseal 操作：\nkubectl -n vault exec -it vault-server-0 -- \\    vault operator unseal\n根据你初始化时传入的 -key-threshold 参数，你可能需要多次执行该命令，每次拿不同的 key 进行 unseal，每次运行成功之后，会输出进度。当 Vault 初始化成功之后，你可以通过 kubectl -n vault get pods 看到它已经正常运行了：\nNAME             READY   STATUS    RESTARTS   AGEvault-server-0   1/1     Running   0          5m\n 题外话：保障自己的服务安全\n一般来说 Vault 服务是只需要对特定的用户以及服务开放的，所以你可以配置 Ingress Annotations 来让它只对特定的 IP 开放，比如说以 nginx 为例：\n server:   # ...   ingress:     enabled: true+    annotations:+      nginx.ingress.kubernetes.io/whitelist-source-range: 192.168.14.64/32,192.168.14.69/32     hostname: vault.example.com   # ...\n在以上的配置例子中，我们限制了 Vault 服务器可访问的客户端 IP 地址的 CIDR[9]。\n 创建我们的密钥以及策略\n在 Vault 服务首页的左边侧边栏中，点击 Secrets Engines 我们可以创建一个新的密钥引擎，比如说我们这里创建一个名为 kv 的密钥引擎，它的类型是 KV：\n\n进入这个密钥引擎，我们可以添加自己想要的密钥内容，并自定义内容对应的路径，其中路径是用于策略管控的基本单位。\n接下来，打开左边侧边栏的 Policies，创建一个名为 demo-policy 的 ACL 策略，内容如下：\npath \"kv/data/demo/*\" {  capabilities = [\"read\", \"list\"]}path \"kv/metadata/demo/*\" {  capabilities = [\"list\"]}\n\n在该策略中，我们允许绑定该策略的角色访问 kv 密钥引擎下的 demo 子目录。现在你可以尝试在 kv 中添加一些密钥了，密钥的路径可以填写比如 demo/secret 这样的值，使得该策略生效。\n 将我们的工作集群接入 Vault\n 基于 Kubernetes 的认证流程原理\n\n假设如上图所示，我们的工作 Kubernetes 集群名称为 worker-cluster，整条链路的简单说明如下：\n\n首先，当工作集群创建了一个新的 Pod 的时候，运行在该工作集群上的 Vault Agent Injector[10] 会被创建出来，目前支持 sidecar 模式或者 init container 一次性注入的模式。\nVault Agent Injector 拿着自己服务账号的临时凭证，请求 Vault 服务，进行鉴权。\nVault 服务收到认证请求的时候，反向向工作集群的 API 服务请求 Token Review API[11]，来确认服务账号凭证的合法性。\n\n 准备服务账号\n正如我们在上个章节中所说， Vault 服务是需要一个拥有 Token Review API 权限的服务账号来进行 API 调用，所以我们需要准备如下的服务账号以及对应的 RBAC 配置，我们将它存储在 service-account.yaml 中：\napiVersion: v1kind: ServiceAccountmetadata:  name: vault-token-reviewer  namespace: vault---apiVersion: v1kind: Secretmetadata:  name: vault-token-reviewer-token  namespace: vault  annotations:    kubernetes.io/service-account.name: vault-token-reviewertype: kubernetes.io/service-account-token---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRoleBindingmetadata:  name: vault-token-reviewerssubjects:  - kind: ServiceAccount    name: vault-token-reviewer    namespace: vaultroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: system:auth-delegator\n接下来，我们用如下命令让它生效，并抽取出对应的凭证：\nkubectl apply -f service-account.yamlkubectl -n vault get secrets vault-token-reviewer-token \\    -o jsonpath='{.data.token}' | base64 -d &gt;token.txtkubectl -n vault get secrets vault-token-reviewer-token \\    -o jsonpath='{.data.ca\\.crt}' | base64 -d &gt;ca.crt\n生成出来的 token.txt 和 ca.crt 就是这个服务账号的凭证以及 CA 证书了。\n 配置工作 Kubernetes 集群的认证方式\n切换回 Vault 服务视角，我们已经把服务起起来了，你可以通过 https://vault.example.com 来访问你的 Vault UI，接下来我们用 initial root token 登录，在左侧边栏中选择 Access、Authentication Methods，在右边点击 Enable new method 创建一个新的认证方式。\n在创建的时候，选择 Kubernetes，path 可以选择一个非默认的名称，比如说 kubernetes/worker-cluster：\n\n接下来进入配置页，填入工作集群 API 服务的地址，以及我们刚才在工作集群中生成的服务账号的 CA 证书、token：\n\n注意\n由于我们的 Vault 服务并不是搭在工作集群中，也就是说他们用的不是同一个集群的 API 服务，我们需要勾上 “Disable use of local CA and service account JWT” 选项，Vault 服务用自己的服务账号来访问我们的工作集群。\n\n接着我们可以为它配置我们要用的服务的角色，切换到 Roles 标签，点击 Create role 创建一个新的角色：\n\n在上述的配置中，有如下几个配置项需要考虑：\n\nName：角色的名称，用于 Pod 访问密钥数据时的主体指明。\nBound service account name：绑定的服务账号，这里指的是工作集群目标 Pod 用到的服务账号。\nBound service account namespaces：绑定的命名空间，同时这里指的也是目标 Pod 所在的命名空间。\nDo Not Attach ‘default’ Policy To Generated Tokens：一般来说，不是特别建议自动加载默认的策略给服务。\nGenerated Token’s Policies：该角色绑定的策略，在这里我们用之前创建的 demo-policy 策略。\nGenerated Token’s Type：如果是服务在用，填 service，如果是类似 Job 这样的自动化在用，可以用 batch。\n\n 部署 Vault Agent Injector\n接下来，我们需要在工作集群中部署 Vault Agent Injector，把如下的配置存放在 vault-injector.yaml 中：\nglobal:  enabled: false  externalVaultAddr: https://vault.example.cominjector:  enabled: true  image:    tag: 1.4.1  agentImage:    tag: 1.16.1  agentDefaults:    cpuLimit: 500m    cpuRequest: 5m    memLimit: 128Mi    memRequest: 64Mi  authPath: auth/kubernetes/woker-cluster\n如上的配置中，injector.*.tag 也是为了固定镜像版本而存在的，而 injector.authPath 是我们在第一章节中创建的认证方式的认证路径，并加上 auth/ 前缀。\n然后，我们可以用官方的 Helm Chart[12] 来部署 Injector：\nhelm repo add hashicorp https://helm.releases.hashicorp.comhelm upgrade --install -n vault \\    vault hashicorp/vault \\    -f vault-injector.yaml\n通过 kubectl -n vault get pods 确认 Injector 已经正常启动：\nNAME                                   READY   STATUS    RESTARTS   AGEvault-agent-injector-75fc4687c-qdxdj   1/1     Running   0          3m\n关于 Bitnami 的 Injector\nBitnami 的 Vault 应用也有 Injector 的实现，但是它不支持类似 externalVaultAddr 的配置，所以这里我直接以官方的为例子。\n\n 尝试获取我们的密钥\n接下来我们可以编写一个简单的 Deployment 来难我们的服务可以拿到 Vault 中的密钥：\napiVersion: apps/v1kind: Deploymentmetadata:  name: vault-demo  namespace: default  labels: &amp;labels    app.kubernetes.io/instance: vault-demospec:  selector:    matchLabels: *labels  template:    metadata:      annotations:        vault.hashicorp.com/agent-inject: \"true\"        vault.hashicorp.com/agent-pre-populate: \"true\"        vault.hashicorp.com/agent-pre-populate-only: \"true\"        vault.hashicorp.com/agent-inject-template-mixed.yaml: |          {{- range secrets \"kv/demo\" }}          # {{ .  }}          {{- with secret (printf \"kv/demo/%s\" .) }}          ---          {{ .Data.data | toYAML }}          {{- end }}          {{- end }}        vault.hashicorp.com/role: demo      labels: *labels    spec:      serviceAccountName: default      containers:        - image: busybox:1.28          name: demo          command:            - sh            - -c          args:            - |              set -euo pipefail              cat /vault/secrets/mixed.yaml              trap : TERM INT              tail -f /dev/null &amp; wait          resources:            limits:              cpu: 10m              memory: 16Mi            requests:              cpu: 10m              memory: 16Mi\n在上述配置清单中，做一下额外的简单说明：\n\n需要保证使用的 serviceAccountName 以及 namespace 和角色配置一致。\nvault.hashicorp.com/role 应该和角色名一致。\nvault.hashicorp.com/agent-pre-populate 和 vault.hashicorp.com/agent-pre-populate-only 两个注解可以保证使用 init container 而不是 sidecar 的形式进行注入，这样服务运行中，Injector 就不会占用额外的资源了。\nvault.hashicorp.com/agent-inject-template-mixed.yaml 注解是一个简单的模板，把所有的密钥用 YAMl 文件的形式体现，并合并。具体和模板相关的配置，可以参考官方的文档 [13]，以及 Consul Templating Language 的官方文档 [14]。\n\n 参考资料\n\nVault configuration\nEssential Vault 中文手册\nThe Vault Secrets Operator on Kubernetes\nApply a template to the injected secrets\nVault Injector Annotations\nIntegrate a Kubernetes cluster with an external Vault\nManage Kubernetes Secrets using Vault\n\n\n\n\nhttps://kubernetes.io/ ↩︎\n\nhttps://helm.sh/ ↩︎\n\nhttps://www.vaultproject.io/ ↩︎\n\nhttps://github.com/bitnami/charts/tree/main/bitnami/vault ↩︎\n\nhttps://github.com/rancher/local-path-provisioner ↩︎\n\nhttps://kubernetes.io/zh-cn/docs/concepts/storage/storage-classes/ ↩︎\n\nhttps://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/ ↩︎\n\nhttps://kubernetes.io/docs/concepts/configuration/secret/#tls-secrets ↩︎\n\nhttps://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing ↩︎\n\nhttps://developer.hashicorp.com/vault/docs/platform/k8s/injector ↩︎\n\nhttps://kubernetes.io/zh-cn/docs/reference/kubernetes-api/authentication-resources/token-review-v1/ ↩︎\n\nhttps://github.com/hashicorp/vault-helm ↩︎\n\nhttps://developer.hashicorp.com/vault/docs/agent-and-proxy/agent/template ↩︎\n\nhttps://github.com/hashicorp/consul-template/blob/v0.28.1/docs/templating-language.md ↩︎\n\n\n\n","categories":["运维"],"tags":["软件开发/安全","云计算/Kubernetes","项目管理/部署"]},{"title":"hust1017 Dancing Links","url":"/2010/10/04/obsidian/f9e5528d-8fb9-410a-b87b-5dc84fa00548/","content":"这题因为建图卡了好久，Dancing Links 的入门题，不想多说什么。想了解的请参看 Knuth 的论文。\n这里学会了一个很方便的双向链表插入算法，如果要将 xxx 插入到双向链表中，只要先更新 xxx 的指针域，然后调用 dlx 的第二步就可以了。\n在 init 函数有所实现。\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;using namespace std;const int nColumn = 1100;const int nRow = 1100;const int nNode = nRow * nColumn;const int head = 0;const int oo = 0x3f3f3f3f;int right[nNode], left[nNode], up[nNode], down[nNode];int cnt[nColumn];int result[nNode], nResult;int row[nRow][nColumn], column[nColumn][nRow];int cntRow[nRow], cntColumn[nColumn];int nR, nC;int getColumn(int id) {  if (id % nC)    return id % nC;  else    return nC;}int getId(int r, int c) { return r * nC + c; }int getRow(int id) { return (id - 1) / nC; }void remove(const int&amp; x) {  left[right[x]] = left[x];  right[left[x]] = right[x];  for (int r = down[x]; r != x; r = down[r]) {    for (int c = right[r]; c != r; c = right[c]) {      up[down[c]] = up[c];      down[up[c]] = down[c];      cnt[getColumn(c)]--;    }  }}void resume(const int&amp; x) {  for (int r = up[x]; r != x; r = up[r]) {    for (int c = left[r]; c != r; c = left[c]) {      cnt[getColumn(c)]++;      up[down[c]] = c;      down[up[c]] = c;    }  }  left[right[x]] = x;  right[left[x]] = x;}bool dfs(const int&amp; k) {  if (right[head] == head) {    nResult = k;    return true;  }  int S = oo, x = 0;  for (int t = right[head]; t != head; t = right[t]) {    if (cnt[t] &lt; S) {      S = cnt[t];      x = t;    }  }  remove(x);  for (int r = down[x]; r != x; r = down[r]) {    result[k] = getRow(r);    for (int c = right[r]; c != r; c = right[c]) {      remove(getColumn(c));    }    if (dfs(k + 1)) return true;    for (int c = left[r]; c != r; c = left[c]) {      resume(getColumn(c));    }  }  resume(x);  return false;}bool init(int r, int c) {  int id, pre;  // deal with list heads  left[head] = c;  right[head] = 1;  for (int i = 1; i &lt;= c; i++) {    left[i] = i - 1;    right[i] = (i + 1) % (c + 1);    up[i] = down[i] = i;    cnt[i] = cntColumn[i];    if (cnt[i] == 0) return false;  }  // deal with columns  for (int i = 1; i &lt;= c; i++) {    for (int j = 0; j &lt; cnt[i]; j++) {      id = getId(column[i][j], i);      up[id] = i;      down[id] = down[i];      up[down[id]] = id;      down[up[id]] = id;      left[id] = right[id] = id;    }  }  // deal with rows  for (int i = 1; i &lt;= r; i++) {    for (int j = 1; j &lt; cntRow[i]; j++) {      id = getId(i, row[i][j]);      pre = getId(i, row[i][j - 1]);      left[id] = pre;      right[id] = right[pre];      left[right[id]] = id;      right[left[id]] = id;    }  }  return true;}int main() {  int x;  while (~scanf(\"%d%d\", &amp;nR, &amp;nC)) {    for (int i = 1; i &lt;= nC; i++) {      cntColumn[i] = 0;    }    for (int i = 1; i &lt;= nR; i++) {      scanf(\"%d\", &amp;cntRow[i]);      for (int j = 0; j &lt; cntRow[i]; j++) {        scanf(\"%d\", &amp;x);        row[i][j] = x;        column[x][cntColumn[x]++] = i;      }    }    if (!init(nR, nC)) {      puts(\"NO\");      continue;    }    if (!dfs(0)) {      puts(\"NO\");      continue;    }    printf(\"%d\", nResult);    for (int i = 0; i &lt; nResult; i++) {      printf(\" %d\", result[i]);    }    puts(\"\");  }  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"2010 杭州赛区 1005 Code Management System","url":"/2010/09/20/obsidian/fb9d722f-4693-4743-83c6-803023a5d735/","content":"这几次比赛由于没有太好的解题策略，以至于我们队把这个水题给放走了，大部分时间都在改计算几何，到最后也没有 AC。\n这题不想说什么，很大自然的题目，就是模拟，用各种 STL 来模拟，我考虑到既然模拟了，应该不会超时吧？今天就拍了下，果断 1Y，这么暴力的方法 600 多 ms 过。\n嗯，主要是记录每个人最近一次下载代码的时间，每行更新的时间和优先级，每个人的优先级。\n懒得 hash 了，直接 map 做。\n对于 submit 操作，之前 modify 的行号全部放到一个 list 中，submit 的时候直接清空链表就可以了。。。\n\n嗯，很长的代码，不过看上去比计算几何会好很多。。。\n这题还有一个比较不好处理的是字符串的手动分割，这种题目我平时还是做比较多了，直接数长度就可以了，谁叫这题的输入格式这么的。。。呵呵呵呵。。。\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Time {  int y, m, d;  int hh, mm, ss;  Time();  Time(char* s);  bool operator&lt;(const Time&amp; t) const;  Time operator=(const Time&amp; t);  void Show();};struct Node {  int level;  string name;  Time t;};struct In {  string name;  int id;  Time t;  bool operator&lt;(const In&amp; in) const;};map&lt;string, list&lt;int&gt; &gt; mod;map&lt;string, int&gt; level;map&lt;int, Node&gt; last;map&lt;int, Node&gt;::iterator res;map&lt;string, Time&gt; sub;vector&lt;In&gt; in;vector&lt;In&gt;::iterator itin;void init();int main() {  int n, m, num;  In data;  char str[150], op[150];  string name;  while (scanf(\"%d\", &amp;n), n) {    init();    for (int i = 0; i &lt; n; i++) {      scanf(\"%s%d%d\", str, &amp;num, &amp;m);      name = str;      level[name] = num;      data.name = name;      gets(str);      for (int j = 0; j &lt; m; j++) {        gets(op);        for (int k = 0; k &lt; 21; k++) str[k] = op[k];        str[21] = 0;        data.t = Time(str);        switch (op[23]) {          case 'Y':          case 'U':            data.id = -1;            break;          case 'O':            int k = 29;            data.id = 0;            while (op[k]) {              data.id = data.id * 10 + op[k] - '0';              k++;            }            break;        }        in.push_back(data);      }    }    sort(in.begin(), in.end());    for (itin = in.begin(); itin != in.end(); itin++) {      //(itin-&gt;t).Show(); //printf(\" %s %d\\n\",(itin-&gt;name).c_str(),itin-&gt;id);      list&lt;int&gt;&amp; lst = mod[itin-&gt;name];      if (itin-&gt;id == -1) {        while (!lst.empty()) {          num = lst.front();          lst.pop_front();          if (last.find(num) == last.end() ||              last[num].level &lt; level[itin-&gt;name] ||              last[num].t &lt; sub[itin-&gt;name]) {            last[num].t = itin-&gt;t;            last[num].level = level[itin-&gt;name];            last[num].name = itin-&gt;name;          }        }        sub[itin-&gt;name] = itin-&gt;t;      } else {        lst.push_back(itin-&gt;id);      }    }    for (res = last.begin(); res != last.end(); res++) {      printf(\"%d \", res-&gt;first);      (res-&gt;second).t.Show();      printf(\" BY %s\\n\", (res-&gt;second).name.c_str());    }    puts(\"END\");  }  return 0;}Time::Time() {  y = m = d = 0;  hh = mm = ss = 0;}Time::Time(char* s) {  sscanf(s, \"[%d/%d/%d%d:%d:%d]\", &amp;y, &amp;m, &amp;d, &amp;hh, &amp;mm, &amp;ss);}bool Time::operator&lt;(const Time&amp; t) const {  if (y != t.y)    return y &lt; t.y;  else if (m != t.m)    return m &lt; t.m;  else if (d != t.d)    return d &lt; t.d;  else if (hh != t.hh)    return hh &lt; t.hh;  else if (mm != t.mm)    return mm &lt; t.mm;  else    return ss &lt; t.ss;}Time Time::operator=(const Time&amp; t) {  y = t.y;  m = t.m;  d = t.d;  hh = t.hh;  mm = t.mm;  ss = t.ss;  return *this;}bool In::operator&lt;(const In&amp; in) const { return t &lt; in.t; }void Time::Show() {  printf(\"[%04d/%02d/%02d %02d:%02d:%02d]\", y, m, d, hh, mm, ss);}void init() {  mod.clear();  in.clear();  level.clear();  last.clear();  sub.clear();}\n剩下的还有几场比赛要加油了，今晚的 Code Forces 应该可以再去混混。。。\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]},{"title":"POJ2373 动态规划","url":"/2010/12/09/obsidian/fd0c11e8-ba86-4cf2-a479-b71c2f7b1060/","content":"单调队列优化的 dp。首先我们先进行预处理，将可以合并的区间合并到一起，这个可以在 O(nlg⁡n)O(n \\lg n)O(nlgn) 的时间内完成。方法是按照 xxx 排序，然后找相邻的两个区间 (a,b)(a, b)(a,b) 和 (c,d)(c, d)(c,d) 是否满足 a&lt;da &lt; da&lt;d 并且 b&gt;cb &gt; cb&gt;c，注意这里必须严格大于才行，因为这里的区间都是开区间，如果存在 b=cb = cb=c 这样的情况，那么 b 这个点就可以分割。\n然后进行动态规划转移，令 dp[i]dp[i]dp[i] 为前 iii 个区间可以划分的最小区间数目，那么就有：\ndp[i]=min⁡{dp[i−2k]}+1,&nbsp;A≤k≤Bdp[i]=\\min\\{dp[i-2k]\\}+1,&nbsp; A \\leq k \\leq B\ndp[i]=min{dp[i−2k]}+1,&nbsp;A≤k≤B\n如果不存在这样的 kkk 值，或者 iii 是在某个区间内，那么 dp[i]dp[i]dp[i] 就为 ∞\\infty∞，注意初始化 dp[0]=1,dp[1]=∞dp[0] = 1, dp[1] = \\inftydp[0]=1,dp[1]=∞。\n运用类似多重背包的方法将 iii 划分成 222 的一个剩余类，也就是说我们可以对上式进行变形，变成如下的形式：\ndp[mod+2j]=min⁡{dp[mod+2k]}+1,A≤j−k≤Bdp[mod+2j]=\\min\\{dp[mod+2k]\\}+1, A \\leq j-k \\leq B\ndp[mod+2j]=min{dp[mod+2k]}+1,A≤j−k≤B\n这里 dp[mod+2j]dp[mod+2j]dp[mod+2j] 是个仅关于 jjj 的函数，可以用单调队列维护一定区间的最值，最后问题得到解决。\n注意这题的一些细节，首先当 LLL 为奇数的时候 dp[L]dp[L]dp[L] 与 dp[1]dp[1]dp[1] 属于同一个剩余类，那么 dp[L]dp[L]dp[L] 就为 ∞\\infty∞，所以直接可以输出 −1-1−1。其次，对于判断 iii 是否在区间内，可以用一个指针 ppp 动态向后移动的方式来判断，如果第 ppp 个区间的右边界小等于 iii，那么 ppp 就右移，知道 ppp 等于 nnn 或者右边界大于 iii 为止，这时候判断第 ppp 个区间的左边界是否比 iii 小，如果左边界小于 iii，那么 dp[i]dp[i]dp[i] 就是 ∞\\infty∞。最后，如果 dp[L]dp[L]dp[L] 等于 ∞\\infty∞ 记得输出 −1-1−1。\n这里还有一个很好的技巧，在队列中加一个哨兵 ∞\\infty∞，它的 ididid 也为 ∞\\infty∞，这样可以处理如果 i&lt;Ai &lt; Ai&lt;A 的情况，当然也可以直接预处理出对所有的 i&lt;Ai &lt; Ai&lt;A 都有 dp[i]=∞dp[i] = \\inftydp[i]=∞，注意这里枚举和 000 的同剩余类的元素要从 222 开始循环！\n\n我的代码：\n#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int MAX = 1001000;const int oo = 0x3f3f3f3f;int dp[MAX];struct Seg {  int x, y;  Seg(int x = 0, int y = 0) : x(x), y(y) {}  bool operator&lt;(const Seg&amp; seg) const { return x &lt; seg.x; }} seg[1100];int q[MAX], id[MAX], f, b;int merge(int n) {  int top = 0;  sort(seg, seg + n);  int l = seg[0].x, r = seg[0].y;  for (int i = 1; i &lt; n; i++) {    if (seg[i].x &lt; r) {      r = max(r, seg[i].y);    } else {      seg[top++] = Seg(l, r);      l = seg[i].x;      r = seg[i].y;    }  }  seg[top++] = Seg(l, r);  return top;}int main() {  int n, L, l, r, p;  scanf(\"%d%d\", &amp;n, &amp;L);  if (L &amp; 1) {    printf(\"%d\\n\", -1);    return 0;  }  scanf(\"%d%d\", &amp;l, &amp;r);  for (int i = 0; i &lt; n; i++) {    scanf(\"%d%d\", &amp;seg[i].x, &amp;seg[i].y);  }  n = merge(n);  l &lt;&lt;= 1;  r &lt;&lt;= 1;  dp[0] = 0;  f = b = 0;  p = 0;  dp[0] = 0;  for (int i = 2; i &lt; l; i += 2) dp[i] = oo;  // start with 2.  for (int i = l; i &lt;= L; i += 2) {    while (f != b &amp;&amp; i - id[f] &gt; r) f++;    while (f != b &amp;&amp; q[b - 1] &gt;= dp[i - l]) b--;    id[b] = i - l;    q[b++] = dp[i - l];    while (p &lt; n &amp;&amp; seg[p].y &lt;= i) p++;    // if q[f] is oo, not to set dp[i] = q[f]+1. else dp[i]=q[f]+1;    if (p &lt; n &amp;&amp; seg[p].x &lt; i || q[f] == oo) dp[i] = oo;  }  // for(int i=0;i&lt;=L;i+=2)printf(\"%d \",dp[i]==oo?-1:dp[i]);puts(\"\");  printf(\"%d\\n\", dp[L] == oo ? -1 : dp[L]);  return 0;}\n","categories":["ICPC题解"],"tags":["CSDN","ICPC题解"]}]